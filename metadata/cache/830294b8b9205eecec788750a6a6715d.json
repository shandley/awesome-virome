{
  "cache_date": "2025-03-17T02:21:32.306795",
  "data": "![COBRA_logo](https://github.com/linxingchen/cobra/assets/46725273/f21d1198-991c-42b2-9ec0-0ae8a662ba35)\n\nCOBRA (Contig Overlap Based Re-Assembly) is a bioinformatics tool to get higher quality viral genomes assembled from metagenomes of short paired-end reads. COBRA was written in Python. COBRA has so far only been tested on assembled contigs and scaffolds from metaSPAdes, IDBA_UD, and MEGAHIT.\n\n```\n# Developed by Dr. LinXing Chen\n# University of California, Berkeley\n# The Banfield Lab\n# Email: linkingchan@gmail.com\n```\n\n## Versions\n1. v1.2.2 (released on 2023-09-03) - initial release\n\n2. v1.2.3 (released on 2024-02-26)\n- The GC function issue due to the update of Biopython.\n- The abnormal exit in the middle of processing some samples.\n- If none of the queries was extended, the process will break. If your runs do not have the expected output files, see the log file.\n\n\n## Citation\nThe paper is out at Nature Microbiology (https://www.nature.com/articles/s41564-023-01598-2). Please cite as follows if you find COBRA is helpful for your analyses. \n```Chen, L., Banfield, J.F. COBRA improves the completeness and contiguity of viral genomes assembled from metagenomes. Nat Microbiol (2024). https://doi.org/10.1038/s41564-023-01598-2```\n\n\n## Introduction\n\n**1. Why metagenomic contigs are fragmented?**\n\nThe genomes assembled from short paired-end reads based metagenomes are usually fragmented due to (1) intra-genome repeats, (2) inter-genome shared region, and (3) within-population variations, as the widely utilized assemblers based on de Bruijn graphs, e.g., metaSPAdes, IDBA_UD and MEGAHIT, tend to have a breaking point when multiple paths are available instead of making risky extension (see example in **Figure 1**). \n\n![image](https://user-images.githubusercontent.com/46725273/111676563-8a21f180-87db-11eb-9b8c-4c63fb993936.png)\n\nFigure 1. Example of how assemblers break in assembly when within-population occurs.\n\n**2. Contigs may be joined with expected end overlap.**\n\nAccording to the principles of the abovementioned assemblers, the broken contigs have an end overlap with determined length, that is the max-kmer (maxK hereafter) used in de nono assembly for metaSPAdes and MEGAHIT, and the maxK-1 for IDBA_UD, which we termed as \"expected overlap length\" (Figures 1 and 2). \n\n* Note: as COBRA will use the information provided by paired-end reads, thus only those samples sequenced by paired-end technology should work.\n\n![image](https://user-images.githubusercontent.com/46725273/111677281-4c719880-87dc-11eb-85a9-a62906f4e10b.png)\n\nFigure 2. The \"expected overlap length\" has been documented in manual genome curation, see [Chen et al. 2020](https://genome.cshlp.org/content/30/3/315.short) for details.\n\n\n## How COBRA works\n\nCOBRA determines the \"expected overlap length\" (both the forward direction and reverse complement direction) for all the contigs from an assembly, then looks for the valid joining path for each query that users provide (should be a fraction of the whole assembly) based on a list of features including contig coverage, contig overlap relationships, and contig continuity (based on paired-end reads mapping) (Figure 3).\n\nNote that scaffolds (for example, metaSPAdes assembly) could be used as input for COBRA extension, however, we suggest not using scaffolds from IDBA_UD as the potential errors in the scaffolding step (see [Chen et al. 2020](https://genome.cshlp.org/content/30/3/315.short) for details). Thus, for IDBA_UD and MEGAHIT assembly, the contigs should be used. \n\nGiven that COBRA has only tested for contigs/scaffolds from IDBA_UD, metaSPAdes and MEGAHIT, it will be risky to use it on contigs/scaffolds from any other assemblers.\n\n![Figure 1](https://github.com/linxingchen/cobra/assets/46725273/77a8285b-cce8-45f3-8e4e-4c46c3f45354)\n\nFigure 3. The workflow of COBRA.\n\n\n## Dependencies\n* COBRA is a Python script (tested for version 3.7 or higher) that uses a list of frequently used Python packages including:\n```\nBio\nBio.Seq\ncollections\nargparse\nmath\npysam\ntime\n```\n\n* The only third-party software that COBRA will use is [BLASTn](https://blast.ncbi.nlm.nih.gov/Blast.cgi?PAGE_TYPE=BlastDocs&DOC_TYPE=Download).\n\n## Installation\nCOBRA could now be installed via different ways.\n\n* (1) git\n\n```git clone https://github.com/linxingchen/cobra.git```\n\n```cd cobra```\n\n```python cobra.py -h```\n\n\n* (2) pip\n\n```pip install cobra-meta```\n\nTo confirm the installment,\n\n```cobra-meta -h```\n\nwhich shows your something like this\n\n```\nusage: cobra-meta [-h] -q QUERY -f FASTA -a {idba,megahit,metaspades} -mink MINK -maxk MAXK -m MAPPING -c COVERAGE [-lm LINKAGE_MISMATCH] [-o OUTPUT] [-t THREADS] [-v]\n\n...\n```\n\n* (3) conda\n\n```conda create -n cobra python=3.8```\n\n```conda activate cobra```\n\n```conda install bioconda::cobra-meta``` or ```conda install linxingchen1987::cobra-meta```\n\nTo confirm the installment,\n\n```cobra-meta -h```\n\nwhich shows your something like this\n\n```\nusage: cobra-meta [-h] -q QUERY -f FASTA -a {idba,megahit,metaspades} -mink MINK -maxk MAXK -m MAPPING -c COVERAGE [-lm LINKAGE_MISMATCH] [-o OUTPUT] [-t THREADS] [-v]\n\n...\n```\n\n## Update\n* pip\n  \n```pip install --upgrade cobra-meta```\n\n* conda\n\n``` conda activate cobra``` (if cobra is the conda environment name)\n\n``` conda update cobra-meta```\n\n\n## Input files\n(1) COBRA needs four files as inputs, i.e., \n\n* ```-f/--fasta```: A fasta format file containing all the contigs from a single assembly, note that IDBA_UD and MEGAHIT usually save contigs with a minimum length of 200 bp.\n\n* ```-c/--coverage```: a two columns (separated by tab) file of the sequencing coverage of all contigs in the ```-f/--fasta``` file, example below:\n\n```contig-140_0    25.552\ncontig-140_1    42.1388\ncontig-140_2    14.6023\ncontig-140_3    15.4817\ncontig-140_4    41.2746\n...\n```\n\n* ```-q/--query```: the query contigs that the user wants COBRA to extend, could be provided in a fasta format file, or a one-column text file with the names of the query contigs. Please make sure the names are exactly the same format as in the ```-f/--fasta``` file, otherwise, COBRA may have problems extending them.\n  \n* ```-m/--mapping```: the paired-end reads mapping file of all contigs in the ```-f/--fasta``` file, could be sam or bam file.\n\n(2) and three parameters\n* ```-a/--assembler```: the name of the de novo assembler used, currently only 'idba' (for IDBA_UD), 'metaspades' (for metaSPAdes), and 'megahit' (for MEGAHIT).\n* ```-maxk/--maxk```: the largest kmer used in de novo assembly.\n* ```-mink/--mink```: the smallest kmer used in de novo assembly.\n\n\n(3) Optional flags\n* ```-lm/--linkage_mismatch```: the number of read mapping mismatches allowed when determining if two contigs were spanned by paired reads.\n* ```-o/--output```: the name of the output folder, otherwise it will be \"{```-q/--query```}.COBRA\" if not provided.\n* ```-t/--threads```: the number of threads used for BLASTn search.\n\n\n## How to obtain the mapping file\n\nThe mapping file could be obtained with tools like Bowtie2 and BBMap, please refer to the manual descriptions for details of the tools. Below is the general way to get the sorted sam/bam file, you thus need to be available to samtools (which could be get here - https://github.com/samtools/samtools).\n\nFor example, \n\n* ```contig file = \"contigs.fasta\"```\n\n* ```first read file = \"R1.fastq.gz\"```\n\n* ```second read file = \"R2.fastq.gz\"```\n\n(1) with Bowtie2 (https://github.com/BenLangmead/bowtie2)\n\n* ```bowtie2-build contigs.fasta contigs.fasta```\n\n* ```bowtie2 -p 16 -x contigs.fasta -1 R1.fastq.gz -2 R2.fastq.gz -S output.sam && samtools view -bS output.sam | samtools sort -o sorted_output.bam -```\n\n\n(2) with BBMap (https://github.com/BioInfoTools/BBMap)\n\n* ```bbmap.sh ref=contigs.fasta in1=R1.fastq.gz in2=R2.fastq.gz threads=16 out=output.sam``` (good)\n* ```samtools view -bS output.sam > output.bam```\n* ```samtools sort -o sorted_output.bam output.bam```\n\n\n##  How to obtain the coverage file\n\n(1) with jgi_summarize_bam_contig_depths\n\nOnce the sorted sam or bam file is ready, the tool of \"jgi_summarize_bam_contig_depths\" from MetaBAT (https://bitbucket.org/berkeleylab/metabat/src/master/), or could be used to obtain the coverage file, the resulting profile should be transferred to get a two-column file divided by tab.\n\n* ```jgi_summarize_bam_contig_depths --outputDepth original.coverage.txt *sam``` \n\n* ```jgi_summarize_bam_contig_depths --outputDepth original.coverage.txt *bam```\n\nThe output file from jgi_summarize_bam_contig_depths could be converted to a two-column file divided by tab using the script provided in this study (coverage.transfer.py).\n\n* ```python coverage.transfer.py -i original.coverage.txt -o coverage.txt```\n\n\n(2) CoverM \n\nCoverM is a fast DNA read coverage and relative abundance calculator focused on metagenomics applications. Usage could be found here (https://github.com/wwood/CoverM).\n\n\n(3) pyCoverM \n\npyCoverM is a simple Python interface to CoverM's fast coverage estimation functions, which could be found here (https://github.com/apcamargo/pycoverm).\n\n\n## How to run\n(1) The users can only specify the required parameters:\n\n```\ncobra-meta -f input.fasta -q query.fasta -c coverage.txt -m mapping.sam -a idba -mink 20 -maxk 140\n```\n\n(2) The users could also include the optional parameters like output name (-o), mismatch of mapped reads for linkage identification (-lm)\n\n```\ncobra-meta -f all.contigs.fasta -q query.fasta -o query.fasta.COBRA.out -c coverage.txt -m mapping.sam -a idba -mink 20 -maxk 140 -lm 2\n```\n\n```\ncobra-meta -f all.contigs.fasta -q query.fasta -o query.fasta.COBRA.out -c coverage.txt -m mapping.sam -a metaspades -mink 21 -maxk 127 -lm 2\n```\n\n```\ncobra-meta -f all.contigs.fasta -q query.fasta -o query.fasta.COBRA.out -c coverage.txt -m mapping.sam -a megahit -mink 21 -maxk 141 -lm 2\n```\n\n\n## Output files\nBelow is a general list of output files in the output folder:\n\n```\nCOBRA_category_i_self_circular_queries_trimmed.fasta\nCOBRA_category_i_self_circular_queries_trimmed.fasta.summary.txt\nCOBRA_category_ii_extended_circular_unique (folder)\nCOBRA_category_ii_extended_circular_unique.fasta\nCOBRA_category_ii_extended_circular_unique.fasta.summary.txt\nCOBRA_category_ii_extended_circular_unique_joining_details.txt\nCOBRA_category_ii_extended_failed.fasta\nCOBRA_category_ii_extended_failed.fasta.summary.txt\nCOBRA_category_ii_extended_partial_unique (folder)\nCOBRA_category_ii_extended_partial_unique.fasta\nCOBRA_category_ii_extended_partial_unique.fasta.summary.txt\nCOBRA_category_ii_extended_partial_unique_joining_details.txt\nCOBRA_category_iii_orphan_end.fasta\nCOBRA_category_iii_orphan_end.fasta.summary.txt\nCOBRA_joining_status.txt\nCOBRA_joining_summary.txt\nintermediate.files (folder)\nlog\ndebug.txt\ncontig.new.fa\n```\n\nFor all the queries, COBRA assigns them to different categories based on their joining status (detailed in the ```COBRA_joining_status.txt``` file), i.e.,\n\n* \"self_circular\" - the query contig itself is a circular genome.\n* \"extended_circular\" - the query contig was joined and extended into a circular genome.\n* \"extended_partial\" - the query contig was joined and extended but not to circular.\n* \"extended_failed\" - the query contig was not able to be extended due to COBRA rules. \n* \"orphan end\" - neither end of a given contig shares \"expected overlap length\" with others.\n\nFor the joined and extended queries in each category, only the unique ones (```*.fasta```) will be saved for users' following analyses, and the sequence information (e.g., length, coverage, GC, num of Ns) is summarized in the ```*fasta.summary.txt``` files. For categories of \"extended_circular\", and \"extended_partial\", the joining details of each query are included in the corresponding folder and ```*joining_details.txt``` file, and summarized in the ```COBRA_joining_summary.txt``` file, an example shown below:\n\n```\nQuerySeqID      QuerySeqLen     TotRetSeqs      TotRetLen       AssembledLen    ExtendedLen     Status\ncontig-140_100  47501   3       50379   49962   2461    Extended_circular\ncontig-140_112  45060   3       62549   62132   17072   Extended_circular\ncontig-140_114  44829   2       45342   45064   235     Extended_circular\ncontig-140_160  40329   2       41018   40740   411     Extended_circular\ncontig-140_188  38386   5       48986   48291   9905    Extended_circular\n...\n```\n\n\n* **log file:** The ```log``` file includes the content of each processing step, an example shown below:\n\n```\n1. INPUT INFORMATION\n# Assembler: IDBA_UD\n# Min-kmer: 20\n# Max-kmer: 140\n# Overlap length: 139 bp\n# Read mapping max mismatches for contig linkage: 2\n# Query contigs: file-path\n# Whole contig set: file-path\n# Mapping file: file-path\n# Coverage file: file-path\n# Output folder: file-path\n\n2. PROCESSING STEPS\n[01/22] [2023/05/04 12:48:15] Reading contigs and getting the contig end sequences. A total of 311739 contigs were imported.\n[02/22] [2023/05/04 12:48:33] Getting shared contig ends.\n[03/22] [2023/05/04 12:48:40] Writing contig end joining pairs.\n[04/22] [2023/05/04 12:48:41] Getting contig coverage information.\n[05/22] [2023/05/04 12:48:42] Getting query contig list. A total of 2304 query contigs were imported.\n[06/22] [2023/05/04 12:48:43] Getting contig linkage based on sam/bam. Be patient, this may take long.\n[07/22] [2023/05/04 13:00:01] Detecting self_circular contigs.\n[08/22] [2023/05/04 13:00:37] Detecting joins of contigs. 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100% finished.\n[09/22] [2023/05/04 14:29:20] Saving potential joining paths.\n[10/22] [2023/05/04 14:29:23] Checking for invalid joining: sharing queries.\n[11/22] [2023/05/04 14:29:28] Getting initial joining status of each query contig.\n[12/22] [2023/05/04 14:29:28] Getting final joining status of each query contig.\n[13/22] [2023/05/04 14:29:28] Getting the joining order of contigs.\n[14/22] [2023/05/04 14:29:28] Getting retrieved contigs.\n[15/22] [2023/05/04 14:29:32] Saving joined seqeuences.\n[16/22] [2023/05/04 14:29:35] Checking for invalid joining using BLASTn: close strains.\n[17/22] [2023/05/04 14:30:11] Saving unique sequences of \"Extended_circular\" and \"Extended_partial\" for joining checking.\n[18/22] [2023/05/04 14:30:12] Getting the joining details of unique \"Extended_circular\" and \"Extended_partial\" query contigs.\n[19/22] [2023/05/04 14:30:12] Saving joining summary of \"Extended_circular\" and \"Extended_partial\" query contigs.\n[20/22] [2023/05/04 14:30:15] Saving joining status of all query contigs.\n[21/22] [2023/05/04 14:30:15] Saving self_circular contigs.\n[22/22] [2023/05/04 14:30:16] Saving the new fasta file.\n\n======================================================================================================================================================\n3. RESULTS SUMMARY\n# Total queries: 2304\n# Category i   - Self_circular: 74\n# Category ii  - Extended_circular: 120 (Unique: 82)\n# Category ii  - Extended_partial: 1088 (Unique: 889)\n# Category ii  - Extended_failed (due to COBRA rules): 245\n# Category iii - Orphan end: 777\n# Check \"COBRA_joining_status.txt\" for joining status of each query.\n# Check \"COBRA_joining_summary.txt\" for joining details of \"Extended_circular\" and \"Extended_partial\" queries.\n======================================================================================================================================================\n```\n"
}