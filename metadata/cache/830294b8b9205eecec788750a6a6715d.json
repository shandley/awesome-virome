{
  "cache_date": "2025-11-01T11:40:35.792994",
  "data": "![COBRA_logo](https://github.com/linxingchen/cobra/assets/46725273/f21d1198-991c-42b2-9ec0-0ae8a662ba35)\n\nCOBRA (Contig Overlap Based Re-Assembly) is a bioinformatics tool to get higher quality viral genomes assembled from metagenomes of short paired-end reads. COBRA was written in Python. COBRA has so far only been tested on assembled contigs and scaffolds from metaSPAdes, IDBA_UD, and MEGAHIT.\n\n```\n# Developed by Dr. LinXing Chen\n# University of California, Berkeley\n# The Banfield Lab\n# Email: linkingchan@gmail.com\n```\n\n## Versions\n1. v1.2.2 (released on 2023-09-03) - initial release\n\n2. v1.2.3 (released on 2024-02-26)\n    - The GC function issue due to the update of Biopython.\n    - The abnormal exit in the middle of processing some samples.\n    - If none of the queries was extended, the process will break. If your runs do not have the expected output files, see the log file.\n\n3. v1.3.0 (released on 2025-06-26)\n    - refactor+feature: format code and add trim_readno\n    - fix the handle of \"6\" shape path\n\n\n## Citation\nThe paper is out at Nature Microbiology (https://www.nature.com/articles/s41564-023-01598-2). Please cite as follows if you find COBRA is helpful for your analyses.\n```Chen, L., Banfield, J.F. COBRA improves the completeness and contiguity of viral genomes assembled from metagenomes. Nat Microbiol (2024). https://doi.org/10.1038/s41564-023-01598-2```\n\n\n## Introduction\n\n**1. Why are metagenomic contigs fragmented?**\n\nThe genomes assembled from short paired-end reads based metagenomes are usually fragmented due to (1) intra-genome repeats, (2) inter-genome shared region, and (3) within-population variations, as the widely utilized assemblers based on de Bruijn graphs, e.g., metaSPAdes, IDBA_UD and MEGAHIT, tend to have a breaking point when multiple paths are available instead of making risky extension (see example in **Figure 1**).\n\n![image](https://user-images.githubusercontent.com/46725273/111676563-8a21f180-87db-11eb-9b8c-4c63fb993936.png)\n\nFigure 1. An example of how assemblers break in assembly when within-population occurs.\n\n**2. Contigs may be joined with expected end overlap.**\n\nAccording to the principles of the abovementioned assemblers, the broken contigs have an end overlap with a determined length, that is, the max-kmer (maxK hereafter) used in de nono assembly for metaSPAdes and MEGAHIT, and the maxK-1 for IDBA_UD, which we termed as \"expected overlap length\" (Figures 1 and 2).\n\n* Note: as COBRA will use the information provided by paired-end reads, only those samples sequenced by paired-end technology should work.\n\n![image](https://user-images.githubusercontent.com/46725273/111677281-4c719880-87dc-11eb-85a9-a62906f4e10b.png)\n\nFigure 2. The \"expected overlap length\" has been documented in manual genome curation, see [Chen et al. 2020](https://genome.cshlp.org/content/30/3/315.short) for details.\n\n\n## How COBRA works\n\nCOBRA determines the \"expected overlap length\" (both the forward direction and reverse complement direction) for all the contigs from an assembly, then looks for the valid joining path for each query that users provide (should be a fraction of the whole assembly) based on a list of features including contig coverage, contig overlap relationships, and contig continuity (based on paired-end reads mapping) (Figure 3).\n\nNote that scaffolds (for example, metaSPAdes assembly) could be used as input for COBRA extension; however, we suggest not using scaffolds from IDBA_UD as the potential errors in the scaffolding step (see [Chen et al. 2020](https://genome.cshlp.org/content/30/3/315.short) for details). Thus, for IDBA_UD and MEGAHIT assembly, the contigs should be used.\n\nGiven that COBRA has only tested for contigs/scaffolds from IDBA_UD, metaSPAdes, and MEGAHIT, it will be risky to use it on contigs/scaffolds from any other assemblers.\n\n![Figure 1](https://github.com/linxingchen/cobra/assets/46725273/77a8285b-cce8-45f3-8e4e-4c46c3f45354)\n\nFigure 3. The workflow of COBRA.\n\n\n## Dependencies\n* COBRA is a Python script (tested for version 3.7 or higher) that uses a list of frequently used Python packages, including:\n```\nBio\nBio.Seq\ncollections\nargparse\nmath\npysam\ntime\n```\n\n* The only third-party software that COBRA will use is [BLASTn](https://blast.ncbi.nlm.nih.gov/Blast.cgi?PAGE_TYPE=BlastDocs&DOC_TYPE=Download).\n\n## Installation\nCOBRA could now be installed in different ways.\n\n* (1) git\n\n```git clone https://github.com/linxingchen/cobra.git```\n\n```cd cobra```\n\n```python cobra.py -h```\n\n\n* (2) pip\n\n```pip install cobra-meta```\n\nTo confirm the installment,\n\n```cobra-meta -h```\n\nWhich shows something like this\n\n```\nusage: cobra-meta [-h] -q QUERY -f FASTA -a {idba,megahit,metaspades} -mink MINK -maxk MAXK -m MAPPING -c COVERAGE [-lm LINKAGE_MISMATCH] [-o OUTPUT] [-t THREADS] [-v]\n\n...\n```\n\n* (3) conda\n\n```conda create -n cobra python=3.8```\n\n```conda activate cobra```\n\n```conda install bioconda::cobra-meta``` or ```conda install linxingchen1987::cobra-meta```\n\nTo confirm the installment,\n\n```cobra-meta -h```\n\nWhich shows something like this\n\n```\nusage: cobra.py [-h] -q QUERY [-i IGNORE] -f FASTA -a {idba,megahit,metaspades} -mink MINK -maxk MAXK -m MAPPING\n                [--mapping-link-cache [MAPPING_LINK_CACHE ...]] -c COVERAGE [-lm LINKAGE_MISMATCH] [-tr {no,trim,auto}]\n                [--skip_new_assembly] [-o OUTPUT] [-t THREADS] [-v]\n\n...\n```\n\n## Update\n* pip\n\n```pip install --upgrade cobra-meta```\n\n* conda\n\n``` conda activate cobra``` (if cobra is the conda environment name)\n\n``` conda update cobra-meta```\n\n\n## Input files\n(1) COBRA needs four files as inputs, i.e.,\n\n* ```-f/--fasta```: A fasta format file containing all the contigs from a single assembly. Note that IDBA_UD and MEGAHIT usually save contigs with a minimum length of 200 bp.\n\n* ```-c/--coverage```: a two-column (separated by tab) file of the sequencing coverage of all contigs in the ```-f/--fasta``` file, example below:\n\n```\ncontig-140_0    25.552\ncontig-140_1    42.1388\ncontig-140_2    14.6023\ncontig-140_3    15.4817\ncontig-140_4    41.2746\n...\n```\n\n* ```-q/--query```: the query contigs that the user wants COBRA to extend, could be provided in a fasta format file, or a one-column text file with the names of the query contigs. Please make sure the names are exactly the same format as in the ```-f/--fasta``` file; otherwise, COBRA may have problems extending them.\n\n* ```-m/--mapping```: the paired-end reads mapping file of all contigs in the ```-f/--fasta``` file, could be sam or bam file.\n\n(2) and three parameters\n* ```-a/--assembler```: the name of the de novo assembler used, currently only 'idba' (for IDBA_UD), 'metaspades' (for metaSPAdes), and 'megahit' (for MEGAHIT).\n* ```-maxk/--maxk```: the largest kmer used in de novo assembly.\n* ```-mink/--mink```: the smallest kmer used in de novo assembly.\n\n\n(3) Optional flags\n* ```-lm/--linkage_mismatch```: the number of read mapping mismatches allowed when determining if paired reads spanned two contigs.\n* ```-o/--output```: the name of the output folder, otherwise it will be \"{```-q/--query```}.COBRA\" if not provided.\n* ```-t/--threads```: the number of threads used for BLASTn search.\n\n\n## How to obtain the mapping file\n\nThe mapping file could be obtained with tools like Bowtie2 and BBMap. Please refer to the manual descriptions for details of the tools. Below is the general way to get the sorted sam/bam file; you thus need to be available to samtools (which could be downloaded here - https://github.com/samtools/samtools).\n\nFor example,\n\n* ```contig file = \"contigs.fasta\"```\n\n* ```first read file = \"R1.fastq.gz\"```\n\n* ```second read file = \"R2.fastq.gz\"```\n\n(1) with Bowtie2 (https://github.com/BenLangmead/bowtie2)\n\n* ```bowtie2-build contigs.fasta contigs.fasta```\n\n* ```bowtie2 -p 16 -x contigs.fasta -1 R1.fastq.gz -2 R2.fastq.gz -S output.sam && samtools view -bS output.sam | samtools sort -o sorted_output.bam -```\n\n\n(2) with BBMap (https://github.com/BioInfoTools/BBMap)\n\n* ```bbmap.sh ref=contigs.fasta in1=R1.fastq.gz in2=R2.fastq.gz threads=16 out=output.sam``` (good)\n* ```samtools view -bS output.sam > output.bam```\n* ```samtools sort -o sorted_output.bam output.bam```\n\n\n##  How to obtain the coverage file\n\n(1) with jgi_summarize_bam_contig_depths\n\nOnce the sorted sam or bam file is ready, the tool of \"jgi_summarize_bam_contig_depths\" from MetaBAT (https://bitbucket.org/berkeleylab/metabat/src/master/), or could be used to obtain the coverage file, the resulting profile should be transferred to get a two-column file divided by tab.\n\n* ```jgi_summarize_bam_contig_depths --outputDepth original.coverage.txt *sam```\n\n* ```jgi_summarize_bam_contig_depths --outputDepth original.coverage.txt *bam```\n\nThe output file from jgi_summarize_bam_contig_depths could be converted to a two-column file divided by tab using the script provided in this study (coverage.transfer.py).\n\n* ```python coverage.transfer.py -i original.coverage.txt -o coverage.txt```\n\n\n(2) CoverM\n\nCoverM is a fast DNA read coverage and relative abundance calculator focused on metagenomics applications. Usage could be found here (https://github.com/wwood/CoverM).\n\n\n(3) pyCoverM\n\npyCoverM is a simple Python interface to CoverM's fast coverage estimation functions, which could be found here (https://github.com/apcamargo/pycoverm).\n\n\n## How to run\n(1) The users can only specify the required parameters:\n\n```\ncobra-meta -f input.fasta -q query.fasta -c coverage.txt -m mapping.sam -a idba -mink 20 -maxk 140\n```\n\n(2) The users could also include the optional parameters like output name (-o), mismatch of mapped reads for linkage identification (-lm)\n\n```\ncobra-meta -f all.contigs.fasta -q query.fasta -o query.fasta.COBRA.out -c coverage.txt -m mapping.sam -a idba -mink 20 -maxk 140 -lm 2\n```\n\n```\ncobra-meta -f all.contigs.fasta -q query.fasta -o query.fasta.COBRA.out -c coverage.txt -m mapping.sam -a metaspades -mink 21 -maxk 127 -lm 2\n```\n\n```\ncobra-meta -f all.contigs.fasta -q query.fasta -o query.fasta.COBRA.out -c coverage.txt -m mapping.sam -a megahit -mink 21 -maxk 141 -lm 2\n```\n\n\n## Output files\nBelow is a general list of output files in the output folder:\n\n```\nCOBRA_end_joining_pairs.tsv\nCOBRA_potential_joining_paths.tsv\nblast_pairs.tsv_temp/\nblast_pairs.tsv\ndebug.txt\nCOBRA_grouping_gv.tsv\nCOBRA_check_assembly_reason.tsv\nCOBRA_joining_summary.tsv\nCOBRA_joining_failed_paths.tsv\nCOBRA_joining_status.tsv\nCOBRA_category_ii-a_extended_circular_unique.fa\nCOBRA_category_ii-a_extended_circular_unique.fa.summary.tsv\nCOBRA_category_ii-b_extended_partial_unique.fa\nCOBRA_category_ii-b_extended_partial_unique.fa.summary.tsv\nCOBRA_category_i_self_circular.fa\nCOBRA_category_i_self_circular.fa.summary.tsv\nCOBRA_category_ii-c_extended_failed.fa\nCOBRA_category_ii-c_extended_failed.fa.summary.tsv\nCOBRA_category_iii-b_complex_end_remain.fa\nCOBRA_category_iii-b_complex_end_remain.fa.summary.tsv\nCOBRA_category_iii-a_orphan_end.fa\nCOBRA_category_iii-a_orphan_end.fa.summary.tsv\nAcMG_contigs.fasta.new.fa\nlog\n```\n\nFor all the queries, COBRA assigns them to different categories based on their joining status (detailed in the ```COBRA_joining_status.txt``` file), i.e.,\n\n* \"self_circular\" - the query contig itself is a circular genome.\n* \"extended_circular\" - the query contig was joined and extended into a circular genome.\n* \"extended_partial\" - the query contig was joined and extended, but not circular.\n* \"extended_failed\" - the query contig was not able to be extended due to COBRA rules.\n* \"orphan_end\" - neither end of a given contig shares \"expected overlap length\" with others.\n* \"complex_end\" - the query contig has multiple possible joining paths, so COBRA could not resolve them.\n\nFor the joined and extended queries in each category, only the unique ones (```*.fa```) will be saved for users' following analyses, and the sequence information (e.g., length, coverage, GC, num of Ns) is summarized in the ```*fa.summary.tsv``` files. For categories of \"extended_circular\", and \"extended_partial\", the joining details of each query are included in the corresponding folder and summarized in the ```COBRA_joining_summary.tsv``` file, an example shown below:\n\n```\nStatusReason\tRepQuery\tStatus\tItem\tContig\tFinalSeqID\tGroupID\tJoinLen\tStartOnJoin\tDirection\tJoinedReason\tContigLen\tCov\tGC\tIsQuery\ncircular\tAcMG_13342\textended_circular\tAcMG_4689667_Lrc AcMG_619867_Lrc AcMG_24500_R AcMG_13342\tAcMG_4689667\tAcMG_13342_extended_circular\t165\t6482\t0\treverse\tother_end_is_extendable\t203\t67.34694\t0.6699507389162561\tFalse\ncircular\tAcMG_13342\textended_circular\tAcMG_4689667_Lrc AcMG_619867_Lrc AcMG_24500_R AcMG_13342\tAcMG_619867\tAcMG_13342_extended_circular\t165\t6482\t148\treverse\tthe_better_one\t456\t95.69927\t0.6600877192982456\tFalse\ncircular\tAcMG_13342\textended_circular\tAcMG_4689667_Lrc AcMG_619867_Lrc AcMG_24500_R AcMG_13342\tAcMG_24500\tAcMG_13342_extended_circular\t165\t6482\t549\tforward\tthe_better_one\t2517\t71.29798\t0.5387365911799762\tFalse\ncircular\tAcMG_13342\textended_circular\tAcMG_4689667_Lrc AcMG_619867_Lrc AcMG_24500_R AcMG_13342\tAcMG_13342\tAcMG_13342_extended_circular\t165\t6482\t3011\tforward\tquery\t3526\t116.24112\t0.6154282473057289\tTrue\ncircular\tAcMG_14922\textended_circular\tAcMG_18416_R AcMG_14922\tAcMG_18416\tAcMG_14922_extended_circular\t238\t6218\t0\tforward\tthe_better_one\t2955\t17.084356\t0.3549915397631134\tTrue\ncircular\tAcMG_14922\textended_circular\tAcMG_18416_R AcMG_14922\tAcMG_14922\tAcMG_14922_extended_circular\t238\t6218\t2900\tforward\tquery\t3318\t15.571528\t0.3794454490657022\tTrue\n...\n```\n\n\n* **log file:** The ```log``` file includes the content of each processing step, an example shown below:\n\n```\n1. INPUT INFORMATION\n# Max-kmer: 55\n# Min-kmer: 21\n# Overlap length: 55 bp\n# Read mapping max mismatches for contig linkage: 2\n# Query contigs: AcMG/AcMG_virus_gt2500_clean.fasta\n# Whole contig set: AcMG/AcMG_contigs.fasta\n# Mapping file: AcMG/AcMG.sorted.bam\n# Coverage file: AcMG/AcMG\n# Output folder: AcMG_virus_gt2500_clean.fasta_COBRA\n\n\n2. PROCESSING STEPS\n2.1. Loading assembly and mapping data\n[0/5] [2024/11/03 11:51:54] Reading contigs and getting the contig end pairs. A total of 4775825 contigs were imported.\n[1/5] [2024/11/03 11:53:14] Joining contigs by contig end (maxK). Among 570278 link pairs, found 407474 one path end, 158542 two paths end.\n[2/5] [2024/11/03 11:53:18] Getting linkage based on sam/bam. Be patient, this may take long.\n[3/5] [2024/11/03 11:55:27] Reading contig coverage information.\n[4/5] [2024/11/03 11:55:30] Getting query contig list. A total of 3315 query contigs were imported, with 1495 query with unique end (orphan).\n2.2. Analyzing assembled paths and solving conflicts\n[0/8] [2024/11/03 11:55:30] Detecting self_circular contigs, independent of mapping linkage.\n[1/8] [2024/11/03 11:55:31] Detecting joins of contigs.\n[2/8] [2024/11/03 11:55:32] Saving potential joining paths.\n[3/8] [2024/11/03 11:55:32] Getting the joining paths of contigs.\n[4/8] [2024/11/03 11:55:32] Getting joined seqeuences.\n[5/8] [2024/11/03 11:55:32] Checking for invalid joining using BLASTn: close strains.\n[6/8] [2024/11/03 11:55:33] Grouping paths by sharing queries to check for invalid queries.\n[7/8] [2024/11/03 11:55:33] Filtering paths according to COBRA rules.\n3315\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tquery_set\n>\t1495\t\t\t\t\t\t\t\t\t\t\t\t\t\t\torphan_end_query\n>\t0\t486\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomplex_end_query\n>\t0\t0\t13\t\t\t\t\t\t\t\t\t\t\t\t\tself_circular [overlap_maxk]\n0\t0\t0\t0\t0\t\t\t\t\t\t\t\t\t\t\t\tself_circular [overlap_flex]\n>\t0\t0\t0\t0\t1005\t\t\t\t\t\t\t\t\t\t\tassembly_rep\n>\t0\t73\t0\t0\t132\t305\t\t\t\t\t\t\t\t\t\tfailed_join_queries\n>\t0\t68\t0\t0\t70\t>\t149\t\t\t\t\t\t\t\t\tfailed_join [complex]\n>\t0\t6\t0\t0\t62\t>\t5\t155\t\t\t\t\t\t\t\tfailed_join [conflict]\n>\t0\t1\t0\t0\t2\t>\t0\t0\t6\t\t\t\t\t\t\tfailed_join [circular_6]\n>\t0\t0\t1\t0\t1\t1\t0\t0\t1\t2\t\t\t\t\t\tfailed_blast_half\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\t\t\t\tredundant_circular_8\n>\t0\t0\t0\t0\t>\t0\t0\t0\t0\t0\t0\t873\t\t\t\tchecked_rep\n>\t0\t0\t0\t0\t866\t0\t0\t0\t0\t0\t0\t866\t1078\t\t\tchecked_partial_queries\n>\t0\t0\t0\t0\t7\t0\t0\t0\t0\t0\t0\t7\t0\t11\t\tchecked_circular_queries\n>\t0\t0\t0\t0\t>\t0\t0\t0\t0\t0\t0\t>\t0\t>\t7\tpath_circular_rep\n2.3. Output extended paths and circulated paths\n[0/5] [2024/11/03 11:55:33] Getting the joining details of extended query contigs.\n[1/5] [2024/11/03 11:55:36] Getting the joining details of failed query contigs.\n[2/5] [2024/11/03 11:55:36] Saving joining status of all query contigs.\n[3/5] [2024/11/03 11:55:37] Saving identified and modified contigs.\n[4/5] [2024/11/03 11:55:37] Summarise all query contigs and save the new assembled contigs.\n\n\n3. RESULTS SUMMARY\n# Total queries: 3315\n# Category i   - self_circular: 13\n# Category ii  - extended_circular: 11 (Unique: 7)\n# Category ii  - extended_partial: 1078 (Unique: 866)\n# Category ii  - extended_failed (due to COBRA rules): 305\n# Category iii - orphan end: 1495\n# Category iii - too complex to resolve: 413\n# Check \"COBRA_query_status.tsv\" for joining status of each query.\n# Check \"COBRA_joining_summary.tsv\" for joining details of \"extended_circular\" and \"extended_partial\" queries.\n```\n"
}