{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Awesome-Virome","text":"<p>Last Updated: November 29, 2025</p> <p>A curated list of software, tools, and databases useful for virome analysis, including phages, viruses, and their interactions with hosts.</p> <p></p>"},{"location":"#what-is-awesome-virome","title":"What is Awesome-Virome?","text":"<p>Awesome-Virome is a comprehensive collection of resources for studying viral communities in various environments. Whether you're a bioinformatician, a microbiologist, or a researcher in a related field, this repository aims to help you navigate the diverse landscape of tools available for virome analysis.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Awesome-Virome offers several unique features that enhance its value as a resource for the viral bioinformatics community:</p> <ul> <li>Interactive Visualizations: Dynamic network graph and dashboard showing tool relationships and ecosystem trends</li> <li>Interactive Dashboard: Explore 300+ tools with filterable visualizations and comparison features</li> <li>Enhanced Metadata: Automated metadata enrichment from GitHub, GitLab, and Bitbucket</li> <li>Community-Driven: Standardized issue templates and workflows for contributions</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<ul> <li>Introduction - Learn about virome analysis and this repository</li> <li>Tools Overview - Explore the comprehensive list of tools</li> <li>API Reference - Use the programmatic API</li> <li>Contributing - Help improve the repository</li> </ul>"},{"location":"#popular-virome-tools","title":"Popular Virome Tools","text":"<p>Top virome analysis tools ranked by GitHub stars:</p> <ol> <li>metaviralSPAdes - \u2b50 803 stars - Viral genome assembler optimized for metagenomic data</li> <li>DRAMv - \u2b50 270 stars - Viral genome annotation and metabolism analysis</li> <li>geNomad - \u2b50 226 stars - Identification of viruses and plasmids in sequencing data</li> <li>Viral-NGS - \u2b50 192 stars - Viral genomics analysis pipelines</li> <li>VIBRANT - \u2b50 160 stars - Virus identification and annotation</li> <li>Pharokka - \u2b50 160 stars - Fast phage annotation program</li> </ol> <p>View all tools</p>"},{"location":"#interactive-dashboard","title":"Interactive Dashboard","text":"<p>Explore the complete virome analysis ecosystem with our interactive dashboard, now available:</p> <ul> <li>Network Visualization: See relationships between 300+ tools</li> <li>Tool Comparison: Filter and compare tools side-by-side</li> <li>Selection Guide: Get personalized tool recommendations</li> </ul> <p>Launch Dashboard View Documentation</p>"},{"location":"api/endpoints/","title":"API Endpoints","text":"<p>This page details all available endpoints in the Awesome-Virome API, including their parameters, response format, and example usage.</p>"},{"location":"api/endpoints/#tools","title":"Tools","text":"<p>Returns a complete list of all tools in the database with their full metadata.</p> <ul> <li>URL: <code>/api/v1/tools.json</code></li> <li>Method: GET</li> <li>Parameters: None</li> <li>Response Format: JSON</li> </ul> <p>Response Structure: <pre><code>{\n  \"count\": 300,\n  \"last_updated\": \"2025-05-01\",\n  \"tools\": [\n    {\n      \"name\": \"VirSorter2\",\n      \"description\": \"Random forest classifier for virus detection\",\n      \"url\": \"https://bitbucket.org/MAVERICLab/virsorter2/\",\n      \"category\": \"Virus and Phage Identification\",\n      \"subcategory\": \"Metagenome Analysis\",\n      \"language\": \"Python\",\n      \"github_stars\": null,\n      \"package_manager\": \"conda\",\n      \"latest_version\": \"v2.2.4\",\n      \"latest_release_date\": \"2023-04-15\",\n      \"license\": \"GPL-3.0\",\n      \"citation_count\": 342,\n      \"maintenance_status\": \"Active\"\n    },\n    // Additional tools...\n  ]\n}\n</code></pre></p> <p>Example Request: <pre><code>fetch('https://shandley.github.io/awesome-virome/api/v1/tools.json')\n  .then(response =&gt; response.json())\n  .then(data =&gt; console.log(data));\n</code></pre></p>"},{"location":"api/endpoints/#categories","title":"Categories","text":"<p>Returns a list of all tool categories and their subcategories.</p> <ul> <li>URL: <code>/api/v1/categories.json</code></li> <li>Method: GET</li> <li>Parameters: None</li> <li>Response Format: JSON</li> </ul> <p>Response Structure: <pre><code>{\n  \"count\": 8,\n  \"categories\": [\n    {\n      \"name\": \"Virus and Phage Identification\",\n      \"slug\": \"virus-identification\",\n      \"description\": \"Tools for identifying viral sequences in metagenomic data\",\n      \"subcategories\": [\n        \"Metagenome Analysis\",\n        \"Integrated Viruses\",\n        \"RNA Virus Identification\"\n      ],\n      \"tool_count\": 45\n    },\n    // Additional categories...\n  ]\n}\n</code></pre></p> <p>Example Request: <pre><code>import requests\nresponse = requests.get('https://shandley.github.io/awesome-virome/api/v1/categories.json')\ndata = response.json()\nprint(f\"Found {data['count']} categories\")\n</code></pre></p>"},{"location":"api/endpoints/#search","title":"Search","text":"<p>Provides a lightweight index for client-side searching and filtering.</p> <ul> <li>URL: <code>/api/v1/search.json</code></li> <li>Method: GET</li> <li>Parameters: None</li> <li>Response Format: JSON</li> </ul> <p>Response Structure: <pre><code>{\n  \"count\": 300,\n  \"last_updated\": \"2025-05-01\",\n  \"tools\": [\n    {\n      \"name\": \"VirSorter2\",\n      \"category\": \"Virus and Phage Identification\",\n      \"subcategory\": \"Metagenome Analysis\",\n      \"tags\": [\"virus detection\", \"metagenomics\", \"classifier\"],\n      \"language\": \"Python\"\n    },\n    // Additional simplified tool entries...\n  ]\n}\n</code></pre></p> <p>Example Request: <pre><code>// Client-side filtering example\nfetch('https://shandley.github.io/awesome-virome/api/v1/search.json')\n  .then(response =&gt; response.json())\n  .then(data =&gt; {\n    const pythonTools = data.tools.filter(tool =&gt; tool.language === 'Python');\n    console.log(`Found ${pythonTools.length} Python tools`);\n  });\n</code></pre></p>"},{"location":"api/endpoints/#stats","title":"Stats","text":"<p>Provides aggregate statistics about the tool collection.</p> <ul> <li>URL: <code>/api/v1/stats.json</code></li> <li>Method: GET</li> <li>Parameters: None</li> <li>Response Format: JSON</li> </ul> <p>Response Structure: <pre><code>{\n  \"total_tools\": 300,\n  \"tools_by_category\": {\n    \"Virus and Phage Identification\": 45,\n    \"Host Prediction\": 20,\n    \"Genome Analysis\": 35,\n    // Additional categories...\n  },\n  \"tools_by_language\": {\n    \"Python\": 150,\n    \"R\": 50,\n    \"C++\": 30,\n    // Additional languages...\n  },\n  \"tools_by_maintenance\": {\n    \"Active\": 200,\n    \"Inactive\": 80,\n    \"Unknown\": 20\n  },\n  \"tools_by_package_manager\": {\n    \"conda\": 120,\n    \"pip\": 80,\n    \"other\": 100\n  },\n  \"average_citation_count\": 105.3,\n  \"last_updated\": \"2025-05-01\"\n}\n</code></pre></p> <p>Example Request: <pre><code>import requests\nimport matplotlib.pyplot as plt\n\nresponse = requests.get('https://shandley.github.io/awesome-virome/api/v1/stats.json')\ndata = response.json()\n\n# Visualize tools by category\ncategories = list(data['tools_by_category'].keys())\ncounts = list(data['tools_by_category'].values())\n\nplt.figure(figsize=(10, 6))\nplt.bar(categories, counts)\nplt.title('Tools by Category')\nplt.xticks(rotation=45, ha='right')\nplt.tight_layout()\nplt.show()\n</code></pre></p>"},{"location":"api/endpoints/#category-specific","title":"Category-Specific","text":"<p>Returns tools filtered by a specific category.</p> <ul> <li>URL: <code>/api/v1/categories/{category_slug}.json</code></li> <li>Method: GET</li> <li>Path Parameters:</li> <li><code>category_slug</code>: The slug of the category to filter by (e.g., <code>virus-identification</code>)</li> <li>Response Format: JSON</li> </ul> <p>Response Structure: <pre><code>{\n  \"category\": \"Virus and Phage Identification\",\n  \"description\": \"Tools for identifying viral sequences in metagenomic data\",\n  \"subcategories\": [\n    \"Metagenome Analysis\",\n    \"Integrated Viruses\",\n    \"RNA Virus Identification\"\n  ],\n  \"count\": 45,\n  \"tools\": [\n    {\n      \"name\": \"VirSorter2\",\n      \"description\": \"Random forest classifier for virus detection\",\n      \"url\": \"https://bitbucket.org/MAVERICLab/virsorter2/\",\n      \"subcategory\": \"Metagenome Analysis\",\n      \"language\": \"Python\",\n      \"github_stars\": null,\n      \"package_manager\": \"conda\",\n      \"latest_version\": \"v2.2.4\",\n      \"latest_release_date\": \"2023-04-15\",\n      \"license\": \"GPL-3.0\",\n      \"citation_count\": 342,\n      \"maintenance_status\": \"Active\"\n    },\n    // Additional tools in this category...\n  ]\n}\n</code></pre></p> <p>Example Request: <pre><code>// Get all host prediction tools\nfetch('https://shandley.github.io/awesome-virome/api/v1/categories/host-prediction.json')\n  .then(response =&gt; response.json())\n  .then(data =&gt; {\n    console.log(`Found ${data.count} host prediction tools`);\n    // Display tools in a table\n    const tableData = data.tools.map(tool =&gt; ({\n      name: tool.name,\n      description: tool.description,\n      language: tool.language || 'Unknown',\n      stars: tool.github_stars || 'N/A'\n    }));\n    console.table(tableData);\n  });\n</code></pre></p>"},{"location":"api/endpoints/#metadata","title":"Metadata","text":"<p>Returns detailed information about the API itself.</p> <ul> <li>URL: <code>/api/v1/metadata.json</code></li> <li>Method: GET</li> <li>Parameters: None</li> <li>Response Format: JSON</li> </ul> <p>Response Structure: <pre><code>{\n  \"name\": \"Awesome-Virome API\",\n  \"version\": \"v1\",\n  \"documentation_url\": \"https://shandley.github.io/awesome-virome/docs/api\",\n  \"description\": \"REST API for accessing the Awesome-Virome database of virome analysis tools\",\n  \"last_updated\": \"2025-05-01\",\n  \"contact\": \"https://github.com/shandley/awesome-virome/issues\",\n  \"endpoints\": [\n    \"/api/v1/tools.json\",\n    \"/api/v1/categories.json\",\n    \"/api/v1/search.json\",\n    \"/api/v1/stats.json\",\n    \"/api/v1/categories/{category_slug}.json\",\n    \"/api/v1/metadata.json\"\n  ],\n  \"total_tools\": 300,\n  \"repository_url\": \"https://github.com/shandley/awesome-virome\"\n}\n</code></pre></p> <p>Example Request: <pre><code>import requests\n\nresponse = requests.get('https://shandley.github.io/awesome-virome/api/v1/metadata.json')\ndata = response.json()\nprint(f\"API Version: {data['version']}\")\nprint(f\"Last Updated: {data['last_updated']}\")\nprint(f\"Available Endpoints: {', '.join(data['endpoints'])}\")\n</code></pre></p>"},{"location":"api/endpoints/#error-handling","title":"Error Handling","text":"<p>If an error occurs, the API will return a JSON object with an error message:</p> <pre><code>{\n  \"error\": \"Category not found\",\n  \"status\": 404,\n  \"message\": \"The category 'invalid-category' does not exist\"\n}\n</code></pre> <p>Note that since the API is hosted on GitHub Pages, only HTTP status 200 (OK) and 404 (Not Found) are possible. Error details are included in the response body.</p>"},{"location":"api/endpoints/#cross-origin-resource-sharing","title":"Cross-Origin Resource Sharing","text":"<p>All API endpoints support CORS (Cross-Origin Resource Sharing), allowing them to be accessed from web applications hosted on different domains.</p>"},{"location":"api/endpoints/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the API Examples page for more detailed usage examples</li> <li>View the API Overview for general information about the API</li> <li>See the Tools Overview to understand the data model better</li> </ul>"},{"location":"api/examples/","title":"API Usage Examples","text":"<p>This page provides practical examples of how to use the Awesome-Virome API in different programming languages and for various use cases.</p>"},{"location":"api/examples/#basic-examples","title":"Basic Examples","text":""},{"location":"api/examples/#javascript-browser","title":"JavaScript (Browser)","text":"<p>Fetch all tools and display them in a table:</p> <pre><code>async function fetchAndDisplayTools() {\n  try {\n    const response = await fetch('https://shandley.github.io/awesome-virome/api/v1/tools.json');\n    const data = await response.json();\n\n    const toolsTable = document.getElementById('tools-table');\n    const tbody = toolsTable.querySelector('tbody');\n\n    data.tools.forEach(tool =&gt; {\n      const row = document.createElement('tr');\n      row.innerHTML = `\n        &lt;td&gt;&lt;a href=\"${tool.url}\" target=\"_blank\"&gt;${tool.name}&lt;/a&gt;&lt;/td&gt;\n        &lt;td&gt;${tool.description}&lt;/td&gt;\n        &lt;td&gt;${tool.category}&lt;/td&gt;\n        &lt;td&gt;${tool.language || 'N/A'}&lt;/td&gt;\n        &lt;td&gt;${tool.maintenance_status || 'Unknown'}&lt;/td&gt;\n      `;\n      tbody.appendChild(row);\n    });\n  } catch (error) {\n    console.error('Error fetching tools:', error);\n  }\n}\n\n// Call the function when the page loads\ndocument.addEventListener('DOMContentLoaded', fetchAndDisplayTools);\n</code></pre>"},{"location":"api/examples/#python","title":"Python","text":"<p>Find tools by category and save to CSV:</p> <pre><code>import requests\nimport pandas as pd\n\ndef get_tools_by_category(category_slug):\n    url = f'https://shandley.github.io/awesome-virome/api/v1/categories/{category_slug}.json'\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        data = response.json()\n        return data\n    else:\n        print(f\"Error fetching category: {response.status_code}\")\n        return None\n\n# Get all host prediction tools\nhost_prediction_data = get_tools_by_category('host-prediction')\n\nif host_prediction_data:\n    # Convert to DataFrame\n    tools_df = pd.DataFrame(host_prediction_data['tools'])\n\n    # Save to CSV\n    tools_df.to_csv('host_prediction_tools.csv', index=False)\n\n    print(f\"Saved {len(tools_df)} host prediction tools to CSV\")\n\n    # Basic analysis\n    if 'language' in tools_df.columns:\n        print(\"\\nTools by Language:\")\n        print(tools_df['language'].value_counts())\n\n    if 'maintenance_status' in tools_df.columns:\n        print(\"\\nTools by Maintenance Status:\")\n        print(tools_df['maintenance_status'].value_counts())\n</code></pre>"},{"location":"api/examples/#r","title":"R","text":"<p>Create a visualization of tools by category:</p> <pre><code>library(httr)\nlibrary(jsonlite)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Fetch statistics\nstats_url &lt;- \"https://shandley.github.io/awesome-virome/api/v1/stats.json\"\nstats_response &lt;- GET(stats_url)\nstats_data &lt;- fromJSON(content(stats_response, \"text\", encoding = \"UTF-8\"))\n\n# Extract category data for visualization\ncategories_df &lt;- data.frame(\n  Category = names(stats_data$tools_by_category),\n  Count = unlist(stats_data$tools_by_category),\n  stringsAsFactors = FALSE\n)\n\n# Sort by count descending\ncategories_df &lt;- categories_df %&gt;% arrange(desc(Count))\n\n# Create bar chart\nggplot(categories_df, aes(x = reorder(Category, -Count), y = Count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  theme_minimal() +\n  labs(title = \"Virome Analysis Tools by Category\",\n       x = \"Category\",\n       y = \"Number of Tools\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n# Save the plot\nggsave(\"tools_by_category.png\", width = 10, height = 6)\n</code></pre>"},{"location":"api/examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/examples/#tool-recommendation-system","title":"Tool Recommendation System","text":"<p>This JavaScript example creates a simple tool recommendation system based on user requirements:</p> <pre><code>async function recommendTools(requirements) {\n  try {\n    // Fetch all tools\n    const response = await fetch('https://shandley.github.io/awesome-virome/api/v1/tools.json');\n    const data = await response.json();\n\n    // Score each tool based on requirements\n    const scoredTools = data.tools.map(tool =&gt; {\n      let score = 0;\n\n      // Category match\n      if (requirements.category &amp;&amp; tool.category === requirements.category) {\n        score += 3;\n      }\n\n      // Language match\n      if (requirements.language &amp;&amp; tool.language === requirements.language) {\n        score += 2;\n      }\n\n      // Maintenance status (prefer active tools)\n      if (tool.maintenance_status === 'Active') {\n        score += 1;\n      }\n\n      // Citation count (normalized 0-2 points)\n      if (tool.citation_count) {\n        const normalizedCitations = Math.min(tool.citation_count / 500, 1) * 2;\n        score += normalizedCitations;\n      }\n\n      // GitHub stars (normalized 0-2 points)\n      if (tool.github_stars) {\n        const normalizedStars = Math.min(tool.github_stars / 1000, 1) * 2;\n        score += normalizedStars;\n      }\n\n      return {\n        ...tool,\n        score\n      };\n    });\n\n    // Return top 5 recommendations\n    const recommendations = scoredTools\n      .sort((a, b) =&gt; b.score - a.score)\n      .slice(0, 5);\n\n    return recommendations;\n  } catch (error) {\n    console.error('Error fetching tools for recommendation:', error);\n    return [];\n  }\n}\n\n// Example usage\nconst userRequirements = {\n  category: 'Host Prediction',\n  language: 'Python'\n};\n\nrecommendTools(userRequirements)\n  .then(recommendations =&gt; {\n    console.log('Top recommendations:');\n    recommendations.forEach((tool, index) =&gt; {\n      console.log(`${index + 1}. ${tool.name} (Score: ${tool.score.toFixed(1)})`);\n      console.log(`   Description: ${tool.description}`);\n      console.log(`   URL: ${tool.url}`);\n      console.log('');\n    });\n  });\n</code></pre>"},{"location":"api/examples/#python-data-visualization","title":"Python Data Visualization","text":"<p>This Python script creates simple visualizations for tool data:</p> <pre><code>import requests\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Fetch all tools\ndef fetch_tools():\n    url = 'https://shandley.github.io/awesome-virome/api/v1/tools.json'\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()['tools']\n    else:\n        print(f\"Error fetching tools: {response.status_code}\")\n        return []\n\ntools = fetch_tools()\ndf = pd.DataFrame(tools)\n\n# Set up the plotting environment\nplt.style.use('ggplot')\nplt.figure(figsize=(12, 8))\n\n# Create a bar chart of tools by category\ncategory_counts = df['category'].value_counts()\nplt.subplot(2, 1, 1)\nsns.barplot(x=category_counts.index, y=category_counts.values)\nplt.title('Tools by Category')\nplt.xticks(rotation=45, ha='right')\nplt.ylabel('Number of Tools')\nplt.tight_layout()\n\n# Create a pie chart of tool programming languages\nplt.subplot(2, 1, 2)\nlanguage_counts = df['language'].value_counts()\nplt.pie(language_counts, labels=language_counts.index, autopct='%1.1f%%')\nplt.title('Tools by Programming Language')\nplt.axis('equal')\nplt.tight_layout()\n\n# Save the figure\nplt.savefig('awesome_virome_stats.png')\nplt.close()\n\nprint(f\"Visualization saved as awesome_virome_stats.png\")\n\n# Print some basic statistics\nprint(\"\\nBasic Statistics:\")\nprint(f\"Total number of tools: {len(df)}\")\n\nif 'maintenance_status' in df.columns:\n    print(\"\\nTools by Maintenance Status:\")\n    print(df['maintenance_status'].value_counts())\n\nif 'category' in df.columns:\n    print(\"\\nTop Categories:\")\n    print(category_counts.head(5))\n\nif 'citation_count' in df.columns:\n    print(\"\\nMost Cited Tools:\")\n    most_cited = df.sort_values('citation_count', ascending=False).head(5)\n    for _, tool in most_cited.iterrows():\n        print(f\"- {tool['name']}: {tool['citation_count']} citations\")\n</code></pre>"},{"location":"api/examples/#command-line-tool-examples","title":"Command-Line Tool Examples","text":""},{"location":"api/examples/#shell-script-for-category-summary","title":"Shell Script for Category Summary","text":"<p>This Bash script summarizes tools by category:</p> <pre><code>#!/bin/bash\n\n# Function to fetch and display category information\nfetch_category() {\n  local category_slug=$1\n  echo \"Fetching information for category: $category_slug\"\n\n  # Fetch category data\n  response=$(curl -s \"https://shandley.github.io/awesome-virome/api/v1/categories/$category_slug.json\")\n\n  # Extract and display information\n  category=$(echo $response | jq -r '.category')\n  description=$(echo $response | jq -r '.description')\n  count=$(echo $response | jq -r '.count')\n\n  echo \"===================================\"\n  echo \"Category: $category\"\n  echo \"Description: $description\"\n  echo \"Number of tools: $count\"\n  echo \"===================================\"\n\n  # Show top 5 tools\n  echo \"Top tools in this category:\"\n  echo $response | jq -r '.tools[0:5] | .[] | \"- \\(.name): \\(.description)\"'\n  echo \"\"\n}\n\n# Fetch categories\necho \"Fetching available categories...\"\ncategories=$(curl -s \"https://shandley.github.io/awesome-virome/api/v1/categories.json\")\n\n# Display categories\necho \"Available categories:\"\necho $categories | jq -r '.categories[] | .slug'\necho \"\"\n\n# Process each category\necho $categories | jq -r '.categories[] | .slug' | while read -r category_slug; do\n  fetch_category \"$category_slug\"\ndone\n</code></pre>"},{"location":"api/examples/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed endpoint documentation</li> <li>Check out the API Overview for general information</li> <li>Visit the Tools section to learn about the available tools</li> </ul>"},{"location":"api/overview/","title":"Awesome-Virome API","text":"<p>Awesome-Virome provides a REST API that allows programmatic access to the curated database of virome analysis tools. This enables developers and researchers to build applications, workflows, or custom analyses on top of the dataset.</p>"},{"location":"api/overview/#api-features","title":"API Features","text":"<ul> <li>Base URL: <code>https://shandley.github.io/awesome-virome/api/v1/</code></li> <li>Format: All endpoints return JSON</li> <li>Authentication: No authentication required</li> <li>CORS-Enabled: Accessible from browser applications</li> <li>Cache-Friendly: Responses include appropriate cache headers</li> </ul>"},{"location":"api/overview/#getting-started","title":"Getting Started","text":"<p>Here's a simple example of how to fetch the complete list of tools using JavaScript:</p> <pre><code>fetch('https://shandley.github.io/awesome-virome/api/v1/tools.json')\n  .then(response =&gt; response.json())\n  .then(data =&gt; {\n    console.log(`Found ${data.count} tools`);\n    // Process the tools data\n  });\n</code></pre> <p>Or using Python:</p> <pre><code>import requests\n\nresponse = requests.get('https://shandley.github.io/awesome-virome/api/v1/tools.json')\ndata = response.json()\nprint(f\"Found {data['count']} tools\")\n# Process the tools data\n</code></pre>"},{"location":"api/overview/#available-endpoints","title":"Available Endpoints","text":"Endpoint Description Example <code>/api/v1/tools.json</code> Complete list of all tools with metadata View <code>/api/v1/categories.json</code> List of all tool categories View <code>/api/v1/search.json</code> Lightweight index for client-side filtering View <code>/api/v1/stats.json</code> Aggregate statistics about the tools collection View <code>/api/v1/categories/{category_slug}.json</code> Tools filtered by category Example"},{"location":"api/overview/#data-structure","title":"Data Structure","text":"<p>The API returns data with a consistent structure across endpoints. Here's an example of a tool entry:</p> <pre><code>{\n  \"name\": \"VirSorter2\",\n  \"description\": \"Random forest classifier for virus detection\",\n  \"url\": \"https://bitbucket.org/MAVERICLab/virsorter2/\",\n  \"category\": \"Virus and Phage Identification\",\n  \"subcategory\": \"Metagenome Analysis\",\n  \"language\": \"Python\",\n  \"github_stars\": null,\n  \"package_manager\": \"conda\",\n  \"latest_version\": \"v2.2.4\",\n  \"latest_release_date\": \"2023-04-15\",\n  \"license\": \"GPL-3.0\",\n  \"citation_count\": 342,\n  \"maintenance_status\": \"Active\"\n}\n</code></pre>"},{"location":"api/overview/#rate-limiting","title":"Rate Limiting","text":"<p>The API is served from GitHub Pages and doesn't have explicit rate limits. However, we recommend:</p> <ul> <li>Implementing caching in your applications</li> <li>Limiting requests to a reasonable frequency</li> <li>Downloading the full dataset for heavy processing rather than making many small requests</li> </ul>"},{"location":"api/overview/#use-cases","title":"Use Cases","text":"<p>The API enables many interesting use cases:</p> <ul> <li>Tool Discovery Applications: Build custom interfaces for discovering tools</li> <li>Scientific Workflows: Integrate tool metadata into computational pipelines</li> <li>Academic Research: Analyze trends in virome analysis tool development</li> <li>Recommendation Systems: Create intelligent tool recommendation systems based on user needs</li> <li>Custom Dashboards: Build specialized visualizations for specific types of tools</li> </ul>"},{"location":"api/overview/#versioning","title":"Versioning","text":"<p>The API uses a versioned URL structure (currently <code>v1</code>). This ensures that future changes to the API won't break existing applications. If we introduce breaking changes, we'll create a new version (e.g., <code>v2</code>) while maintaining the old version for backward compatibility.</p>"},{"location":"api/overview/#api-changelog","title":"API Changelog","text":""},{"location":"api/overview/#v1-current","title":"v1 (Current)","text":"<ul> <li>Initial release with core endpoints</li> <li>Support for all tool categories</li> <li>Basic statistics and search index</li> <li>Complete metadata for all tools</li> </ul>"},{"location":"api/overview/#need-help","title":"Need Help?","text":"<p>If you have questions about the API or encounter any issues, please:</p> <ol> <li>Check the complete API documentation</li> <li>Look at the example code</li> <li>Open an issue on GitHub if you find a bug or have a feature request</li> </ol>"},{"location":"best-practices/quality-control/","title":"Quality Control Best Practices","text":"<p>Last Updated: November 29, 2025</p> <p>Quality control (QC) is critical at every stage of virome analysis. Poor QC leads to false positives, missed discoveries, and irreproducible results. This guide covers best practices for QC throughout the entire workflow.</p>"},{"location":"best-practices/quality-control/#overview","title":"Overview","text":"<p>QC checkpoints in virome analysis:</p> <ol> <li>Sample Quality - Before sequencing</li> <li>Sequencing Quality - Raw reads</li> <li>Assembly Quality - Contigs</li> <li>Viral Identification Quality - Predicted viral sequences</li> <li>Annotation Quality - Gene predictions and functional assignments</li> <li>Final Dataset Quality - Publication-ready results</li> </ol>"},{"location":"best-practices/quality-control/#1-sample-quality-control","title":"1. Sample Quality Control","text":""},{"location":"best-practices/quality-control/#pre-sequencing-qc","title":"Pre-Sequencing QC","text":"<p>DNA/RNA Quantity: <pre><code># Qubit fluorometry (most accurate for low concentrations)\n# Target: &gt;50 ng total for standard library prep\n# Minimum: 10 ng (may require amplification)\n\n# Check concentration\nqubit dsDNA HS sample.dna\n# Expected: 5-100 ng/\u03bcL for virome samples\n</code></pre></p> <p>DNA/RNA Quality: <pre><code># Check purity ratios\nnanodrop sample.dna\n\n# Good quality indicators:\n# 260/280 ratio: 1.8-2.0 (1.8 for DNA, 2.0 for RNA)\n# 260/230 ratio: 2.0-2.2 (lower indicates contamination)\n</code></pre></p> <p>Contamination Indicators</p> <ul> <li>260/280 &lt; 1.7: Protein contamination</li> <li>260/280 &gt; 2.2: RNA contamination (DNA samples)</li> <li>260/230 &lt; 1.8: Salt, phenol, or humic acid contamination</li> <li>Brown color: Humic acids (soil samples) - requires additional cleanup</li> </ul> <p>Fragment Size: <pre><code># Run Bioanalyzer or TapeStation\n# Expected for viral samples:\n# - DNA viruses: Broad range (few kb to 100+ kb)\n# - High-quality samples: Distinct peaks &gt;10 kb\n# - Degraded samples: Smear &lt;5 kb (may still be usable)\n</code></pre></p>"},{"location":"best-practices/quality-control/#negative-controls","title":"Negative Controls","text":"<p>Include at every stage: - Extraction blank: No sample input - Library prep blank: No DNA input - PCR blank: No template (if using amplification)</p> <pre><code># Sequence negative controls\n# Good run indicators:\n# - &lt;1% reads in neg controls vs samples\n# - Different taxonomic composition than samples\n# - No \"sample-specific\" viruses in neg controls\n</code></pre>"},{"location":"best-practices/quality-control/#2-sequencing-quality-control","title":"2. Sequencing Quality Control","text":""},{"location":"best-practices/quality-control/#raw-read-qc","title":"Raw Read QC","text":"<p>Run FastQC or FastP: <pre><code># FastQC for visualization\nfastqc reads_R1.fastq.gz reads_R2.fastq.gz -o qc_reports/\n\n# FastP for QC + filtering\nfastp \\\n    -i reads_R1.fastq.gz -I reads_R2.fastq.gz \\\n    -o clean_R1.fastq.gz -O clean_R2.fastq.gz \\\n    -h report.html -j report.json \\\n    --detect_adapter_for_pe \\\n    --qualified_quality_phred 20 \\\n    --length_required 50\n</code></pre></p> <p>Key Metrics to Check:</p> Metric Good Warning Poor Total Reads &gt;10M 5-10M &lt;5M Q30 Score &gt;90% 80-90% &lt;80% GC Content 35-55% 30-60% &lt;30% or &gt;60% Adapter Content &lt;5% 5-10% &gt;10% Duplication Rate &lt;30% 30-50% &gt;50%* <p>*High duplication (30-70%) is normal for viral samples due to high viral abundance</p> <p>Virome-Specific QC Expectations</p> <ul> <li>GC content: Highly variable (some viruses are AT-rich, others GC-rich)</li> <li>Duplication: Higher than bacterial metagenomes (20-50% normal)</li> <li>Insert size: Should match library prep protocol</li> </ul>"},{"location":"best-practices/quality-control/#post-qc-metrics","title":"Post-QC Metrics","text":"<pre><code># Count reads before/after QC\necho \"Before QC: $(zcat raw_R1.fastq.gz | wc -l | awk '{print $1/4}')\"\necho \"After QC: $(zcat clean_R1.fastq.gz | wc -l | awk '{print $1/4}')\"\n\n# Acceptable QC pass rate:\n# &gt;85%: Excellent\n# 70-85%: Good\n# &lt;70%: Poor - check sample quality or sequencing issues\n</code></pre>"},{"location":"best-practices/quality-control/#3-assembly-quality-control","title":"3. Assembly Quality Control","text":""},{"location":"best-practices/quality-control/#assembly-metrics","title":"Assembly Metrics","text":"<pre><code># Calculate N50, L50, total length\nseqkit stats contigs.fasta\n\n# Use MetaQUAST for detailed assembly metrics\nmetaquast.py contigs.fasta -o quast_results/\n</code></pre> <p>Key Assembly Metrics:</p> Metric Good Acceptable Poor N50 &gt;10 kb 5-10 kb &lt;5 kb Longest Contig &gt;50 kb 20-50 kb &lt;20 kb Total Assembly &gt;10 Mb 5-10 Mb &lt;5 Mb Contigs &gt;1kb &gt;1,000 500-1,000 &lt;500 <p>Virome-specific considerations: - Small genomes expected (most 20-150 kb) - Fragmentation is common (incomplete genomes) - Chimeric contigs possible (mix of viruses)</p>"},{"location":"best-practices/quality-control/#detect-chimeric-contigs","title":"Detect Chimeric Contigs","text":"<pre><code># Check for abrupt GC content changes\n# Chimeric contigs show discontinuities in GC content\n\npython3 &lt;&lt; 'EOF'\nfrom Bio import SeqIO\nimport numpy as np\n\ndef calculate_gc_sliding(seq, window=1000, step=500):\n    gc_values = []\n    for i in range(0, len(seq) - window, step):\n        subseq = seq[i:i+window]\n        gc = (subseq.count('G') + subseq.count('C')) / len(subseq) * 100\n        gc_values.append(gc)\n    return gc_values\n\nfor record in SeqIO.parse('contigs.fasta', 'fasta'):\n    if len(record.seq) &gt; 5000:  # Only check long contigs\n        gc_profile = calculate_gc_sliding(str(record.seq))\n\n        # Check for large GC jumps (&gt;15% change = potential chimera)\n        if len(gc_profile) &gt; 2:\n            max_jump = max(abs(gc_profile[i+1] - gc_profile[i])\n                           for i in range(len(gc_profile)-1))\n\n            if max_jump &gt; 15:\n                print(f\"Potential chimera: {record.id} (GC jump: {max_jump:.1f}%)\")\nEOF\n</code></pre>"},{"location":"best-practices/quality-control/#coverage-analysis","title":"Coverage Analysis","text":"<pre><code># Map reads back to contigs to check coverage\nbbmap.sh in=reads.fq ref=contigs.fasta out=mapped.sam covstats=coverage.txt\n\n# Good assembly indicators:\n# - Even coverage across contigs (no sudden drops)\n# - Coverage &gt;10x for most contigs\n# - Consistent coverage within contigs (no breakpoints)\n</code></pre>"},{"location":"best-practices/quality-control/#4-viral-identification-quality-control","title":"4. Viral Identification Quality Control","text":""},{"location":"best-practices/quality-control/#multiple-tool-validation","title":"Multiple Tool Validation","text":"<p>Critical: Use Multiple Tools</p> <p>Never rely on a single viral identification tool. False positive rates are 10-30% for individual tools.</p> <pre><code># Run at least 2-3 tools:\n# VirSorter2\nvirsorter run -i contigs.fa --min-score 0.5 -w vs2_out/ all\n\n# VIBRANT\nVIBRANT_run.py -i contigs.fa -folder vibrant_out/\n\n# geNomad\ngenomad end-to-end contigs.fa genomad_out/ genomad_db/\n\n# Take consensus: contigs predicted by \u22652 tools\n# (See Tutorial 1 for detailed implementation)\n</code></pre> <p>Recommended Thresholds:</p> Tool Parameter Conservative Balanced Sensitive VirSorter2 --min-score 0.9 0.7 0.5 VIBRANT - Default Default Default geNomad --min-score 0.9 0.8 0.7 Consensus Min tools 3/3 2/3 1/3* <p>*Not recommended - high false positive rate</p>"},{"location":"best-practices/quality-control/#checkv-quality-assessment","title":"CheckV Quality Assessment","text":"<pre><code># Always run CheckV on viral predictions\ncheckv end_to_end viral_contigs.fasta checkv_out/ -t 8\n\n# Filter by quality\nawk -F'\\t' '$8 == \"Complete\" || $8 == \"High-quality\" {print $1}' \\\n    checkv_out/quality_summary.tsv &gt; hq_viral_ids.txt\n\n# Quality tier guidelines:\n# Complete (&gt;90% complete): Use for all analyses\n# High-quality (&gt;50% complete): Use for most analyses\n# Medium-quality: Use for diversity, but validate taxonomy\n# Low-quality: Use with extreme caution or exclude\n</code></pre> <p>CheckV Red Flags:</p> <pre><code># Check for problems\nawk -F'\\t' '$10 &gt; 10 {print $1, $10}' checkv_out/quality_summary.tsv\n# High contamination (&gt;10%) indicates:\n# - False positive (not actually viral)\n# - Prophage with flanking host genes\n# - Chimeric assembly\n\n# Solutions:\n# - Use CheckV's cleaned sequences (contamination removed)\n# - Increase viral prediction stringency\n# - Manually inspect suspicious contigs\n</code></pre>"},{"location":"best-practices/quality-control/#5-annotation-quality-control","title":"5. Annotation Quality Control","text":""},{"location":"best-practices/quality-control/#gene-prediction-qc","title":"Gene Prediction QC","text":"<pre><code># Run Prodigal\nprodigal -i viral_contigs.fa -a proteins.faa -p meta\n\n# Check gene prediction sanity\npython3 &lt;&lt; 'EOF'\nfrom Bio import SeqIO\n\nproteins = list(SeqIO.parse('proteins.faa', 'fasta'))\ntotal_prots = len(proteins)\n\n# Calculate statistics\nlengths = [len(p.seq) for p in proteins]\navg_length = sum(lengths) / len(lengths)\n\nprint(f\"Total proteins predicted: {total_prots}\")\nprint(f\"Average protein length: {avg_length:.0f} aa\")\n\n# Red flags:\nif avg_length &lt; 100:\n    print(\"WARNING: Very short average protein length - check gene prediction\")\nif total_prots &lt; 100:\n    print(\"WARNING: Very few proteins - check input\")\nEOF\n\n# Expected for viral genomes:\n# Average protein length: 150-300 aa\n# Genes per kb: ~1-1.5 (viruses are gene-dense)\n</code></pre>"},{"location":"best-practices/quality-control/#functional-annotation-qc","title":"Functional Annotation QC","text":"<pre><code># After annotation (e.g., with Pharokka, DRAMv)\n# Check for viral hallmark genes\n\n# Expected in most viral genomes:\n# - Terminase (DNA packaging)\n# - Major capsid protein\n# - Portal protein\n# - Tail proteins (tailed phages)\n\n# Red flags:\n# - &gt;50% hypothetical proteins (normal for novel viruses)\n# - Many bacterial genes (possible host contamination)\n# - No structural genes (possible false positive)\n</code></pre>"},{"location":"best-practices/quality-control/#6-taxonomic-assignment-quality-control","title":"6. Taxonomic Assignment Quality Control","text":""},{"location":"best-practices/quality-control/#blast-based-qc","title":"BLAST-Based QC","text":"<pre><code># Check BLAST hits for sanity\nblastn -query viral_contigs.fa -db nt -outfmt 6 -max_target_seqs 5 \\\n    &gt; blast_results.txt\n\n# Analyze top hits\ncut -f1,2,3 blast_results.txt | head -20\n\n# Red flags:\n# - Top hits to non-viral sequences (bacteria, eukaryotes)\n# - Very low identity to known viruses (&lt;70%)\n# - Hits to vectors, contaminants\n</code></pre> <p>Identity Interpretation:</p> BLAST Identity Interpretation Confidence &gt;95% Same species/strain High 85-95% Same genus High 70-85% Same family Medium 50-70% Distantly related Low &lt;50% Very distant or novel Very Low"},{"location":"best-practices/quality-control/#taxonomic-consistency-check","title":"Taxonomic Consistency Check","text":"<pre><code># Check that taxonomic assignments are consistent\n# E.g., if proteins BLAST to different virus families, investigate\n\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load protein BLAST results\nblast = pd.read_csv('protein_blast.txt', sep='\\t',\n                    header=None, names=['protein', 'hit', 'pident', ...])\n\n# Extract virus families (requires parsing taxonomy)\n# Check if all proteins from same contig hit same family\n\n# Red flag: Proteins from same contig hit different families\n# Could indicate:\n# - Chimeric contig\n# - Horizontal gene transfer\n# - Incorrect taxonomy in database\nEOF\n</code></pre>"},{"location":"best-practices/quality-control/#7-abundance-estimation-quality-control","title":"7. Abundance Estimation Quality Control","text":""},{"location":"best-practices/quality-control/#mapping-qc","title":"Mapping QC","text":"<pre><code># Check mapping statistics\nsamtools flagstat mapped.bam\n\n# Good mapping indicators:\n# - Properly paired: &gt;80%\n# - Mapping quality &gt;30: &gt;90%\n# - Duplicates: &lt;50% (higher for abundant viruses OK)\n\n# Coverage distribution\nsamtools depth mapped.bam | awk '{sum+=$3; count++} END {print \"Mean coverage:\", sum/count}'\n</code></pre>"},{"location":"best-practices/quality-control/#coverage-uniformity","title":"Coverage Uniformity","text":"<pre><code># Check for even coverage (no bias)\n# Uneven coverage indicates:\n# - PCR bias\n# - Repetitive regions\n# - Chimeric contigs\n\n# Calculate coefficient of variation (CV) for coverage\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport numpy as np\n\ndepth = pd.read_csv('coverage.txt', sep='\\t',\n                    header=None, names=['contig', 'pos', 'depth'])\n\n# Calculate CV per contig\nfor contig in depth['contig'].unique():\n    contig_depth = depth[depth['contig'] == contig]['depth']\n\n    mean_cov = contig_depth.mean()\n    std_cov = contig_depth.std()\n    cv = (std_cov / mean_cov) * 100 if mean_cov &gt; 0 else 0\n\n    if cv &gt; 100:  # Very high CV\n        print(f\"WARNING: Uneven coverage for {contig} (CV={cv:.1f}%)\")\nEOF\n</code></pre>"},{"location":"best-practices/quality-control/#8-reproducibility-qc","title":"8. Reproducibility QC","text":""},{"location":"best-practices/quality-control/#document-everything","title":"Document Everything","text":"<p>Create analysis log: <pre><code># Record all commands and versions\necho \"Analysis started: $(date)\" &gt; analysis_log.txt\necho \"VirSorter2 version: $(virsorter -v)\" &gt;&gt; analysis_log.txt\necho \"CheckV version: $(checkv -v)\" &gt;&gt; analysis_log.txt\n# ... etc.\n\n# Log parameters\necho \"VirSorter2 command:\" &gt;&gt; analysis_log.txt\necho \"virsorter run --min-score 0.5 ...\" &gt;&gt; analysis_log.txt\n</code></pre></p> <p>Use version control: <pre><code># Track analysis scripts\ngit init virome_analysis/\ngit add *.sh *.py\ngit commit -m \"Initial analysis scripts\"\n</code></pre></p>"},{"location":"best-practices/quality-control/#random-seed-setting","title":"Random Seed Setting","text":"<pre><code># Set random seeds for reproducible results\n# In Python:\nimport numpy as np\nimport random\nnp.random.seed(42)\nrandom.seed(42)\n\n# In R:\nset.seed(42)\n\n# For tools with random components (assembly, subsampling):\nspades.py --seed 42 ...\nseqtk sample -s42 reads.fq 1000000 &gt; subsample.fq\n</code></pre>"},{"location":"best-practices/quality-control/#9-final-dataset-qc-checklist","title":"9. Final Dataset QC Checklist","text":"<p>Before publication or downstream analysis:</p> <ul> <li>[ ] Sequencing depth adequate (&gt;10M reads for diversity studies)</li> <li>[ ] Assembly quality acceptable (N50 &gt;5kb)</li> <li>[ ] Viral predictions validated (consensus from \u22652 tools)</li> <li>[ ] CheckV quality assessed (majority High-quality or better)</li> <li>[ ] Contamination removed (host sequences, non-viral contigs)</li> <li>[ ] Negative controls clean (&lt;1% of sample reads)</li> <li>[ ] Taxonomic assignments reasonable (consistent with expected environment)</li> <li>[ ] Abundance estimates valid (even coverage, good mapping rates)</li> <li>[ ] Analysis documented (versions, parameters, scripts saved)</li> <li>[ ] Results reproducible (random seeds set, workflows saved)</li> </ul>"},{"location":"best-practices/quality-control/#10-common-qc-failures-and-solutions","title":"10. Common QC Failures and Solutions","text":""},{"location":"best-practices/quality-control/#problem-high-contamination-in-checkv","title":"Problem: High Contamination in CheckV","text":"<p>Diagnosis: <pre><code># Check contamination levels\nawk -F'\\t' '$10 &gt; 10 {print $1, $10}' checkv_out/quality_summary.tsv\n</code></pre></p> <p>Solutions: - Use CheckV's cleaned sequences (contamination auto-removed) - Increase viral prediction stringency - Check if samples are actually virome-enriched (VLP prep) - Filter out contigs with &gt;10% contamination</p>"},{"location":"best-practices/quality-control/#problem-most-viral-predictions-are-low-quality","title":"Problem: Most Viral Predictions are Low Quality","text":"<p>Diagnosis: <pre><code># Quality distribution\nawk -F'\\t' '{print $8}' checkv_out/quality_summary.tsv | sort | uniq -c\n</code></pre></p> <p>Solutions: - Increase sequencing depth (fragmentation due to low coverage) - Use longer read technology (PacBio, Nanopore) - Accept that novel viruses have lower completeness - Focus on High-quality+ subset for key analyses</p>"},{"location":"best-practices/quality-control/#problem-very-few-viral-sequences-identified","title":"Problem: Very Few Viral Sequences Identified","text":"<p>Possible causes: 1. Sample not enriched for viruses (need VLP prep) 2. Highly novel viruses (not recognized by tools) 3. Low viral biomass 4. Assembly fragmentation</p> <p>Diagnostic: <pre><code># Check if viral reads present\nseqtk sample -s42 reads.fq 100000 &gt; subsample.fq\nblastn -query subsample.fq -db viral_refseq -outfmt 6 | wc -l\n\n# If many viral BLAST hits but few contigs:\n# -&gt; Assembly issue, try different assembler or parameters\n# If few viral BLAST hits:\n# -&gt; Low viral content or highly novel viruses\n</code></pre></p>"},{"location":"best-practices/quality-control/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>QC at Every Step: Don't wait until the end to check quality</li> <li>Use Multiple Methods: Consensus predictions reduce false positives</li> <li>Keep Negative Controls: Identify and remove contamination</li> <li>Document Everything: Record versions, parameters, and decisions</li> <li>Validate Key Findings: Experimental validation for important results</li> <li>Be Realistic: Expect incomplete genomes and unknown taxonomy</li> <li>Set Thresholds Appropriately: Balance sensitivity vs specificity for your goals</li> </ol>"},{"location":"best-practices/quality-control/#further-reading","title":"Further Reading","text":"<ul> <li>Roux, S., et al. (2019). \"Minimum Information about an Uncultivated Virus Genome (MIUViG).\" Nature Biotechnology, 37(1), 29-37.</li> <li>Nayfach, S., et al. (2021). \"CheckV assesses the quality and completeness of metagenome-assembled viral genomes.\" Nature Biotechnology, 39(5), 578-585.</li> <li>Ewels, P., et al. (2016). \"MultiQC: summarize analysis results for multiple tools and samples in a single report.\" Bioinformatics, 32(19), 3047-3048.</li> </ul>"},{"location":"best-practices/reproducibility/","title":"Reproducibility Best Practices","text":"<p>Last Updated: November 29, 2025</p> <p>Reproducible research is essential for scientific integrity and enables others to build on your work. This guide covers best practices for making your virome analyses reproducible.</p>"},{"location":"best-practices/reproducibility/#core-principles","title":"Core Principles","text":"<p>Reproducibility means: - Same data + same analysis = same results - Others can verify your findings - Future you can re-run analyses</p> <p>Three pillars: 1. Documentation - Record what you did 2. Version Control - Track changes over time 3. Environment Management - Ensure consistent software</p>"},{"location":"best-practices/reproducibility/#documentation-best-practices","title":"Documentation Best Practices","text":""},{"location":"best-practices/reproducibility/#analysis-log","title":"Analysis Log","text":"<p>Create a lab notebook for bioinformatics: <pre><code># Start a log file\necho \"# Virome Analysis Log\" &gt; analysis_log.md\necho \"Started: $(date)\" &gt;&gt; analysis_log.md\necho \"\" &gt;&gt; analysis_log.md\n\n# Record each step\ncat &gt;&gt; analysis_log.md &lt;&lt; 'ENTRY'\n## Step 1: Quality Control\nDate: 2025-11-29\nTool: fastp v0.23.4\nCommand: fastp -i R1.fq.gz -I R2.fq.gz -o clean_R1.fq -O clean_R2.fq\nInput: 10,234,567 read pairs\nOutput: 9,123,456 read pairs (89.1%)\nENTRY\n</code></pre></p>"},{"location":"best-practices/reproducibility/#readme-files","title":"README Files","text":"<p>Every project should have: <pre><code># Project: Marine Virome Time Series\n\n## Overview\nAnalysis of viral communities across seasonal time series\n\n## Data Location\n- Raw sequences: `/data/raw_reads/`\n- Assembled contigs: `/data/assembly/`\n- Final viral contigs: `/results/viral_contigs.fa`\n\n## Software Requirements\nSee `environment.yml`\n\n## Analysis Steps\n1. QC: `scripts/01_quality_control.sh`\n2. Assembly: `scripts/02_assembly.sh`\n3. Viral ID: `scripts/03_viral_identification.sh`\n\n## Key Results\n- 234 viral contigs identified\n- See `results/summary_stats.txt`\n\n## Contact\nYour Name (email@institution.edu)\n</code></pre></p>"},{"location":"best-practices/reproducibility/#metadata-management","title":"Metadata Management","text":"<p>Track sample metadata: <pre><code>Sample_ID   Collection_Date Location    Depth_m Temp_C  pH  Sequencing_Date Reads\nS001    2024-01-15  Station_A   10  8.5 7.8 2024-02-01  12534678\nS002    2024-01-15  Station_A   10  8.5 7.8 2024-02-01  11234567\nS003    2024-04-15  Station_A   10  12.1    7.9 2024-05-01  13456789\n</code></pre></p> <p>Include: - Sample collection details - Processing dates - Technical parameters - Sequencing metrics</p>"},{"location":"best-practices/reproducibility/#version-control-with-git","title":"Version Control with Git","text":""},{"location":"best-practices/reproducibility/#initialize-repository","title":"Initialize Repository","text":"<pre><code># Create git repo\ncd ~/virome_project\ngit init\n\n# Create .gitignore (don't track large files)\ncat &gt; .gitignore &lt;&lt; 'GITIGNORE'\n# Raw data (too large for git)\n*.fastq\n*.fastq.gz\n*.fq\n*.fq.gz\n\n# Temporary files\n*.tmp\n*.log\n\n# Large results\n*.bam\n*.sam\n\n# Keep\n!*.sh\n!*.py\n!*.R\n!*.md\nGITIGNORE\n\n# Initial commit\ngit add .\ngit commit -m \"Initial project structure\"\n</code></pre>"},{"location":"best-practices/reproducibility/#commit-best-practices","title":"Commit Best Practices","text":"<pre><code># Make frequent, descriptive commits\ngit add scripts/quality_control.sh\ngit commit -m \"Add QC script with fastp parameters\"\n\n# NOT:\ngit commit -m \"Update\"  # Too vague!\n\n# Branch for experimental changes\ngit checkout -b test_new_assembler\n# ... test changes ...\ngit checkout main  # Switch back if it didn't work\n</code></pre>"},{"location":"best-practices/reproducibility/#remote-backup","title":"Remote Backup","text":"<pre><code># Push to GitHub/GitLab\ngit remote add origin https://github.com/username/virome_project.git\ngit push -u origin main\n\n# Enables collaboration and backup\n</code></pre>"},{"location":"best-practices/reproducibility/#software-environment-management","title":"Software Environment Management","text":""},{"location":"best-practices/reproducibility/#conda-environments","title":"Conda Environments","text":"<p>Create reproducible environment: <pre><code># Create environment\nconda create -n virome_v1 python=3.9\n\n# Install tools\nconda activate virome_v1\nconda install -c bioconda -c conda-forge \\\n    fastp=0.23.4 \\\n    spades=3.15.5 \\\n    virsorter=2.2.4 \\\n    checkv=1.0.1\n\n# Export environment (CRITICAL for reproducibility)\nconda env export &gt; environment.yml\n\n# Others can recreate:\nconda env create -f environment.yml\n</code></pre></p> <p>environment.yml format: <pre><code>name: virome_v1\nchannels:\n  - bioconda\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.9\n  - fastp=0.23.4\n  - spades=3.15.5\n  - virsorter=2.2.4\n  - checkv=1.0.1\n</code></pre></p>"},{"location":"best-practices/reproducibility/#docker-containers","title":"Docker Containers","text":"<p>For maximum reproducibility: <pre><code># Dockerfile\nFROM continuumio/miniconda3:latest\n\n# Install tools\nRUN conda install -c bioconda -c conda-forge \\\n    fastp=0.23.4 spades=3.15.5 virsorter=2.2.4\n\n# Add scripts\nCOPY scripts/ /opt/scripts/\n\n# Set entrypoint\nENTRYPOINT [\"/bin/bash\"]\n</code></pre></p> <pre><code># Build container\ndocker build -t virome_analysis:v1.0 .\n\n# Run analysis in container\ndocker run -v $(pwd):/data virome_analysis:v1.0 \\\n    /opt/scripts/run_analysis.sh\n</code></pre>"},{"location":"best-practices/reproducibility/#record-all-tool-versions","title":"Record All Tool Versions","text":"<pre><code># Create versions.txt\ncat &gt; versions.txt &lt;&lt; 'VERSIONS'\nTool Versions Used:\n- fastp: $(fastp --version 2&gt;&amp;1 | head -n1)\n- SPAdes: $(spades.py --version | head -n1)\n- VirSorter2: $(virsorter -v)\n- CheckV: $(checkv -v)\n- BLAST+: $(blastn -version | head -n1)\n- Python: $(python --version)\n- R: $(R --version | head -n1)\n\nSystem:\n- OS: $(uname -a)\n- Date: $(date)\nVERSIONS\n\n# Evaluate the commands\nbash versions.txt &gt; versions_actual.txt\n</code></pre>"},{"location":"best-practices/reproducibility/#workflow-management","title":"Workflow Management","text":""},{"location":"best-practices/reproducibility/#snakemake-recommended","title":"Snakemake (Recommended)","text":"<pre><code># Snakefile\nconfigfile: \"config.yaml\"\n\nrule all:\n    input:\n        \"results/viral_contigs.fa\"\n\nrule qc:\n    input:\n        r1=\"data/{sample}_R1.fastq.gz\",\n        r2=\"data/{sample}_R2.fastq.gz\"\n    output:\n        r1=\"qc/{sample}_clean_R1.fastq.gz\",\n        r2=\"qc/{sample}_clean_R2.fastq.gz\"\n    threads: 4\n    shell:\n        \"fastp -i {input.r1} -I {input.r2} \"\n        \"-o {output.r1} -O {output.r2} -w {threads}\"\n\nrule assembly:\n    input:\n        r1=\"qc/{sample}_clean_R1.fastq.gz\",\n        r2=\"qc/{sample}_clean_R2.fastq.gz\"\n    output:\n        \"assembly/{sample}/contigs.fasta\"\n    threads: 16\n    shell:\n        \"metaspades.py --metaviral -1 {input.r1} -2 {input.r2} \"\n        \"-o assembly/{sample} -t {threads}\"\n\n# Run workflow:\n# snakemake --cores 32\n</code></pre> <p>Benefits: - Automatic parallelization - Resumes from last successful step - Clear dependencies - Self-documenting</p>"},{"location":"best-practices/reproducibility/#nextflow-alternative","title":"Nextflow (Alternative)","text":"<pre><code>// main.nf\nparams.reads = \"data/*_R{1,2}.fastq.gz\"\nparams.outdir = \"results\"\n\nprocess QC {\n    cpus 4\n    publishDir \"${params.outdir}/qc\"\n\n    input:\n    tuple val(sample), path(reads)\n\n    output:\n    tuple val(sample), path(\"${sample}_clean_R*.fastq.gz\")\n\n    script:\n    \"\"\"\n    fastp -i ${reads[0]} -I ${reads[1]} \\\n        -o ${sample}_clean_R1.fastq.gz \\\n        -O ${sample}_clean_R2.fastq.gz -w ${task.cpus}\n    \"\"\"\n}\n\n// Run: nextflow run main.nf\n</code></pre>"},{"location":"best-practices/reproducibility/#data-management","title":"Data Management","text":""},{"location":"best-practices/reproducibility/#raw-data-preservation","title":"Raw Data Preservation","text":"<pre><code># NEVER modify raw data\n# Instead, create copies or symlinks\n\n# Read-only raw data\nchmod -R a-w raw_data/\n\n# Work on copies\ncp -r raw_data/ working_data/\n# OR symlink\nln -s /archive/project/raw_data data/raw\n</code></pre>"},{"location":"best-practices/reproducibility/#data-organization","title":"Data Organization","text":"<p>Recommended structure: <pre><code>project/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 environment.yml\n\u251c\u2500\u2500 Snakefile or workflow script\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 raw/          # Original, unchanged data (read-only)\n\u2502   \u251c\u2500\u2500 metadata/     # Sample information\n\u2502   \u2514\u2500\u2500 databases/    # Reference databases\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 01_qc.sh\n\u2502   \u251c\u2500\u2500 02_assembly.sh\n\u2502   \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 results/\n\u2502   \u251c\u2500\u2500 qc/\n\u2502   \u251c\u2500\u2500 assembly/\n\u2502   \u251c\u2500\u2500 viral_id/\n\u2502   \u2514\u2500\u2500 final/\n\u251c\u2500\u2500 notebooks/        # Jupyter/R notebooks for exploration\n\u251c\u2500\u2500 figures/\n\u2514\u2500\u2500 manuscript/\n</code></pre></p>"},{"location":"best-practices/reproducibility/#archiving-results","title":"Archiving Results","text":"<pre><code># Create compressed archive\ntar -czf virome_project_v1.0.tar.gz \\\n    scripts/ \\\n    results/final/ \\\n    environment.yml \\\n    README.md \\\n    versions.txt\n\n# Upload to long-term storage\n# - Zenodo (for data + DOI)\n# - Figshare\n# - Institutional repository\n</code></pre>"},{"location":"best-practices/reproducibility/#random-seed-management","title":"Random Seed Management","text":"<p>Set seeds for reproducibility:</p> <pre><code># Python\nimport numpy as np\nimport random\nnp.random.seed(42)\nrandom.seed(42)\n</code></pre> <pre><code># R\nset.seed(42)\n</code></pre> <pre><code># Command-line tools\nspades.py --seed 42 ...\nseqtk sample -s42 reads.fq 1000000 &gt; subsample.fq\n</code></pre>"},{"location":"best-practices/reproducibility/#parameters-and-configuration","title":"Parameters and Configuration","text":""},{"location":"best-practices/reproducibility/#configuration-files","title":"Configuration Files","text":"<pre><code># config.yaml\nassembly:\n  kmer_sizes: [21, 33, 55, 77]\n  threads: 16\n  memory_gb: 128\n\nviral_identification:\n  virsorter_score: 0.5\n  vibrant: true\n  genomad_score: 0.8\n  min_contig_length: 2000\n\nquality_control:\n  min_quality: 20\n  min_length: 50\n  adapter_trim: true\n</code></pre> <p>Use in scripts: <pre><code>import yaml\n\nwith open('config.yaml') as f:\n    config = yaml.safe_load(f)\n\nmin_score = config['viral_identification']['virsorter_score']\n</code></pre></p> <p>Benefits: - Single place to change parameters - Clear documentation of choices - Easy to test different settings</p>"},{"location":"best-practices/reproducibility/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"best-practices/reproducibility/#test-data","title":"Test Data","text":"<pre><code># Create small test dataset\nseqtk sample -s42 large_dataset.fq 10000 &gt; test_data.fq\n\n# Run full pipeline on test data\n# Should complete in &lt;30 minutes\n\n# If test passes, run on full data\n</code></pre>"},{"location":"best-practices/reproducibility/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Test Pipeline\n\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup conda\n        uses: conda-incubator/setup-miniconda@v2\n      - name: Install dependencies\n        run: conda env create -f environment.yml\n      - name: Run tests\n        run: |\n          conda activate virome\n          bash scripts/run_tests.sh\n</code></pre>"},{"location":"best-practices/reproducibility/#publication-and-sharing","title":"Publication and Sharing","text":""},{"location":"best-practices/reproducibility/#data-deposition","title":"Data Deposition","text":"<p>Before publication, deposit: 1. Raw sequences \u2192 SRA/ENA (NCBI) 2. Assembled genomes \u2192 GenBank 3. Analysis scripts \u2192 GitHub/GitLab 4. Final dataset \u2192 Zenodo (get DOI)</p> <pre><code># Example Zenodo upload structure:\nzenodo_upload/\n\u251c\u2500\u2500 README.txt\n\u251c\u2500\u2500 viral_contigs.fasta\n\u251c\u2500\u2500 abundance_table.tsv\n\u251c\u2500\u2500 taxonomy.tsv\n\u251c\u2500\u2500 metadata.tsv\n\u251c\u2500\u2500 environment.yml\n\u2514\u2500\u2500 analysis_scripts.tar.gz\n</code></pre>"},{"location":"best-practices/reproducibility/#code-availability-statement","title":"Code Availability Statement","text":"<p>Include in manuscript:</p> <p>\"All code used for this analysis is available at https://github.com/username/project (DOI: 10.5281/zenodo.XXXXX). The analysis workflow was managed with Snakemake v7.18 and executed in a Conda environment (environment.yml provided). Raw sequencing data have been deposited in the NCBI SRA under BioProject PRJNA123456.\"</p>"},{"location":"best-practices/reproducibility/#reproducibility-checklist","title":"Reproducibility Checklist","text":"<p>Before publication:</p> <ul> <li>[ ] All analysis scripts version controlled (Git)</li> <li>[ ] Software versions recorded (environment.yml or Dockerfile)</li> <li>[ ] Random seeds set for all stochastic steps</li> <li>[ ] Configuration files document all parameters</li> <li>[ ] README explains how to reproduce analysis</li> <li>[ ] Raw data preserved and deposited (SRA/ENA)</li> <li>[ ] Intermediate and final results archived</li> <li>[ ] Negative controls included and documented</li> <li>[ ] Analysis log documents decisions made</li> <li>[ ] Code runs on test dataset without errors</li> <li>[ ] GitHub repository public (or will be at publication)</li> <li>[ ] DOI obtained for code and data (Zenodo)</li> </ul>"},{"location":"best-practices/reproducibility/#common-reproducibility-failures","title":"Common Reproducibility Failures","text":""},{"location":"best-practices/reproducibility/#mistakes-to-avoid","title":"\u274c Mistakes to Avoid","text":"<ol> <li>\"It works on my machine\"</li> <li> <p>Solution: Use containers or detailed environment specs</p> </li> <li> <p>Hard-coded paths <pre><code># BAD:\ninput=\"/home/myname/project/data/sample1.fq\"\n\n# GOOD:\ninput=\"data/sample1.fq\"  # Relative path\n</code></pre></p> </li> <li> <p>Undocumented manual steps</p> </li> <li> <p>Solution: Automate everything, document unavoidable manual steps</p> </li> <li> <p>Overwriting data</p> </li> <li> <p>Solution: Make raw data read-only, work on copies</p> </li> <li> <p>Missing tool versions</p> </li> <li> <p>Solution: Export conda environment or use containers</p> </li> <li> <p>No random seed</p> </li> <li> <p>Solution: Set seeds for sampling, assembly, ML</p> </li> <li> <p>Lost intermediate files</p> </li> <li>Solution: Archive key intermediates, not just final results</li> </ol>"},{"location":"best-practices/reproducibility/#tools-for-reproducibility","title":"Tools for Reproducibility","text":"Tool Purpose When to Use Git Version control Always Conda Environment management Most projects Docker Containerization Maximum reproducibility Snakemake Workflow management Multi-step pipelines Nextflow Workflow management HPC or cloud Jupyter Interactive analysis Exploration, visualization Zenodo Data archiving + DOI Publication"},{"location":"best-practices/reproducibility/#further-reading","title":"Further Reading","text":"<ul> <li>Sandve, G. K., et al. (2013). \"Ten simple rules for reproducible computational research.\" PLoS Computational Biology.</li> <li>Wilson, G., et al. (2017). \"Good enough practices in scientific computing.\" PLoS Computational Biology.</li> <li>Gr\u00fcning, B., et al. (2018). \"Practical computational reproducibility in the life sciences.\" Cell Systems.</li> </ul>"},{"location":"best-practices/statistical-analysis/","title":"Statistical Analysis Best Practices","text":"<p>Last Updated: November 29, 2025</p> <p>Statistical rigor is essential for drawing valid conclusions from virome data. This guide covers best practices for experimental design, statistical testing, and result interpretation.</p>"},{"location":"best-practices/statistical-analysis/#experimental-design-principles","title":"Experimental Design Principles","text":""},{"location":"best-practices/statistical-analysis/#sample-size-determination","title":"Sample Size Determination","text":"<p>Minimum recommendations:</p> Study Type Minimum Samples Recommended Rationale Pilot/exploratory 3 5-10 Identify patterns Comparative (2 groups) 3 per group 5-10 per group Statistical power Time series 4 timepoints \u00d7 3 reps 6-10 timepoints \u00d7 3 reps Temporal trends Multi-factor 3 per condition 5 per condition Interaction effects <p>Power analysis (R example): <pre><code>library(pwr)\n\n# Calculate required sample size for t-test\n# Effect size: 0.8 (large), power: 0.8, alpha: 0.05\npwr.t.test(d=0.8, power=0.8, sig.level=0.05, type=\"two.sample\")\n\n# Typically need n=26 per group for medium effect (d=0.5)\n# n=6-10 per group is reasonable compromise for exploratory studies\n</code></pre></p>"},{"location":"best-practices/statistical-analysis/#replication-strategy","title":"Replication Strategy","text":"<p>Technical vs biological replicates:</p> <pre><code>Biological Replicates (CRITICAL):\n\u251c\u2500 Independent samples from different subjects/sites/timepoints\n\u251c\u2500 Captures biological variation\n\u2514\u2500 Required for statistical inference\n\nTechnical Replicates (OPTIONAL):\n\u251c\u2500 Same sample sequenced multiple times\n\u251c\u2500 Assesses technical noise\n\u2514\u2500 Usually not necessary with modern sequencing\n</code></pre> <p>Common Mistake</p> <p>Don't confuse technical and biological replicates! Sequencing the same sample 3 times \u2260 3 biological replicates.</p>"},{"location":"best-practices/statistical-analysis/#controls","title":"Controls","text":"<p>Essential controls: 1. Negative controls (extraction/library blanks) 2. Positive controls (mock communities with known viruses) 3. Time-matched controls (for time series) 4. Batch controls (for multi-batch studies)</p>"},{"location":"best-practices/statistical-analysis/#compositional-data-considerations","title":"Compositional Data Considerations","text":"<p>Virome data is compositional - relative abundances sum to 1 (or 100%).</p>"},{"location":"best-practices/statistical-analysis/#the-compositional-problem","title":"The Compositional Problem","text":"<pre><code># Example: Spurious correlation in compositional data\n\n# Sample A: Virus1=50, Virus2=50 (total=100)\n# Sample B: Virus1=25, Virus2=75 (total=100)\n\n# If we add Virus3 at high abundance to Sample B:\n# Sample B': Virus1=10, Virus2=30, Virus3=60 (total=100)\n\n# Virus1 and Virus2 appear to decrease, but only relative to Virus3!\n# This is called \"spurious correlation\"\n</code></pre>"},{"location":"best-practices/statistical-analysis/#solutions","title":"Solutions","text":"<p>1. Use compositional-aware methods: <pre><code>library(compositions)\nlibrary(ALDEx2)\n\n# ALDEx2 for differential abundance (compositional-aware)\naldex_result &lt;- aldex(counts, conditions, mc.samples=128, test=\"t\")\n\n# Filter significant\nsig_viruses &lt;- aldex_result[aldex_result$we.eBH &lt; 0.05, ]\n</code></pre></p> <p>2. Centered log-ratio (CLR) transformation: <pre><code>library(compositions)\n\n# CLR transformation\nclr_abundance &lt;- clr(abundance + 1)  # Add pseudocount to avoid log(0)\n\n# Now can use standard statistical methods on CLR-transformed data\n</code></pre></p> <p>3. Acknowledge limitations: - Report relative abundance changes, not absolute - Validate key findings with qPCR (absolute quantification) - Consider total viral load alongside composition</p>"},{"location":"best-practices/statistical-analysis/#alpha-diversity-analysis","title":"Alpha Diversity Analysis","text":""},{"location":"best-practices/statistical-analysis/#choosing-diversity-metrics","title":"Choosing Diversity Metrics","text":"Metric What It Measures When to Use Sensitive To Richness Number of vOTUs Presence/absence focus Rare species, sequencing depth Shannon Diversity (richness + evenness) General diversity Both common and rare species Simpson Dominance/evenness Community evenness Common species Faith's PD Phylogenetic diversity Evolutionary diversity Requires phylogeny <p>Implementation: <pre><code>library(vegan)\nlibrary(ggplot2)\n\n# Calculate multiple diversity metrics\ndiversity_metrics &lt;- data.frame(\n  Sample = rownames(abundance),\n  Richness = specnumber(abundance),\n  Shannon = diversity(abundance, index=\"shannon\"),\n  Simpson = diversity(abundance, index=\"simpson\"),\n  Evenness = diversity(abundance, index=\"shannon\") / log(specnumber(abundance))\n)\n\n# Merge with metadata\ndiv_data &lt;- merge(diversity_metrics, metadata, by=\"Sample\")\n\n# Plot\nggplot(div_data, aes(x=Treatment, y=Shannon, fill=Treatment)) +\n  geom_boxplot() +\n  geom_jitter(width=0.2) +\n  theme_minimal()\n</code></pre></p>"},{"location":"best-practices/statistical-analysis/#statistical-testing","title":"Statistical Testing","text":"<p>Compare diversity between groups: <pre><code># Parametric (if data is normally distributed)\nt.test(Shannon ~ Treatment, data=div_data)\n\n# Non-parametric (safer for small sample sizes)\nwilcox.test(Shannon ~ Treatment, data=div_data)\n\n# Multiple groups\nkruskal.test(Shannon ~ Treatment, data=div_data)\n\n# If significant, post-hoc test:\nlibrary(FSA)\ndunnTest(Shannon ~ Treatment, data=div_data, method=\"bh\")\n</code></pre></p> <p>Check assumptions: <pre><code># Test normality\nshapiro.test(div_data$Shannon)\n\n# Visual check\nqqnorm(div_data$Shannon)\nqqline(div_data$Shannon)\n\n# If p &lt; 0.05, data is not normal \u2192 use non-parametric tests\n</code></pre></p>"},{"location":"best-practices/statistical-analysis/#rarefaction","title":"Rarefaction","text":"<p>Account for unequal sequencing depth: <pre><code># Rarefy to minimum depth\nmin_depth &lt;- min(rowSums(abundance))\n\nrarefied &lt;- rrarefy(abundance, sample=min_depth)\n\n# Or use rarefaction curves\nrarecurve(abundance, step=1000, label=FALSE)\n\n# Calculate diversity on rarefied data\nshannon_rarefied &lt;- diversity(rarefied, index=\"shannon\")\n</code></pre></p> <p>Modern Alternative to Rarefaction</p> <p>Many statisticians now recommend NOT rarefying and instead using models that account for sequencing depth (e.g., DESeq2, edgeR). Rarefaction discards data.</p>"},{"location":"best-practices/statistical-analysis/#beta-diversity-analysis","title":"Beta Diversity Analysis","text":""},{"location":"best-practices/statistical-analysis/#distance-metrics","title":"Distance Metrics","text":"Metric Type Best For Range Bray-Curtis Abundance-based Quantitative data 0-1 Jaccard Presence/absence Binary data 0-1 Weighted UniFrac Phylogenetic + abundance With phylogeny 0-1 Unweighted UniFrac Phylogenetic Presence/absence + phylogeny 0-1 Euclidean Abundance-based Continuous data 0-\u221e <p>Recommendation: Use Bray-Curtis for most virome studies (abundance-based, no phylogeny needed).</p>"},{"location":"best-practices/statistical-analysis/#ordination-methods","title":"Ordination Methods","text":"<p>NMDS (Non-metric Multidimensional Scaling): <pre><code># Most common for ecological data\nnmds &lt;- metaMDS(abundance, distance=\"bray\", k=2, trymax=100)\n\n# Check stress (quality of ordination)\nnmds$stress  # &lt;0.1 excellent, 0.1-0.2 good, &gt;0.2 poor\n\n# Extract scores\nnmds_scores &lt;- as.data.frame(scores(nmds))\nnmds_scores$Sample &lt;- rownames(nmds_scores)\nnmds_scores &lt;- merge(nmds_scores, metadata, by=\"Sample\")\n\n# Plot\nggplot(nmds_scores, aes(x=NMDS1, y=NMDS2, color=Treatment)) +\n  geom_point(size=3) +\n  stat_ellipse() +\n  theme_minimal() +\n  labs(title=paste(\"Stress =\", round(nmds$stress, 3)))\n</code></pre></p> <p>PCoA (Principal Coordinates Analysis): <pre><code># Alternative to NMDS\ndist_matrix &lt;- vegdist(abundance, method=\"bray\")\npcoa &lt;- cmdscale(dist_matrix, k=2, eig=TRUE)\n\n# Variance explained\npcoa$eig[1:2] / sum(pcoa$eig) * 100  # % variance explained by PC1, PC2\n</code></pre></p>"},{"location":"best-practices/statistical-analysis/#testing-group-differences","title":"Testing Group Differences","text":"<p>PERMANOVA (Permutational MANOVA): <pre><code># Test if communities differ between groups\npermanova &lt;- adonis2(abundance ~ Treatment, data=metadata, method=\"bray\", permutations=999)\nprint(permanova)\n\n# Significant if p &lt; 0.05\n# R\u00b2 tells you % variance explained by treatment\n</code></pre></p> <p>Pairwise PERMANOVA: <pre><code>library(pairwiseAdonis)\n\n# All pairwise comparisons\npairwise.adonis(abundance, metadata$Treatment, sim.method=\"bray\", p.adjust.m=\"BH\")\n</code></pre></p> <p>Betadisper (Test homogeneity of dispersion): <pre><code># Check if groups have different dispersions (variance)\n# Important assumption for PERMANOVA\n\ndist_matrix &lt;- vegdist(abundance, method=\"bray\")\ndispersion &lt;- betadisper(dist_matrix, metadata$Treatment)\npermutest(dispersion)\n\n# If significant (p &lt; 0.05), groups have different dispersions\n# PERMANOVA results may be driven by dispersion, not location\n</code></pre></p>"},{"location":"best-practices/statistical-analysis/#differential-abundance-testing","title":"Differential Abundance Testing","text":""},{"location":"best-practices/statistical-analysis/#deseq2-recommended","title":"DESeq2 (Recommended)","text":"<pre><code>library(DESeq2)\n\n# Create DESeq2 object\ndds &lt;- DESeqDataSetFromMatrix(\n  countData = round(abundance),  # Must be integers\n  colData = metadata,\n  design = ~ Treatment\n)\n\n# Filter low-abundance vOTUs (optional but recommended)\nkeep &lt;- rowSums(counts(dds)) &gt;= 10\ndds &lt;- dds[keep,]\n\n# Run DESeq2\ndds &lt;- DESeq(dds)\n\n# Extract results\nresults &lt;- results(dds, contrast=c(\"Treatment\", \"A\", \"B\"))\n\n# Filter significant\nsig &lt;- subset(results, padj &lt; 0.05 &amp; abs(log2FoldChange) &gt; 1)\n\n# How many significant?\nsummary(sig)\n\n# MA plot\nplotMA(results, ylim=c(-5,5))\n\n# Volcano plot\nplot(results$log2FoldChange, -log10(results$padj),\n     xlab=\"Log2 Fold Change\", ylab=\"-Log10 Adjusted P-value\",\n     pch=20, col=ifelse(results$padj &lt; 0.05, \"red\", \"grey\"))\nabline(h=-log10(0.05), lty=2)\nabline(v=c(-1,1), lty=2)\n</code></pre>"},{"location":"best-practices/statistical-analysis/#multiple-testing-correction","title":"Multiple Testing Correction","text":"<p>Always correct for multiple comparisons!</p> <pre><code># Methods (in order of stringency):\n# 1. Bonferroni (most conservative)\np_bonferroni &lt;- p.adjust(pvalues, method=\"bonferroni\")\n\n# 2. Benjamini-Hochberg FDR (recommended)\np_bh &lt;- p.adjust(pvalues, method=\"BH\")\n\n# 3. Benjamini-Yekutieli (for dependent tests)\np_by &lt;- p.adjust(pvalues, method=\"BY\")\n\n# Use adjusted p-values for significance calls\nsig_viruses &lt;- results[p_bh &lt; 0.05, ]\n</code></pre> <p>Choosing significance thresholds: - p &lt; 0.05: Standard (5% false discovery rate) - p &lt; 0.01: More stringent (1% FDR) - p &lt; 0.10: Exploratory (10% FDR, acceptable for pilot studies)</p>"},{"location":"best-practices/statistical-analysis/#time-series-analysis","title":"Time Series Analysis","text":""},{"location":"best-practices/statistical-analysis/#autocorrelation","title":"Autocorrelation","text":"<pre><code># Check for autocorrelation\nacf(abundance_overtime[,\"Virus1\"])\n\n# If autocorrelation present, use time-series aware methods\n</code></pre>"},{"location":"best-practices/statistical-analysis/#trend-detection","title":"Trend Detection","text":"<pre><code># Simple linear regression\nlm_fit &lt;- lm(Abundance ~ Time, data=virus_data)\nsummary(lm_fit)\n\n# Non-linear trends\nlibrary(mgcv)\ngam_fit &lt;- gam(Abundance ~ s(Time), data=virus_data)\nsummary(gam_fit)\n\n# Multiple viruses\nlibrary(DESeq2)\ndds &lt;- DESeqDataSetFromMatrix(counts, colData=metadata, design=~Time)\ndds &lt;- DESeq(dds, test=\"LRT\", reduced=~1)  # Test for time effect\n</code></pre>"},{"location":"best-practices/statistical-analysis/#correlation-analysis","title":"Correlation Analysis","text":""},{"location":"best-practices/statistical-analysis/#phage-host-correlations","title":"Phage-Host Correlations","text":"<pre><code># Spearman correlation (robust to outliers)\ncor.test(phage_abundance, host_abundance, method=\"spearman\")\n\n# Multiple phage-host pairs\ncorrelations &lt;- cor(phage_matrix, host_matrix, method=\"spearman\")\n\n# Significance testing with p-value correction\nlibrary(Hmisc)\ncor_results &lt;- rcorr(phage_matrix, host_matrix, type=\"spearman\")\n\n# Adjust p-values\ncor_results$P_adjusted &lt;- p.adjust(cor_results$P, method=\"BH\")\n</code></pre>"},{"location":"best-practices/statistical-analysis/#network-analysis","title":"Network Analysis","text":"<pre><code>library(igraph)\n\n# Build correlation network\ncor_matrix &lt;- cor(abundance, method=\"spearman\")\n\n# Threshold (only strong correlations)\ncor_matrix[abs(cor_matrix) &lt; 0.6] &lt;- 0\n\n# Create network\nnetwork &lt;- graph_from_adjacency_matrix(cor_matrix, mode=\"undirected\", weighted=TRUE, diag=FALSE)\n\n# Community detection\ncommunities &lt;- cluster_louvain(network)\n\n# Plot\nplot(network, vertex.color=membership(communities))\n</code></pre>"},{"location":"best-practices/statistical-analysis/#effect-sizes","title":"Effect Sizes","text":"<p>Don't just report p-values - report effect sizes!</p> <pre><code># Cohen's d (standardized mean difference)\nlibrary(effsize)\ncohen.d(group_A, group_B)\n\n# Interpretation:\n# |d| &lt; 0.2: negligible\n# 0.2-0.5: small\n# 0.5-0.8: medium\n# &gt;0.8: large\n\n# For PERMANOVA, report R\u00b2 (% variance explained)\n# R\u00b2 &lt; 0.01: negligible\n# 0.01-0.06: small\n# 0.06-0.14: medium\n# &gt;0.14: large\n</code></pre>"},{"location":"best-practices/statistical-analysis/#model-validation","title":"Model Validation","text":""},{"location":"best-practices/statistical-analysis/#cross-validation","title":"Cross-Validation","text":"<pre><code># K-fold cross-validation\nlibrary(caret)\n\n# Split data\nset.seed(123)\nfolds &lt;- createFolds(metadata$Treatment, k=5)\n\n# Train/test for each fold\naccuracies &lt;- sapply(folds, function(test_idx) {\n  train_data &lt;- abundance[-test_idx,]\n  test_data &lt;- abundance[test_idx,]\n\n  # Train model\n  model &lt;- randomForest(train_data, metadata$Treatment[-test_idx])\n\n  # Test\n  predictions &lt;- predict(model, test_data)\n  accuracy &lt;- mean(predictions == metadata$Treatment[test_idx])\n\n  return(accuracy)\n})\n\nmean(accuracies)  # Average cross-validation accuracy\n</code></pre>"},{"location":"best-practices/statistical-analysis/#overfitting-checks","title":"Overfitting Checks","text":"<pre><code># Check if model is too complex\n# Compare training vs validation performance\n\n# Training error should be similar to validation error\n# Large gap indicates overfitting\n</code></pre>"},{"location":"best-practices/statistical-analysis/#reporting-guidelines","title":"Reporting Guidelines","text":""},{"location":"best-practices/statistical-analysis/#minimum-reporting-standards","title":"Minimum Reporting Standards","text":"<p>Always report: 1. Sample size per group 2. Statistical test used and why 3. P-values (adjusted for multiple testing) 4. Effect sizes (fold change, R\u00b2, Cohen's d) 5. Confidence intervals (when applicable) 6. Software versions</p> <p>Example:</p> <p>\"We compared viral diversity between treatments using the Kruskal-Wallis test (n=8 per group), followed by Dunn's post-hoc test with Benjamini-Hochberg correction. Treatment A showed significantly higher Shannon diversity than Treatment B (median 3.8 vs 2.9, p=0.003, BH-corrected, Dunn's test). Analysis was performed in R v4.2 using vegan v2.6.\"</p>"},{"location":"best-practices/statistical-analysis/#visualizations","title":"Visualizations","text":"<p>Required elements: - Error bars (SD, SE, or 95% CI) - Individual data points (when n &lt; 30) - Sample sizes in caption - Statistical significance indicators</p> <pre><code># Good plot example\nggplot(data, aes(x=Treatment, y=Shannon)) +\n  geom_boxplot(outlier.shape=NA) +\n  geom_jitter(width=0.2, alpha=0.5) +\n  stat_compare_means(method=\"kruskal.test\") +\n  labs(y=\"Shannon Diversity\", caption=\"n=8 per group\") +\n  theme_minimal()\n</code></pre>"},{"location":"best-practices/statistical-analysis/#common-statistical-mistakes","title":"Common Statistical Mistakes","text":""},{"location":"best-practices/statistical-analysis/#avoid-these","title":"\u274c Avoid These","text":"<ol> <li>Not correcting for multiple testing</li> <li>Testing 1000 viruses \u2192 expect 50 false positives at p&lt;0.05</li> <li> <p>Solution: Use FDR correction (Benjamini-Hochberg)</p> </li> <li> <p>Pseudoreplication</p> </li> <li>Treating technical replicates as biological</li> <li> <p>Solution: Average technical reps, analyze biological reps</p> </li> <li> <p>p-hacking</p> </li> <li>Testing many hypotheses, reporting only significant ones</li> <li> <p>Solution: Pre-register hypotheses, report all tests</p> </li> <li> <p>Ignoring assumptions</p> </li> <li>Using parametric tests on non-normal data</li> <li> <p>Solution: Check assumptions, use non-parametric tests</p> </li> <li> <p>Confusing correlation with causation</p> </li> <li>High correlation doesn't prove causation</li> <li> <p>Solution: Use causal language carefully</p> </li> <li> <p>Small sample size</p> </li> <li>n=3 per group has low power</li> <li>Solution: Power analysis before study, replicate key findings</li> </ol>"},{"location":"best-practices/statistical-analysis/#best-practices","title":"\u2705 Best Practices","text":"<ol> <li>Pre-specify hypotheses before analysis</li> <li>Use appropriate tests for data type</li> <li>Report effect sizes alongside p-values</li> <li>Visualize data before statistical testing</li> <li>Check assumptions (normality, homoscedasticity)</li> <li>Correct for multiple testing</li> <li>Report negative results (not just significant findings)</li> </ol>"},{"location":"best-practices/statistical-analysis/#further-reading","title":"Further Reading","text":"<ul> <li>McMurdie, P. J., &amp; Holmes, S. (2014). \"Waste not, want not: why rarefying microbiome data is inadmissible.\" PLoS Computational Biology, 10(4), e1003531.</li> <li>Gloor, G. B., et al. (2017). \"Microbiome datasets are compositional.\" Frontiers in Microbiology, 8, 2224.</li> <li>Anderson, M. J. (2001). \"A new method for non-parametric multivariate analysis of variance.\" Austral Ecology, 26(1), 32-46.</li> </ul>"},{"location":"best-practices/tool-combinations/","title":"Tool Combination Best Practices","text":"<p>Last Updated: November 29, 2025</p> <p>Combining multiple tools is essential for accurate virome analysis. This guide provides evidence-based recommendations for which tool combinations work best for different scenarios.</p>"},{"location":"best-practices/tool-combinations/#why-combine-tools","title":"Why Combine Tools?","text":"<p>Single tools have limitations: - False positives: 10-30% for viral identification tools - False negatives: Miss 20-40% of viruses - Method bias: Different algorithms favor different virus types</p> <p>Tool combinations provide: - Higher accuracy (consensus predictions) - Better coverage (union of predictions) - Confidence assessment (number of tools agreeing)</p>"},{"location":"best-practices/tool-combinations/#viral-identification-tool-combinations","title":"Viral Identification Tool Combinations","text":""},{"location":"best-practices/tool-combinations/#recommended-combinations","title":"Recommended Combinations","text":""},{"location":"best-practices/tool-combinations/#gold-standard-high-accuracy-moderate-coverage","title":"Gold Standard (High Accuracy, Moderate Coverage)","text":"<pre><code># VirSorter2 + VIBRANT + geNomad (consensus \u22652)\n# Expected: 60-70% of viruses, &lt;5% false positives\n\n# Run all three tools\nvirsorter run -i contigs.fa --min-score 0.5 -w vs2/ all\nVIBRANT_run.py -i contigs.fa -folder vibrant/\ngenomad end-to-end contigs.fa genomad/ genomad_db/\n\n# Take consensus (\u22652 tools agree)\n# Implementation in Tutorial 1\n</code></pre> <p>Best for: - Publication-quality datasets - Novel virus discovery - Low tolerance for false positives</p> <p>Performance: - Sensitivity: 60-70% - Specificity: &gt;95% - Runtime: 4-8 hours (1000 contigs, 16 cores)</p>"},{"location":"best-practices/tool-combinations/#balanced-good-accuracy-good-coverage","title":"Balanced (Good Accuracy, Good Coverage)","text":"<pre><code># VirSorter2 + geNomad (either tool)\n# Expected: 75-85% of viruses, ~10% false positives\n\nvirsorter run -i contigs.fa --min-score 0.5 -w vs2/ all\ngenomad end-to-end contigs.fa genomad/ genomad_db/\n\n# Union: any tool predicts viral\ncat vs2/final-viral-combined.fa genomad/viral.fna | \\\n    cd-hit-est -c 0.95 -i - -o viral_union.fa\n</code></pre> <p>Best for: - Diversity studies - Exploratory analysis - Moderate sample size (10-50 samples)</p> <p>Performance: - Sensitivity: 75-85% - Specificity: ~90% - Runtime: 2-4 hours (1000 contigs)</p>"},{"location":"best-practices/tool-combinations/#high-sensitivity-maximum-coverage-lower-accuracy","title":"High Sensitivity (Maximum Coverage, Lower Accuracy)","text":"<pre><code># VirSorter2 (low threshold) + VIBRANT + geNomad + DeepVirFinder\n# Expected: &gt;90% of viruses, 15-25% false positives\n\nvirsorter run -i contigs.fa --min-score 0.3 -w vs2/ all\nVIBRANT_run.py -i contigs.fa -folder vibrant/\ngenomad end-to-end contigs.fa genomad/ genomad_db/ --min-score 0.7\npython dvf.py -i contigs.fa -o dvf/ -l 1000\n\n# Union of all predictions\n# MUST use CheckV to filter false positives\n</code></pre> <p>Best for: - Highly novel environments - Pilot studies - When missing viruses is worse than false positives</p> <p>Performance: - Sensitivity: &gt;90% - Specificity: ~75-85% - Requires: CheckV filtering to remove false positives</p>"},{"location":"best-practices/tool-combinations/#tool-specific-considerations","title":"Tool-Specific Considerations","text":"Tool Strengths Weaknesses Best Parameters VirSorter2 Broad virus types, well-tested Slower, some false positives <code>--min-score 0.5-0.7</code> VIBRANT Good for phages, built-in annotation Misses some virus types Default settings geNomad Fast, recent database, plasmid detection Newer (less validated) <code>--min-score 0.8</code> DeepVirFinder Works on short contigs Needs GPU for speed, higher FP <code>--len 1000</code> minimum"},{"location":"best-practices/tool-combinations/#quality-filtering-after-prediction","title":"Quality Filtering After Prediction","text":"<p>Always run CheckV: <pre><code># After any viral identification\ncheckv end_to_end viral_contigs.fa checkv_out/ -t 8\n\n# Recommended filters:\n# Conservative: Complete + High-quality only\nawk -F'\\t' '$8 == \"Complete\" || $8 == \"High-quality\" {print $1}' \\\n    checkv_out/quality_summary.tsv &gt; hq_ids.txt\n\n# Balanced: Complete + High + Medium\nawk -F'\\t' '$8 != \"Low-quality\" &amp;&amp; $8 != \"Not-determined\" {print $1}' \\\n    checkv_out/quality_summary.tsv &gt; good_ids.txt\n\n# Also filter by contamination\nawk -F'\\t' '$8 != \"Low-quality\" &amp;&amp; $10 &lt; 5 {print $1}' \\\n    checkv_out/quality_summary.tsv &gt; clean_ids.txt\n</code></pre></p>"},{"location":"best-practices/tool-combinations/#host-prediction-tool-combinations","title":"Host Prediction Tool Combinations","text":""},{"location":"best-practices/tool-combinations/#tiered-approach-recommended","title":"Tiered Approach (Recommended)","text":"<pre><code># Tier 1: CRISPR spacers (highest confidence, ~5-10% of phages)\n# Use PILER-CR or minced + BLAST\n\n# Tier 2: iPHoP integrated prediction (~40-60% of phages)\niphop predict --fa_file phages.fa --db_dir iphop_db/ --out_dir iphop/\n\n# Tier 3: Individual methods for remaining phages\n# - WIsH (genomic signatures)\n# - CHERRY (deep learning)\n# - Protein homology (BLAST)\n\n# Combine with confidence weighting:\n# - CRISPR match: 95% confidence\n# - iPHoP + CRISPR: 90% confidence\n# - iPHoP &gt;90 score: 70% confidence\n# - \u22652 methods agree: 60% confidence\n# - Single method: 30% confidence\n</code></pre> <p>Implementation: <pre><code>def assign_host_confidence(predictions):\n    \"\"\"Assign confidence based on prediction method(s)\"\"\"\n    confidence_map = {\n        'CRISPR': 0.95,\n        'iPHoP_high': 0.70,  # iPHoP score &gt;90\n        'iPHoP_medium': 0.50,  # iPHoP score 70-90\n        'WIsH': 0.40,\n        'CHERRY': 0.40,\n        'Homology': 0.45,\n        'Consensus_2': 0.60,  # \u22652 methods agree\n        'Consensus_3': 0.75,  # \u22653 methods agree\n    }\n\n    # Logic to determine confidence\n    if 'CRISPR' in predictions['methods']:\n        return confidence_map['CRISPR']\n    elif len(predictions['methods']) &gt;= 3:\n        return confidence_map['Consensus_3']\n    elif len(predictions['methods']) &gt;= 2:\n        return confidence_map['Consensus_2']\n    # ... etc\n</code></pre></p>"},{"location":"best-practices/tool-combinations/#when-to-use-each-host-prediction-tool","title":"When to Use Each Host Prediction Tool","text":"Tool Use When Avoid When Typical Success Rate CRISPR Bacterial MAGs available Limited bacterial data 5-10% (very high confidence) iPHoP Any phages Time/resource limited 40-60% (medium-high confidence) WIsH Bacterial genomes available Only viral databases 30-50% (medium confidence) CHERRY Any phages, especially novel Need genus-level precision 35-55% (medium confidence) VirHostMatcher Related hosts in database Completely novel phages 25-45% (low-medium confidence)"},{"location":"best-practices/tool-combinations/#assembly-tool-combinations","title":"Assembly Tool Combinations","text":""},{"location":"best-practices/tool-combinations/#single-assembly-vs-co-assembly-vs-hybrid","title":"Single Assembly vs Co-Assembly vs Hybrid","text":"<p>Scenario 1: Few Samples (1-5) <pre><code># Use individual assemblies per sample\nfor sample in sample1 sample2 sample3; do\n    metaspades.py --metaviral \\\n        -1 ${sample}_R1.fq -2 ${sample}_R2.fq \\\n        -o assembly/${sample}\ndone\n\n# Dereplicate across samples\ncat assembly/*/contigs.fasta | \\\n    cd-hit-est -c 0.95 -aS 0.85 -o derep_contigs.fa\n</code></pre></p> <p>Scenario 2: Many Similar Samples (10-50) <pre><code># Co-assemble all samples together\ncat sample*_R1.fq.gz &gt; all_R1.fq.gz\ncat sample*_R2.fq.gz &gt; all_R2.fq.gz\n\nmetaspades.py --metaviral \\\n    -1 all_R1.fq.gz -2 all_R2.fq.gz \\\n    -o co_assembly/ -t 32 -m 250\n\n# Better for shared viruses, misses rare sample-specific viruses\n</code></pre></p> <p>Scenario 3: Complex Design (Recommended for Most Studies) <pre><code># Hybrid approach:\n# 1. Co-assemble within groups (timepoints, treatments, etc.)\n# 2. Individual assemblies for each sample\n# 3. Combine and dereplicate\n\n# Co-assembly per timepoint\nmetaspades.py --metaviral -1 T1_all_R1.fq -2 T1_all_R2.fq -o T1_coasm/\nmetaspades.py --metaviral -1 T2_all_R1.fq -2 T2_all_R2.fq -o T2_coasm/\n\n# Individual assemblies\nfor sample in T1_R1 T1_R2 T2_R1 T2_R2; do\n    metaspades.py --metaviral -1 ${sample}_R1.fq -2 ${sample}_R2.fq -o ${sample}_asm/\ndone\n\n# Combine and dereplicate\ncat *_coasm/contigs.fasta *_asm/contigs.fasta | \\\n    cd-hit-est -c 0.95 -aS 0.85 -M 64000 -T 16 -o final_derep.fa\n</code></pre></p>"},{"location":"best-practices/tool-combinations/#annotation-tool-combinations","title":"Annotation Tool Combinations","text":""},{"location":"best-practices/tool-combinations/#phage-annotation-pipeline","title":"Phage Annotation Pipeline","text":"<pre><code># Step 1: Pharokka (fast, phage-specific)\npharokka.py -i phages.fa -o pharokka/ -t 8 -d pharokka_db/\n\n# Step 2: DRAMv (metabolic annotation)\nDRAM-v.py annotate -i phages.fa -o dramv/ --threads 8\nDRAM-v.py distill -i dramv/annotations.tsv -o dramv_distill/\n\n# Step 3: PHROGs (for additional functional annotation)\nhmmsearch --tblout phrogs_hits.txt -E 1e-5 --cpu 8 \\\n    PHROGs.hmm pharokka/proteins.faa\n\n# Combine annotations (take best from each tool)\npython3 combine_annotations.py \\\n    --pharokka pharokka/*.gff \\\n    --dramv dramv/annotations.tsv \\\n    --phrogs phrogs_hits.txt \\\n    --output combined_annotations.tsv\n</code></pre> <p>When to use each: - Pharokka: Primary phage annotation (fast, comprehensive) - DRAMv: Auxiliary metabolic genes (AMGs), metabolic pathways - PHROGs: Additional functional categories - PROKKA: If Pharokka fails (less phage-specific)</p>"},{"location":"best-practices/tool-combinations/#taxonomic-classification-combinations","title":"Taxonomic Classification Combinations","text":""},{"location":"best-practices/tool-combinations/#multi-method-taxonomy","title":"Multi-Method Taxonomy","text":"<pre><code># Method 1: BLAST (sequence similarity)\nblastn -query viral.fa -db nt -outfmt 6 -max_target_seqs 5 &gt; blast.txt\n\n# Method 2: vConTACT2 (protein sharing network)\nvcontact2 --raw-proteins proteins.faa --db ProkaryoticViralRefSeq --output vcontact2/\n\n# Method 3: PhaGCN (graph convolutional network)\npython PhaTYP.py --contigs viral.fa --threads 8\n\n# Combine:\n# - BLAST for known viruses (&gt;80% identity)\n# - vConTACT2 for viral clusters (species-level)\n# - PhaGCN for novel viruses (family-level)\n</code></pre> <p>Decision tree: <pre><code>For each virus:\n\u251c\u2500 BLAST identity &gt;90%? \u2192 Use BLAST taxonomy (high confidence)\n\u251c\u2500 BLAST identity 70-90%? \u2192 Use BLAST family + vConTACT2 genus (medium confidence)\n\u251c\u2500 vConTACT2 cluster with references? \u2192 Use cluster taxonomy (medium confidence)\n\u2514\u2500 No hits? \u2192 Use PhaGCN family prediction (low confidence) + mark as novel\n</code></pre></p>"},{"location":"best-practices/tool-combinations/#abundance-estimation-combinations","title":"Abundance Estimation Combinations","text":""},{"location":"best-practices/tool-combinations/#read-mapping-strategy","title":"Read Mapping Strategy","text":"<pre><code># Method 1: BBMap (sensitive, slower)\nbbmap.sh in=reads.fq ref=viral.fa out=bbmap.sam covstats=bbmap_cov.txt\n\n# Method 2: Bowtie2 (fast, standard)\nbowtie2-build viral.fa viral_idx\nbowtie2 -x viral_idx -1 R1.fq -2 R2.fq -S bowtie2.sam\n\n# Method 3: CoverM (batch processing, multiple metrics)\ncoverm contig --coupled *_R1.fq *_R2.fq --reference viral.fa \\\n    --methods mean trimmed_mean covered_fraction variance \\\n    --output-file coverm_abundance.tsv\n\n# Recommendation: Use CoverM for multi-sample studies\n</code></pre> <p>Coverage metrics comparison:</p> Metric Robust to Outliers Good for Low Coverage Best Use Mean No Yes Even coverage, high depth Trimmed Mean Yes Yes Recommended for most cases Median Yes No Very uneven coverage RPKM No No Cross-sample comparison Covered Fraction N/A Yes Presence/absence"},{"location":"best-practices/tool-combinations/#statistical-analysis-combinations","title":"Statistical Analysis Combinations","text":""},{"location":"best-practices/tool-combinations/#diversity-analysis","title":"Diversity Analysis","text":"<pre><code># R script combining multiple diversity metrics\n</code></pre> <pre><code>library(vegan)\nlibrary(phyloseq)\n\n# Alpha diversity (within-sample)\nrichness &lt;- specnumber(abundance)  # Species richness\nshannon &lt;- diversity(abundance, index=\"shannon\")  # Shannon\nsimpson &lt;- diversity(abundance, index=\"simpson\")  # Simpson\n\n# Beta diversity (between-sample)\nbray &lt;- vegdist(abundance, method=\"bray\")  # Bray-Curtis\njaccard &lt;- vegdist(abundance, method=\"jaccard\", binary=TRUE)  # Jaccard\n\n# Ordination\nnmds_bray &lt;- metaMDS(abundance, distance=\"bray\", k=2)\npca &lt;- rda(abundance)\n\n# Statistical tests\n# PERMANOVA for group differences\nadonis2(abundance ~ Treatment, data=metadata, method=\"bray\")\n\n# ANOSIM (alternative)\nanosim(abundance, metadata$Treatment, method=\"bray\")\n\n# Recommendation: Use PERMANOVA (more powerful)\n</code></pre>"},{"location":"best-practices/tool-combinations/#differential-abundance","title":"Differential Abundance","text":"<pre><code># Use DESeq2 for count data (recommended)\n# Use ANCOM for compositional data (alternative)\n</code></pre> <pre><code>library(DESeq2)\nlibrary(ALDEx2)\n\n# Method 1: DESeq2 (recommended for most cases)\ndds &lt;- DESeqDataSetFromMatrix(\n    countData = counts,\n    colData = metadata,\n    design = ~ Treatment\n)\ndds &lt;- DESeq(dds)\nresults &lt;- results(dds, contrast=c(\"Treatment\", \"A\", \"B\"))\n\n# Method 2: ALDEx2 (for compositional data)\naldex_result &lt;- aldex(counts, metadata$Treatment, mc.samples=128)\n\n# Recommendation:\n# - DESeq2 for most virome studies\n# - ALDEx2 if concerned about compositionality\n# - Validate with both if results differ substantially\n</code></pre>"},{"location":"best-practices/tool-combinations/#workflow-integration-examples","title":"Workflow Integration Examples","text":""},{"location":"best-practices/tool-combinations/#complete-virome-workflow-recommended-stack","title":"Complete Virome Workflow (Recommended Stack)","text":"<pre><code>#!/bin/bash\n# Complete virome analysis combining best practices\n\n# 1. QC\nfastp -i R1.fq.gz -I R2.fq.gz -o clean_R1.fq -O clean_R2.fq\n\n# 2. Assembly (hybrid approach)\nmetaspades.py --metaviral -1 clean_R1.fq -2 clean_R2.fq -o assembly/\n\n# 3. Viral ID (consensus of 3 tools)\nvirsorter run -i assembly/contigs.fa --min-score 0.5 -w vs2/ all\nVIBRANT_run.py -i assembly/contigs.fa -folder vibrant/\ngenomad end-to-end assembly/contigs.fa genomad/ genomad_db/\n\n# Consensus\npython3 consensus_viral_prediction.py \\\n    --vs2 vs2/final-viral-combined.fa \\\n    --vibrant vibrant/phages.fa \\\n    --genomad genomad/viral.fna \\\n    --min-tools 2 \\\n    --output consensus_viral.fa\n\n# 4. Quality check\ncheckv end_to_end consensus_viral.fa checkv/ -t 8\n\n# 5. Annotation\npharokka.py -i checkv/viruses.fna -o pharokka/ -t 8\nDRAM-v.py annotate -i checkv/viruses.fna -o dramv/ --threads 8\n\n# 6. Taxonomy\nblastn -query checkv/viruses.fna -db nt -outfmt 6 &gt; blast_tax.txt\nvcontact2 --raw-proteins pharokka/proteins.faa --output vcontact2/\n\n# 7. Abundance\ncoverm contig --coupled clean_R*.fq --reference checkv/viruses.fna \\\n    --methods trimmed_mean --output-file abundance.tsv\n\n# 8. Host prediction\niphop predict --fa_file checkv/viruses.fna --db_dir iphop_db/ --out_dir iphop/\n</code></pre>"},{"location":"best-practices/tool-combinations/#tool-compatibility-matrix","title":"Tool Compatibility Matrix","text":"Upstream Tool Compatible Downstream Tools Notes metaviralSPAdes VirSorter2, VIBRANT, geNomad All viral ID tools VirSorter2 CheckV, Pharokka, DRAMv Standard workflow VIBRANT CheckV, DRAMv Built-in annotation CheckV Pharokka, DRAMv, vConTACT2 Use <code>viruses.fna</code> output Pharokka vConTACT2, DRAMv Use protein FAA DRAMv Custom scripts Metabolic analysis"},{"location":"best-practices/tool-combinations/#common-pitfalls-in-tool-combinations","title":"Common Pitfalls in Tool Combinations","text":""},{"location":"best-practices/tool-combinations/#anti-patterns-avoid-these","title":"\u274c Anti-Patterns (Avoid These)","text":"<ol> <li>Using only one viral ID tool</li> <li>False positive rate too high (10-30%)</li> <li> <p>Solution: Always use \u22652 tools</p> </li> <li> <p>Not running CheckV after viral ID</p> </li> <li>Can't assess quality or remove contamination</li> <li> <p>Solution: Always run CheckV</p> </li> <li> <p>Over-relying on machine learning tools</p> </li> <li>Need validation with sequence-based methods</li> <li> <p>Solution: Combine ML with BLAST/CRISPR</p> </li> <li> <p>Ignoring tool version differences</p> </li> <li>Databases and algorithms change</li> <li> <p>Solution: Record versions, use same version within study</p> </li> <li> <p>Combining incompatible tools</p> </li> <li>E.g., using DNA assembler for RNA viruses</li> <li>Solution: Check tool documentation</li> </ol>"},{"location":"best-practices/tool-combinations/#best-practices","title":"\u2705 Best Practices","text":"<ol> <li>Consensus predictions (\u22652 tools agree)</li> <li>CheckV filtering (remove low quality)</li> <li>Multiple evidence types (CRISPR + homology + ML)</li> <li>Version control (document all tool versions)</li> <li>Appropriate thresholds (adjust for your goals)</li> </ol>"},{"location":"best-practices/tool-combinations/#computational-resource-considerations","title":"Computational Resource Considerations","text":"Tool Combination RAM CPUs Runtime (1000 contigs) VirSorter2 + geNomad 32GB 16 2-3 hours VirSorter2 + VIBRANT + geNomad 64GB 16 4-6 hours Full stack (assembly + ID + annotation) 128GB 32 12-24 hours <p>Optimization tips: - Run tools in parallel when possible - Use high-memory nodes for assembly - Cache databases (don't re-download)</p>"},{"location":"best-practices/tool-combinations/#further-reading","title":"Further Reading","text":"<ul> <li>Roux, S., et al. (2019). \"Minimum Information about an Uncultivated Virus Genome (MIUViG).\" Nature Biotechnology.</li> <li>Camargo, A. P., et al. (2023). \"Identification of mobile genetic elements with geNomad.\" Nature Biotechnology.</li> <li>Guo, J., et al. (2021). \"VirSorter2: a multi-classifier, expert-guided approach.\" Microbiome.</li> </ul>"},{"location":"best-practices/validation/","title":"Validation Best Practices","text":"<p>Last Updated: November 29, 2025</p> <p>Computational predictions in virome analysis require validation. This guide covers strategies for validating viral identifications, host predictions, and functional annotations.</p>"},{"location":"best-practices/validation/#why-validation-matters","title":"Why Validation Matters","text":"<p>Computational predictions have limitations: - Viral identification: 10-30% false positives - Host prediction: 30-60% accuracy for novel phages - Functional annotation: 40-70% hypothetical proteins</p> <p>Validation provides: - Confidence in results - Publishable claims - Biological insights - Method benchmarking</p>"},{"location":"best-practices/validation/#viral-identification-validation","title":"Viral Identification Validation","text":""},{"location":"best-practices/validation/#in-silico-validation","title":"In Silico Validation","text":"<p>1. CheckV Quality Assessment <pre><code># Essential first step\ncheckv end_to_end viral_contigs.fa checkv_out/ -t 8\n\n# Red flags (likely false positives):\n# - High contamination (&gt;10%)\n# - Very low completeness (&lt;10%)\n# - No viral genes identified\n# - Contamination warning in provirus column\n\n# Filter false positives\nawk -F'\\t' '$8 != \"Not-determined\" &amp;&amp; $10 &lt; 5 {print $1}' \\\n    checkv_out/quality_summary.tsv &gt; validated_ids.txt\n</code></pre></p> <p>2. Gene Content Analysis <pre><code># Check for viral hallmark genes\n# Expected in most DNA viruses:\n# - Terminase, portal protein, major capsid protein\n\n# Search for hallmark genes\nhmmsearch --tblout hallmark_hits.txt viral_hallmark_hmms.hmm proteins.faa\n\n# Contigs with \u22651 hallmark gene = higher confidence\n</code></pre></p> <p>3. Manual Inspection <pre><code># For key findings, manually inspect:\n# - Gene synteny (organization)\n# - Protein homology\n# - Genomic context\n\n# View in Artemis or GenBank\nartemis contig.gbk\n</code></pre></p>"},{"location":"best-practices/validation/#experimental-validation","title":"Experimental Validation","text":"<p>1. PCR Confirmation <pre><code># Design primers flanking predicted viral region\n# Positive PCR = virus present in sample\n\n# qPCR for quantification\nqpcr_primers viral_gene.fa\n\n# Expected: Amplicon if virus is real, no amplicon if false positive\n</code></pre></p> <p>2. Plaque Assays (Cultivable Phages) <pre><code># Gold standard for phages\n# 1. Isolate phage from environmental sample\n# 2. Purify plaques\n# 3. Sequence isolate\n# 4. Compare to predicted sequence\n\n# Match? \u2192 Validated!\n# No match? \u2192 Prediction may be wrong or virus is uncultivable\n</code></pre></p> <p>3. Viral Metagenomics Comparison <pre><code># Compare VLP-enriched vs total metagenome\n# True viruses should be:\n# - Enriched in VLP fraction (10-100x)\n# - Depleted in non-VLP fraction\n\n# Calculate enrichment\ncoverage_VLP / coverage_total &gt; 10  # Likely viral\n</code></pre></p>"},{"location":"best-practices/validation/#host-prediction-validation","title":"Host Prediction Validation","text":""},{"location":"best-practices/validation/#computational-validation","title":"Computational Validation","text":"<p>1. Taxonomic Consistency <pre><code># Check if predictions are taxonomically reasonable\n# E.g., marine phage predicted to infect human gut bacteria = suspicious\n\ndef check_taxonomic_consistency(phage_env, host_env):\n    \"\"\"Check if phage and host environments match\"\"\"\n    compatible = {\n        'marine': ['marine', 'ocean', 'seawater'],\n        'gut': ['gut', 'fecal', 'intestinal'],\n        'soil': ['soil', 'terrestrial', 'sediment']\n    }\n\n    for env_type, keywords in compatible.items():\n        if any(k in phage_env for k in keywords):\n            if any(k in host_env for k in keywords):\n                return True\n    return False\n</code></pre></p> <p>2. Prophage Analysis <pre><code># If predicted host genome available, check for integrated prophages\n\n# Search for prophage in host genome\nphispy predicted_host_genome.fa -o prophage_check/\n\n# If phage sequence found integrated \u2192 Strong validation!\n</code></pre></p> <p>3. CRISPR Validation <pre><code># Gold standard: CRISPR spacer match\n# Indicates phage-host encounter\n\nblast spacer vs phage_genome\n# &gt;95% identity, &lt;2 mismatches = high confidence\n</code></pre></p>"},{"location":"best-practices/validation/#experimental-validation_1","title":"Experimental Validation","text":"<p>1. Infection Assays <pre><code># Culture-based (if phage and host are cultivable)\n# 1. Grow predicted host\n# 2. Add phage lysate\n# 3. Monitor for lysis or plaques\n\n# Lysis/plaques \u2192 Validated host!\n# No lysis \u2192 Either wrong prediction or resistance\n</code></pre></p> <p>2. qPCR Co-occurrence <pre><code># Quantify phage and predicted host across samples\n# Strong positive correlation suggests interaction\n\n# Calculate Spearman correlation\ncorrelation(phage_abundance, host_abundance)\n# \u03c1 &gt; 0.6, p &lt; 0.05 \u2192 Supporting evidence\n</code></pre></p> <p>3. Hi-C Proximity Ligation <pre><code># Detects physical proximity of phage-host DNA\n# Indicates active infection\n\n# Hi-C reads linking phage to host = strong validation\n# Requires specialized sequencing\n</code></pre></p> <p>4. Single-Cell Genomics <pre><code># Sequence single infected cells\n# Phage + host DNA in same cell = validation\n\n# Use flow cytometry to sort infected cells\n# Sequence with MDA or similar\n</code></pre></p>"},{"location":"best-practices/validation/#functional-annotation-validation","title":"Functional Annotation Validation","text":""},{"location":"best-practices/validation/#in-silico-validation_1","title":"In Silico Validation","text":"<p>1. Domain Architecture <pre><code># Check if protein domains are consistent with function\n# E.g., \"DNA polymerase\" should have polymerase domains\n\n# Run InterProScan\ninterproscan.sh -i protein.faa -f tsv -o domains.tsv\n\n# Check consistency\n# Predicted: Terminase\n# Domains: Terminase_ATPase, Terminase_nuclease\n# \u2192 Consistent, validated!\n</code></pre></p> <p>2. Phylogenetic Placement <pre><code># Place protein in phylogenetic tree with known proteins\n# Should cluster with proteins of similar function\n\n# Build tree\nmafft --auto protein_with_refs.faa &gt; aligned.faa\niqtree -s aligned.faa -m TEST -bb 1000\n\n# Check: Does it cluster with annotated terminases?\n# Yes \u2192 Validated\n# No \u2192 Annotation may be wrong\n</code></pre></p> <p>3. Structure Prediction <pre><code># Use AlphaFold to predict structure\n# Compare to known structures\n\nalphafold --fasta protein.faa --output alphafold_out/\n\n# Compare to PDB\n# Similar structure to known terminase? \u2192 Validated\n</code></pre></p>"},{"location":"best-practices/validation/#experimental-validation_2","title":"Experimental Validation","text":"<p>1. Heterologous Expression <pre><code># Clone gene into expression vector\n# Express in E. coli\n# Test predicted activity\n\n# E.g., if predicted as \"endolysin\":\n# - Express protein\n# - Test lytic activity on bacterial cells\n# - Activity \u2192 Validated!\n</code></pre></p> <p>2. Deletion/Mutation Studies <pre><code># Delete or mutate predicted essential gene\n# Phenotype should match prediction\n\n# E.g., delete predicted \"portal protein\"\n# Expected: Non-functional phage\n# Observed: Non-functional phage \u2192 Validated!\n</code></pre></p>"},{"location":"best-practices/validation/#abundance-estimate-validation","title":"Abundance Estimate Validation","text":""},{"location":"best-practices/validation/#technical-replicates","title":"Technical Replicates","text":"<pre><code># Sequence same sample multiple times\n# Abundance should be highly correlated\n\n# Expected correlation: r &gt; 0.95\n# Lower correlation indicates technical noise\n</code></pre>"},{"location":"best-practices/validation/#spike-in-controls","title":"Spike-In Controls","text":"<pre><code># Add known amount of control virus to sample\n# Quantify after sequencing\n\nobserved_abundance / expected_abundance \u2248 1\n# Deviations indicate bias or error\n</code></pre>"},{"location":"best-practices/validation/#qpcr-validation","title":"qPCR Validation","text":"<pre><code># Absolute quantification via qPCR\n# Compare to sequencing-based abundance\n\n# Should be correlated (not necessarily 1:1)\n# Correlation r &gt; 0.7 = reasonable agreement\n</code></pre>"},{"location":"best-practices/validation/#validation-confidence-levels","title":"Validation Confidence Levels","text":"Evidence Type Confidence Level Suitable For CRISPR spacer match Very High (90-95%) Host prediction Plaque assay + sequencing Very High (95%+) Viral ID, host Hi-C proximity High (80-90%) Host prediction CheckV Complete + hallmark genes High (85-90%) Viral ID qPCR confirmation Medium-High (75-85%) Abundance, presence Taxonomic consistency Medium (60-70%) Host prediction Multiple tools agree Medium (65-75%) Viral ID Single prediction method Low (30-50%) Exploratory only"},{"location":"best-practices/validation/#when-to-validate","title":"When to Validate","text":"<p>Always validate: - Novel virus claims (new species/family) - Key biological findings (e.g., \"this phage controls bloom\") - Host predictions used for downstream analysis - Functional claims about gene products - Unexpected or controversial results</p> <p>Can skip validation: - Exploratory/pilot studies (but acknowledge limitation) - When using multiple high-quality methods (e.g., CRISPR + homology) - Well-established results (e.g., T4-like phage identified)</p>"},{"location":"best-practices/validation/#validation-checklist","title":"Validation Checklist","text":"<p>Before submitting for publication:</p> <ul> <li>[ ] Viral predictions validated with CheckV + manual inspection</li> <li>[ ] Key viruses checked for hallmark genes</li> <li>[ ] Negative controls show &lt;1% of sample reads</li> <li>[ ] Host predictions have \u22652 lines of evidence for key findings</li> <li>[ ] Functional annotations consistent with domain architecture</li> <li>[ ] Abundance estimates correlated with technical replicates (if available)</li> <li>[ ] Unexpected findings validated experimentally or noted as predictions</li> <li>[ ] Limitations acknowledged in text</li> </ul>"},{"location":"best-practices/validation/#reporting-validation","title":"Reporting Validation","text":"<p>Good example:</p> <p>\"We identified 234 viral contigs using a consensus of VirSorter2, VIBRANT, and geNomad (\u22652 tools agreeing). Quality assessment with CheckV identified 89 high-quality viral genomes (&gt;50% complete, &lt;5% contamination). We validated the presence of 10 randomly selected viruses via PCR (9/10 positive, Supplementary Fig. 3). Host predictions were based on CRISPR spacer matches (n=12, high confidence) or iPHoP consensus predictions with &gt;90 confidence score (n=45, medium confidence).\"</p> <p>Bad example:</p> <p>\"We found 234 viruses. Host predictions were made with iPHoP.\" (No validation, no quality assessment, no confidence levels)</p>"},{"location":"best-practices/validation/#further-reading","title":"Further Reading","text":"<ul> <li>Roux, S., et al. (2019). \"Minimum information about an uncultivated virus genome (MIUViG).\" Nature Biotechnology.</li> <li>Dutilh, B. E., et al. (2014). \"A highly abundant bacteriophage discovered in the unknown sequences of human faecal metagenomes.\" Nature Communications.</li> </ul>"},{"location":"contributing/guidelines/","title":"Contributing to Awesome-Virome","text":"<p>Thank you for considering contributing to Awesome-Virome! This document provides guidelines and instructions for contributing to this curated list of virome analysis tools.</p>"},{"location":"contributing/guidelines/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are several ways to contribute to Awesome-Virome:</p> <ol> <li>Add New Tools: Submit entries for tools not yet included in the list</li> <li>Update Information: Help keep tool descriptions and links up to date</li> <li>Report Issues: Let us know about broken links or outdated information</li> <li>Improve Documentation: Suggest enhancements to the documentation</li> <li>Fix Bugs: Help resolve issues with the website or dashboard</li> </ol>"},{"location":"contributing/guidelines/#contribution-process","title":"Contribution Process","text":""},{"location":"contributing/guidelines/#option-1-submit-an-issue","title":"Option 1: Submit an Issue","text":"<p>The easiest way to contribute is by submitting an issue:</p> <ol> <li>Go to the Issues page and click \"New Issue\"</li> <li>Select the appropriate template:</li> <li>Tool Addition: For suggesting new tools</li> <li>Tool Update: For updating existing tool information</li> <li>Bug Report: For reporting issues with the repository</li> <li>Feature Request: For suggesting new features</li> <li>Fill out all required fields</li> <li>Submit the issue</li> </ol> <p>Our team will review your submission and incorporate valid contributions.</p>"},{"location":"contributing/guidelines/#option-2-submit-a-pull-request","title":"Option 2: Submit a Pull Request","text":"<p>For more direct contributions:</p> <ol> <li>Fork the repository</li> <li>Create a new branch for your addition (<code>git checkout -b add-new-tool</code>)</li> <li>Make your changes</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/guidelines/#guidelines-for-tool-entries","title":"Guidelines for Tool Entries","text":"<p>Each tool entry should follow this format:</p> <pre><code>- [Tool Name](link-to-tool) - Brief description of the tool. [package-manager] [language]\n</code></pre> <p>Where: - Tool Name: The name of the software, tool, or database - link-to-tool: A URL to the tool's website, GitHub repository, or paper - Brief description: Explains what the tool does in 1-2 sentences - package-manager: Indicates how the tool can be installed (conda, pip, etc.) - language: Indicates the programming language used (optional)</p> <p>Example:</p> <pre><code>- [ViralMSA](https://github.com/niemasd/ViralMSA) - Python script for viral multiple sequence alignment using read mappers. [source] [Python]\n</code></pre>"},{"location":"contributing/guidelines/#detailed-requirements","title":"Detailed Requirements","text":""},{"location":"contributing/guidelines/#required-information","title":"Required Information","text":"<p>Every tool submission must include:</p> <ol> <li>Tool Name: The official name of the tool</li> <li>URL: A link to the tool's repository, website, or publication</li> <li>Description: A clear, concise description of what the tool does</li> <li>Category: The appropriate category for the tool</li> </ol>"},{"location":"contributing/guidelines/#optional-but-recommended","title":"Optional But Recommended","text":"<p>For higher quality entries, include:</p> <ol> <li>Version Information: The latest release version, if available</li> <li>Installation Method: How to install the tool (conda, pip, docker, etc.)</li> <li>Programming Language: The primary language the tool is written in</li> <li>License Information: The license under which the tool is distributed</li> <li>Citation Information: DOI or publication reference</li> <li>GitHub Stars: For GitHub repositories (automatically collected)</li> <li>Maintenance Status: Whether the tool is actively maintained</li> </ol>"},{"location":"contributing/guidelines/#quality-requirements","title":"Quality Requirements","text":"<p>Your submission will be evaluated against these key criteria:</p> <ol> <li>Relevance: The tool must be relevant to virome analysis</li> <li>Accessibility: The URL must be accessible and correct</li> <li>Clarity: The description must be clear and informative</li> <li>Categorization: The tool must be placed in the correct category</li> </ol>"},{"location":"contributing/guidelines/#automated-validation","title":"Automated Validation","text":"<p>All submissions undergo automated validation:</p> <ol> <li>URLs are checked for accessibility</li> <li>Descriptions are analyzed for clarity and relevance</li> <li>Submissions are checked for duplicates</li> <li>DOIs and citations are validated when provided</li> </ol> <p>A quality score (0-100) is assigned based on these checks. Submissions scoring below 70 require improvements before acceptance.</p>"},{"location":"contributing/guidelines/#enhanced-metadata-collection","title":"Enhanced Metadata Collection","text":"<p>For tools hosted on GitHub, GitLab, or Bitbucket, we automatically collect:</p> <ul> <li>Repository statistics (stars, forks, open issues)</li> <li>License information</li> <li>Programming languages</li> <li>Repository topics/tags</li> <li>Release information</li> <li>Creation and update dates</li> </ul> <p>This metadata is updated weekly/monthly and used in our visualizations.</p>"},{"location":"contributing/guidelines/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct:</p> <ul> <li>Be respectful and inclusive</li> <li>Focus on the technical merits of submissions</li> <li>Provide constructive feedback</li> <li>Maintain a positive and helpful environment</li> </ul>"},{"location":"contributing/guidelines/#attribution","title":"Attribution","text":"<p>We appreciate all contributions to Awesome-Virome. Contributors are recognized in the following ways:</p> <ul> <li>Listed in the Contributors section of the repository</li> <li>Acknowledged in release notes for significant contributions</li> <li>Credited in the changelog</li> </ul>"},{"location":"contributing/guidelines/#questions","title":"Questions?","text":"<p>If you have questions about contributing, please:</p> <ol> <li>Check the FAQ</li> <li>Ask in GitHub Discussions</li> <li>Open an issue labeled \"question\"</li> </ol> <p>Thank you for your contributions to the virome analysis community!</p>"},{"location":"contributing/updating-docs/","title":"Updating Documentation","text":"<p>This guide explains how to update the Awesome-Virome documentation.</p>"},{"location":"contributing/updating-docs/#prerequisites","title":"Prerequisites","text":"<ol> <li>Python 3.7+ installed</li> <li>Git installed</li> <li>Clone of the repository</li> </ol>"},{"location":"contributing/updating-docs/#setting-up-the-environment","title":"Setting Up the Environment","text":"<pre><code># Navigate to the mkdocs directory\ncd mkdocs\n\n# Create a virtual environment\npython -m venv venv\n\n# Activate the virtual environment\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n</code></pre>"},{"location":"contributing/updating-docs/#making-documentation-changes","title":"Making Documentation Changes","text":"<ol> <li>Edit Markdown files in the <code>docs/</code> directory</li> <li>Add new files as needed (remember to update navigation in <code>mkdocs.yml</code>)</li> <li>Test your changes locally:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>View your changes at http://127.0.0.1:8000/</li> </ol>"},{"location":"contributing/updating-docs/#creating-new-versions","title":"Creating New Versions","text":"<p>We use mike for versioning:</p> <pre><code># Deploy a new version (e.g., 1.1.0)\nmike deploy 1.1.0\n\n# Update the 'latest' alias\nmike alias 1.1.0 latest\n\n# Set the default version\nmike set-default 1.1.0\n</code></pre>"},{"location":"contributing/updating-docs/#submitting-changes","title":"Submitting Changes","text":"<ol> <li>Commit your changes:</li> </ol> <pre><code>git add .\ngit commit -m \"Update documentation: [brief description]\"\n</code></pre> <ol> <li>Push to your fork:</li> </ol> <pre><code>git push origin your-branch-name\n</code></pre> <ol> <li>Create a pull request</li> </ol>"},{"location":"contributing/updating-docs/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>docs/index.md</code> - Home page</li> <li><code>docs/intro/</code> - Introduction and getting started </li> <li><code>docs/tools/</code> - Tool documentation</li> <li><code>docs/api/</code> - API documentation</li> <li><code>docs/contributing/</code> - Contribution guidelines</li> </ul>"},{"location":"contributing/updating-docs/#style-guidelines","title":"Style Guidelines","text":"<ul> <li>Use Markdown headers appropriately (# for title, ## for sections)</li> <li>Include code examples when relevant</li> <li>Use relative links when linking to other documentation pages</li> <li>Use tables for presenting comparative information</li> <li>Include screenshots when helpful</li> </ul>"},{"location":"contributing/validation/","title":"Submission Validation Process","text":"<p>To maintain high quality data in the Awesome-Virome collection, all tool submissions undergo a comprehensive validation process. This page explains how submissions are validated and provides guidelines to help your submission pass validation.</p>"},{"location":"contributing/validation/#validation-overview","title":"Validation Overview","text":"<p>The validation process includes:</p> <ol> <li>Automated Validation: Initial checks performed by our validation system</li> <li>Manual Review: Human review of submissions that pass automated validation</li> <li>Feedback Process: Communication about issues or improvements needed</li> <li>Final Approval: Acceptance and integration into the collection</li> </ol>"},{"location":"contributing/validation/#automated-validation","title":"Automated Validation","text":""},{"location":"contributing/validation/#what-gets-validated","title":"What Gets Validated","text":"<p>Our automated system checks:</p> <ul> <li>Required Fields: Ensuring all required information is provided</li> <li>URL Accessibility: Verifying that the tool URL is accessible</li> <li>DOI/Citation Validity: Validating any provided DOIs or citations</li> <li>Description Quality: Analyzing the clarity and informativeness of descriptions</li> <li>Duplicate Detection: Checking for existing entries with the same name or URL</li> <li>Category Correctness: Verifying appropriate categorization</li> </ul>"},{"location":"contributing/validation/#validation-scoring","title":"Validation Scoring","text":"<p>Each submission receives a quality score (0-100) based on:</p> Component Weight Description Completeness 30% Presence of all required and recommended fields URL Validity 20% Accessibility and correctness of the provided URL Description Quality 25% Clarity, relevance, and informativeness Metadata Accuracy 15% Correctness of provided metadata (version, language, etc.) Citation Validity 10% Validity of provided DOIs or citations <p>Submissions must achieve a score of at least 70 to proceed to manual review.</p>"},{"location":"contributing/validation/#validation-process","title":"Validation Process","text":""},{"location":"contributing/validation/#step-1-initial-submission","title":"Step 1: Initial Submission","text":"<p>When you submit a new tool (via issue or pull request), the validation process begins automatically.</p>"},{"location":"contributing/validation/#step-2-automated-checks","title":"Step 2: Automated Checks","text":"<p>Our validation system performs the following checks:</p> <ol> <li>URL Check: The tool URL is tested to ensure it's accessible</li> <li>Required Fields Check: Verifies all required fields are provided</li> <li>Duplicate Check: Searches for existing entries with similar names or URLs</li> <li>DOI Validation: If a DOI is provided, it's checked for validity</li> <li>Description Analysis: Evaluates the description for clarity and relevance</li> <li>Repository Analysis: For GitHub/GitLab/Bitbucket repos, additional metadata is collected</li> </ol>"},{"location":"contributing/validation/#step-3-validation-report","title":"Step 3: Validation Report","text":"<p>After validation completes, you'll receive a comment with:</p> <ul> <li>Overall validation score</li> <li>Pass/fail status for each validation check</li> <li>Specific errors or warnings that need addressing</li> <li>Suggestions for improving your submission</li> </ul> <p>Example validation report:</p> <pre><code>## Validation Report for ToolName\n\nOverall Score: 85/100 \u2705\n\n### Validation Results:\n- Required Fields: \u2705 All required fields present\n- URL Validity: \u2705 URL is accessible\n- Duplicate Check: \u2705 No duplicates found\n- Description Quality: \u26a0\ufe0f Description could be more detailed\n- Repository Analysis: \u2705 GitHub metadata successfully collected\n\n### Suggestions:\n- Add more specific details about what the tool does\n- Consider including installation instructions\n- Add package manager information if available\n\nThis submission has passed validation and will be reviewed by a maintainer.\n</code></pre>"},{"location":"contributing/validation/#step-4-addressing-feedback","title":"Step 4: Addressing Feedback","text":"<p>If your submission receives a failing score or has errors:</p> <ol> <li>Review the validation report carefully</li> <li>Make the necessary changes to your submission</li> <li>The validation will run again automatically after your changes</li> </ol>"},{"location":"contributing/validation/#step-5-manual-review","title":"Step 5: Manual Review","text":"<p>Submissions that pass automated validation undergo manual review by a maintainer, who checks:</p> <ul> <li>Relevance to virome analysis</li> <li>Appropriate categorization</li> <li>Description accuracy and clarity</li> <li>Overall quality and usefulness</li> </ul>"},{"location":"contributing/validation/#step-6-final-decision","title":"Step 6: Final Decision","text":"<p>After manual review, your submission will either be:</p> <ul> <li>Approved: Integrated into the collection</li> <li>Requested Changes: Sent back with specific improvement requests</li> <li>Rejected: Declined with a clear explanation of why</li> </ul>"},{"location":"contributing/validation/#common-validation-issues","title":"Common Validation Issues","text":""},{"location":"contributing/validation/#url-validation-failures","title":"URL Validation Failures","text":"<p>Issue: The provided URL is not accessible or returns an error.</p> <p>Solution: - Verify the URL is correct and not missing components - Ensure the repository or website is public - Check if the tool has moved to a new location - For archived tools, provide an archive URL (e.g., Internet Archive)</p>"},{"location":"contributing/validation/#description-quality-issues","title":"Description Quality Issues","text":"<p>Issue: The description is too vague, too short, or lacks relevant information.</p> <p>Solution: - Ensure the description is at least 100 characters - Include specific functionality the tool provides - Mention what type of data it works with - Include unique features or advantages</p>"},{"location":"contributing/validation/#duplicate-detection","title":"Duplicate Detection","text":"<p>Issue: A tool with the same or very similar name already exists.</p> <p>Solution: - Check if you're submitting an updated version of an existing tool - Clarify the name if it's different from an existing tool - Add version information if it's a new version - Consider updating the existing entry instead</p>"},{"location":"contributing/validation/#category-mismatches","title":"Category Mismatches","text":"<p>Issue: The tool is placed in an inappropriate category.</p> <p>Solution: - Review the category definitions in the README - Consider the primary functionality of the tool - Place tools with multiple functions in the most relevant category - Suggest a new category if none of the existing ones fit</p>"},{"location":"contributing/validation/#example-of-a-good-submission","title":"Example of a Good Submission","text":"<p>Here's an example of a submission that would pass validation:</p> <pre><code>## Tool Information\n\n- **Name**: ViralMSA\n- **URL**: https://github.com/niemasd/ViralMSA\n- **Description**: A Python tool for viral multiple sequence alignment using various read mappers. It's optimized for viral genome analysis and supports multiple reference genomes.\n- **Category**: Sequence Analysis\n- **Subcategory**: Multiple Sequence Alignment\n- **Installation**: pip install viralmsa\n- **Language**: Python\n- **Version**: v1.1.2 (2023-02-15)\n- **License**: GNU GPL v3.0\n- **Paper DOI**: 10.1093/bioinformatics/btaa743\n</code></pre> <p>This submission includes all required fields, provides comprehensive information, and correctly categorizes the tool.</p>"},{"location":"contributing/validation/#validation-tools","title":"Validation Tools","text":"<p>For contributors who want to validate submissions before submitting:</p> <ul> <li>Our validation script is available in the repository at <code>scripts/tool_validator.py</code></li> <li>You can run it locally to check your submission before creating an issue or PR</li> <li>Example usage: <code>python scripts/tool_validator.py --name \"ToolName\" --url \"https://example.com/tool\" --description \"Tool description\" --category \"Category\"</code></li> </ul>"},{"location":"contributing/validation/#questions-about-validation","title":"Questions About Validation","text":"<p>If you have questions about the validation process:</p> <ul> <li>Check the validation FAQ</li> <li>Ask in GitHub Discussions</li> <li>Contact the maintainers through the repository</li> </ul> <p>We appreciate your contributions to Awesome-Virome and are committed to maintaining a high-quality collection of virome analysis tools.</p>"},{"location":"fundamentals/","title":"Fundamentals of Virome Analysis","text":"<p>Last Updated: November 29, 2025</p> <p>This section provides essential background knowledge for understanding and performing virome analysis. Whether you're new to the field or looking to deepen your understanding, these fundamentals will help you design better experiments and interpret your results correctly.</p>"},{"location":"fundamentals/#what-is-a-virome","title":"What is a Virome?","text":"<p>A virome is the collection of all viruses (including bacteriophages, archaea viruses, and eukaryotic viruses) in a particular environment or host organism. The term encompasses:</p> <ul> <li>Complete viral genomes - Fully sequenced viral genetic material</li> <li>Partial viral sequences - Fragments of viral genomes from metagenomic data</li> <li>Prophages - Viral genomes integrated into host chromosomes</li> <li>Extrachromosomal elements - Plasmids and other mobile genetic elements with viral characteristics</li> </ul>"},{"location":"fundamentals/#virome-vs-metagenome","title":"Virome vs. Metagenome","text":"<p>It's important to distinguish:</p> <ul> <li>Metagenome: All genetic material from all organisms in a sample (bacteria, archaea, eukaryotes, AND viruses)</li> <li>Virome: Only the viral fraction of genetic material</li> <li>Viral metagenome: Sequencing data from virus-enriched samples (e.g., VLP preparations)</li> </ul>"},{"location":"fundamentals/#why-study-viromes","title":"Why Study Viromes?","text":"<p>Viruses are the most abundant biological entities on Earth (~10\u00b3\u00b9 particles) and play critical roles in:</p>"},{"location":"fundamentals/#ecological-impact","title":"Ecological Impact","text":"<ul> <li>Microbial mortality: Viruses kill ~20-40% of ocean bacteria daily</li> <li>Nutrient cycling: Viral lysis releases nutrients back into ecosystems</li> <li>Population control: Regulate bacterial and algal populations</li> <li>Horizontal gene transfer: Facilitate genetic exchange between hosts</li> </ul>"},{"location":"fundamentals/#human-health","title":"Human Health","text":"<ul> <li>Microbiome modulation: Phages shape gut bacterial communities</li> <li>Disease: Pathogenic viruses cause illness</li> <li>Therapy: Phage therapy for antibiotic-resistant infections</li> <li>Biomarkers: Viral signatures can indicate disease states</li> </ul>"},{"location":"fundamentals/#biotechnology","title":"Biotechnology","text":"<ul> <li>Genetic engineering: CRISPR systems derived from viral defense mechanisms</li> <li>Antimicrobials: Phages and phage-derived proteins as therapeutics</li> <li>Biosensors: Viral components for detection systems</li> <li>Enzyme discovery: Novel enzymes from viral genomes</li> </ul>"},{"location":"fundamentals/#types-of-viromes","title":"Types of Viromes","text":"<p>Viromes vary dramatically based on their source:</p>"},{"location":"fundamentals/#human-associated-viromes","title":"Human-Associated Viromes","text":""},{"location":"fundamentals/#gut-virome","title":"Gut Virome","text":"<ul> <li>Composition: Primarily bacteriophages (&gt;95%), some eukaryotic viruses</li> <li>Stability: Relatively stable in healthy adults, variable in infants</li> <li>Diversity: 10\u2078-10\u00b9\u2070 virus-like particles per gram of feces</li> <li>Challenges: High inter-individual variation, difficult to culture</li> <li>Applications: Microbiome research, disease associations, therapy development</li> </ul>"},{"location":"fundamentals/#respiratory-virome","title":"Respiratory Virome","text":"<ul> <li>Composition: Mix of eukaryotic viruses and phages</li> <li>Dynamics: Highly variable, influenced by infections and environment</li> <li>Sampling: Nasal swabs, throat swabs, bronchoalveolar lavage</li> <li>Challenges: Low viral biomass, host DNA contamination</li> <li>Applications: Infectious disease surveillance, pathogen discovery</li> </ul>"},{"location":"fundamentals/#skin-virome","title":"Skin Virome","text":"<ul> <li>Composition: Dominated by phages targeting skin bacteria</li> <li>Spatial variation: Different body sites have distinct viromes</li> <li>Challenges: Low biomass, environmental contamination</li> <li>Applications: Dermatology, personalized medicine</li> </ul>"},{"location":"fundamentals/#environmental-viromes","title":"Environmental Viromes","text":""},{"location":"fundamentals/#marine-virome","title":"Marine Virome","text":"<ul> <li>Abundance: 10\u2076-10\u2078 viruses per mL seawater</li> <li>Diversity: Extremely high, mostly unknown viruses</li> <li>Function: Major drivers of biogeochemical cycles</li> <li>Challenges: Enormous diversity, most uncultivable</li> <li>Applications: Climate change research, ecosystem monitoring</li> </ul>"},{"location":"fundamentals/#soil-virome","title":"Soil Virome","text":"<ul> <li>Complexity: Among the most complex viromes</li> <li>Host range: Infect bacteria, archaea, fungi, plants</li> <li>Challenges: Extraction difficulties, humic acid contamination</li> <li>Applications: Agriculture, carbon cycling, bioremediation</li> </ul>"},{"location":"fundamentals/#freshwater-virome","title":"Freshwater Virome","text":"<ul> <li>Variation: Lakes, rivers, groundwater have distinct viromes</li> <li>Dynamics: Seasonal changes, pollution impacts</li> <li>Applications: Water quality monitoring, ecosystem health</li> </ul>"},{"location":"fundamentals/#wastewater-virome","title":"Wastewater Virome","text":"<ul> <li>Composition: Human pathogens, phages, plant/animal viruses</li> <li>Applications: Disease surveillance (e.g., COVID-19, polio)</li> <li>Challenges: Complex mixtures, PCR inhibitors</li> <li>Value: Population-level health monitoring</li> </ul>"},{"location":"fundamentals/#clinical-viromes","title":"Clinical Viromes","text":""},{"location":"fundamentals/#infection-associated","title":"Infection-Associated","text":"<ul> <li>Samples: Blood, CSF, tissue biopsies</li> <li>Goals: Pathogen identification, outbreak investigation</li> <li>Challenges: Low viral load, host DNA dominance</li> <li>Applications: Diagnostics, emerging pathogen discovery</li> </ul>"},{"location":"fundamentals/#biological-concepts","title":"Biological Concepts","text":""},{"location":"fundamentals/#viral-lifecycle-strategies","title":"Viral Lifecycle Strategies","text":"<p>Understanding viral lifecycles is crucial for interpretation:</p>"},{"location":"fundamentals/#lytic-cycle-virulent-viruses","title":"Lytic Cycle (Virulent Viruses)","text":"<ol> <li>Attachment: Virus binds to host cell receptors</li> <li>Entry: Viral genome enters host cell</li> <li>Replication: Viral genomes and proteins are produced</li> <li>Assembly: New virus particles are formed</li> <li>Lysis: Host cell bursts, releasing viruses</li> </ol> <p>Implications for virome analysis: - High viral abundance indicates active infections - Rapid turnover in populations - Strong selective pressure on hosts</p>"},{"location":"fundamentals/#lysogenic-cycle-temperate-viruses","title":"Lysogenic Cycle (Temperate Viruses)","text":"<ol> <li>Integration: Viral DNA integrates into host chromosome (becomes prophage)</li> <li>Dormancy: Prophage replicates with host genome</li> <li>Induction: Environmental stress triggers activation</li> <li>Lytic cycle: Prophage excises and enters lytic cycle</li> </ol> <p>Implications for virome analysis: - Prophages detected in bacterial genomes - Can be cryptic (non-functional) or active - Complicate host-virus assignment - Represent \"dark matter\" in metagenomes</p>"},{"location":"fundamentals/#chronicpersistent-infections","title":"Chronic/Persistent Infections","text":"<ul> <li>Continuous low-level virus production</li> <li>No cell lysis</li> <li>Common in eukaryotic viruses</li> </ul>"},{"location":"fundamentals/#viral-diversity-and-classification","title":"Viral Diversity and Classification","text":""},{"location":"fundamentals/#baltimore-classification","title":"Baltimore Classification","text":"<p>Viruses classified by genome type:</p> <ul> <li>Class I: dsDNA viruses (e.g., most phages, herpesviruses)</li> <li>Class II: ssDNA viruses (e.g., microviruses, parvoviruses)</li> <li>Class III: dsRNA viruses (e.g., reoviruses)</li> <li>Class IV: (+)ssRNA viruses (e.g., picornaviruses, coronaviruses)</li> <li>Class V: (-)ssRNA viruses (e.g., influenza, Ebola)</li> <li>Class VI: ssRNA-RT viruses (e.g., retroviruses)</li> <li>Class VII: dsDNA-RT viruses (e.g., hepadnaviruses)</li> </ul> <p>Relevance to virome analysis: - Different sample prep methods for DNA vs RNA viruses - Different assembly and annotation approaches - Different databases and search strategies</p>"},{"location":"fundamentals/#taxonomic-hierarchy","title":"Taxonomic Hierarchy","text":"<ul> <li>Realm: Highest level (e.g., Duplodnaviria)</li> <li>Kingdom: (e.g., Heunggongvirae)</li> <li>Phylum: (e.g., Uroviricota)</li> <li>Class: (e.g., Caudoviricetes)</li> <li>Order: (e.g., Caudovirales)</li> <li>Family: (e.g., Siphoviridae)</li> <li>Genus: (e.g., T4virus)</li> <li>Species: (e.g., Escherichia virus T4)</li> </ul> <p>Note: Many environmental viruses lack formal taxonomic classification.</p>"},{"location":"fundamentals/#viral-dark-matter","title":"Viral \"Dark Matter\"","text":"<p>Definition: Viral sequences with no similarity to known viruses (typically &gt;50% of environmental viral sequences)</p> <p>Challenges: - Cannot be taxonomically classified - Unknown functions and hosts - Difficult to validate as truly viral</p> <p>Approaches: - Protein family-based classification (vConTACT2, VIPTree) - Genomic context and gene synteny - Host prediction methods - Functional annotation despite lacking homologs</p>"},{"location":"fundamentals/#common-challenges-in-virome-analysis","title":"Common Challenges in Virome Analysis","text":""},{"location":"fundamentals/#technical-challenges","title":"Technical Challenges","text":""},{"location":"fundamentals/#low-viral-biomass","title":"Low Viral Biomass","text":"<ul> <li>Problem: Viruses are small and don't have cells</li> <li>Solutions: Enrichment methods (VLP preparation), high sequencing depth</li> <li>Considerations: Not all viruses enrich equally</li> </ul>"},{"location":"fundamentals/#host-contamination","title":"Host Contamination","text":"<ul> <li>Problem: Host DNA/RNA can dominate even in enriched samples</li> <li>Solutions: DNase treatment, size filtration, computational depletion</li> <li>Considerations: Some viral genomes integrate into hosts (prophages)</li> </ul>"},{"location":"fundamentals/#dna-vs-rna-viruses","title":"DNA vs RNA Viruses","text":"<ul> <li>Problem: Standard DNA extractions miss RNA viruses</li> <li>Solutions: Separate RNA extraction, dsRNA enrichment</li> <li>Considerations: Need different library prep and sequencing strategies</li> </ul>"},{"location":"fundamentals/#biological-challenges","title":"Biological Challenges","text":""},{"location":"fundamentals/#extreme-diversity","title":"Extreme Diversity","text":"<ul> <li>Problem: Viruses evolve rapidly, most are unknown</li> <li>Solutions: Assembly-based approaches, profile HMMs, machine learning</li> <li>Considerations: Reference databases are biased and incomplete</li> </ul>"},{"location":"fundamentals/#prophages","title":"Prophages","text":"<ul> <li>Problem: Integrated viral genomes mixed with host genomes</li> <li>Solutions: Prophage prediction tools, CheckV for quality assessment</li> <li>Considerations: Incomplete prophages, false boundaries, cryptic elements</li> </ul>"},{"location":"fundamentals/#horizontal-gene-transfer","title":"Horizontal Gene Transfer","text":"<ul> <li>Problem: Viral genes in hosts, host genes in viruses</li> <li>Solutions: Careful annotation, auxiliary metabolic gene (AMG) analysis</li> <li>Considerations: Mobile genetic elements blur virus-host boundaries</li> </ul>"},{"location":"fundamentals/#analytical-challenges","title":"Analytical Challenges","text":""},{"location":"fundamentals/#false-positives","title":"False Positives","text":"<ul> <li>Problem: Cellular genes misclassified as viral</li> <li>Solutions: Multiple prediction tools, consensus approaches, validation</li> <li>Considerations: Trade-off between sensitivity and specificity</li> </ul>"},{"location":"fundamentals/#host-assignment","title":"Host Assignment","text":"<ul> <li>Problem: Most viruses have unknown hosts</li> <li>Solutions: Multiple prediction methods, CRISPR spacers, co-occurrence</li> <li>Considerations: Predictions are hypotheses, not facts</li> </ul>"},{"location":"fundamentals/#abundance-estimation","title":"Abundance Estimation","text":"<ul> <li>Problem: Variable genome sizes, coverage biases</li> <li>Solutions: Normalization by genome length, read mapping</li> <li>Considerations: Prophages vs free viruses complicate interpretation</li> </ul>"},{"location":"fundamentals/#success-factors-for-virome-studies","title":"Success Factors for Virome Studies","text":""},{"location":"fundamentals/#experimental-design","title":"Experimental Design","text":"<p>\u2705 Clear research question - Different questions need different approaches \u2705 Appropriate controls - Negative controls, mock communities \u2705 Sufficient replication - Biological and technical replicates \u2705 Adequate sequencing depth - 10-100 million reads for diversity studies \u2705 Sample handling - Immediate processing or proper storage (-80\u00b0C)</p>"},{"location":"fundamentals/#sample-preparation","title":"Sample Preparation","text":"<p>\u2705 VLP enrichment - For viral-specific analyses (see Sample Preparation) \u2705 Nucleic acid extraction - DNA and/or RNA based on study goals \u2705 Amplification strategy - MDA for DNA, SISPA for RNA (if needed) \u2705 Quality control - Check for contamination at each step</p>"},{"location":"fundamentals/#computational-analysis","title":"Computational Analysis","text":"<p>\u2705 Quality filtering - Remove low-quality reads and adapters \u2705 Assembly strategy - Match to sample complexity and goals \u2705 Multiple tools - Consensus predictions reduce false positives \u2705 Proper validation - CheckV, manual curation of key results \u2705 Appropriate statistics - Account for compositionality, rarefaction</p>"},{"location":"fundamentals/#interpretation","title":"Interpretation","text":"<p>\u2705 Biological context - Consider host, environment, experimental conditions \u2705 Validation needs - What requires experimental validation? \u2705 Known limitations - Acknowledge what you can't determine \u2705 Future directions - What additional experiments would help?</p>"},{"location":"fundamentals/#next-steps","title":"Next Steps","text":"<p>Now that you understand the fundamentals, explore specific topics:</p> <ul> <li>Sample Preparation Methods - How to prepare samples for virome sequencing</li> <li>Sequencing Strategies - Choosing the right sequencing approach</li> <li>Typical Workflows - Step-by-step analysis procedures</li> <li>Tool Selection Guide - Choosing the right tools for your analysis</li> </ul>"},{"location":"fundamentals/#further-reading","title":"Further Reading","text":""},{"location":"fundamentals/#foundational-reviews","title":"Foundational Reviews","text":"<ul> <li>Breitbart, M. (2012). \"Marine viruses: truth or dare.\" Annual Review of Marine Science, 4, 425-448.</li> <li>Suttle, C. A. (2007). \"Marine viruses\u2014major players in the global ecosystem.\" Nature Reviews Microbiology, 5(10), 801-812.</li> <li>Reyes, A., et al. (2012). \"Gut DNA viromes of Malawian twins discordant for severe acute malnutrition.\" PNAS, 110(28), 11387-11392.</li> </ul>"},{"location":"fundamentals/#methods-papers","title":"Methods Papers","text":"<ul> <li>Roux, S., et al. (2016). \"Towards quantitative viromics for both double-stranded and single-stranded DNA viruses.\" PeerJ, 4, e2777.</li> <li>Warwick-Dugdale, J., et al. (2019). \"Long-read viral metagenomics captures abundant and microdiverse viral populations.\" PeerJ, 7, e6800.</li> </ul>"},{"location":"fundamentals/#recent-advances","title":"Recent Advances","text":"<ul> <li>Camargo, A. P., et al. (2023). \"Identification of mobile genetic elements with geNomad.\" Nature Biotechnology, 42, 1303\u20131312.</li> <li>Nayfach, S., et al. (2021). \"CheckV assesses the quality and completeness of metagenome-assembled viral genomes.\" Nature Biotechnology, 39(5), 578-585.</li> </ul>"},{"location":"fundamentals/sample-preparation/","title":"Sample Preparation for Virome Analysis","text":"<p>Last Updated: November 29, 2025</p> <p>Sample preparation is arguably the most critical step in virome analysis. The methods you choose will fundamentally determine what viruses you can detect and how accurately you can characterize them. This guide covers the essential techniques for preparing samples for viral metagenomic sequencing.</p> <p>Critical Point</p> <p>Different sample preparation methods recover different viruses. There is no \"one size fits all\" approach. Your choice should be guided by your research question, sample type, and target viruses.</p>"},{"location":"fundamentals/sample-preparation/#overview-of-sample-preparation-workflow","title":"Overview of Sample Preparation Workflow","text":"graph LR     A[Raw Sample] --&gt; B[Pre-filtration]     B --&gt; C[Viral Enrichment]     C --&gt; D[Nucleic Acid Extraction]     D --&gt; E[Amplification - Optional]     E --&gt; F[Library Preparation]     F --&gt; G[Sequencing]"},{"location":"fundamentals/sample-preparation/#pre-filtration-and-sample-processing","title":"Pre-Filtration and Sample Processing","text":""},{"location":"fundamentals/sample-preparation/#why-pre-filter","title":"Why Pre-Filter?","text":"<p>Pre-filtration removes larger organisms (bacteria, eukaryotes) and debris, enriching for virus-like particles (VLPs).</p>"},{"location":"fundamentals/sample-preparation/#filtration-methods","title":"Filtration Methods","text":""},{"location":"fundamentals/sample-preparation/#sequential-filtration","title":"Sequential Filtration","text":"<p>Standard protocol: 1. Pre-filtration (10-20 \u03bcm): Remove large particles and eukaryotes 2. Bacterial removal (0.45 \u03bcm or 0.22 \u03bcm): Remove most bacteria 3. Viral concentration (Optional): Tangential flow filtration (TFF) or ultracentrifugation</p> <p>Parameters: - 10 \u03bcm: Removes large debris, algae, protozoa - 0.45 \u03bcm: Removes most bacteria while retaining larger viruses - 0.22 \u03bcm: More stringent bacterial removal, may lose large viruses (&gt;200 nm)</p> <p>Filter Choice Matters</p> <ul> <li>Use 0.45 \u03bcm for environmental samples with giant viruses</li> <li>Use 0.22 \u03bcm for clinical samples focused on smaller viruses</li> <li>Consider 0.8 \u03bcm as intermediate for some applications</li> </ul>"},{"location":"fundamentals/sample-preparation/#practical-considerations","title":"Practical Considerations","text":"<ul> <li>Material: PES (polyethersulfone) or PVDF (polyvinylidene fluoride) filters</li> <li>Volume: Larger volumes (&gt;500 mL) may require pre-filtration to prevent clogging</li> <li>Pressure: Avoid high pressure that could lyse viruses</li> <li>Speed: Process quickly to minimize viral decay</li> </ul>"},{"location":"fundamentals/sample-preparation/#sample-type-specific-processing","title":"Sample Type-Specific Processing","text":""},{"location":"fundamentals/sample-preparation/#aquatic-samples-marine-freshwater","title":"Aquatic Samples (Marine, Freshwater)","text":"<pre><code># Typical workflow\n1. Collect water (0.5-10 L depending on viral abundance)\n2. Pre-filter through 10 \u03bcm filter\n3. Filter through 0.22 \u03bcm filter\n4. Concentrate using tangential flow filtration (10-100x)\n5. Proceed to enrichment\n</code></pre> <p>Challenges: - Large volumes needed for low-biomass environments - Seasonal variation in viral abundance - Particulate matter can clog filters</p>"},{"location":"fundamentals/sample-preparation/#fecalgut-samples","title":"Fecal/Gut Samples","text":"<pre><code># Typical workflow\n1. Resuspend feces in SM buffer (0.1-0.5 g in 5-10 mL)\n2. Vortex thoroughly, incubate 10-30 min at 4\u00b0C\n3. Centrifuge (5,000-10,000 \u00d7 g, 10 min) to pellet debris\n4. Filter supernatant through 0.45 \u03bcm syringe filter\n5. Proceed to enrichment\n</code></pre> <p>Challenges: - High bacterial contamination - PCR inhibitors (bile salts, polysaccharides) - Variable viral titers</p>"},{"location":"fundamentals/sample-preparation/#soil-samples","title":"Soil Samples","text":"<pre><code># Typical workflow\n1. Resuspend soil in phosphate buffer (1:4 w/v)\n2. Shake vigorously, incubate with rotation (30 min to 2 hr)\n3. Centrifuge (5,000 \u00d7 g, 10 min)\n4. Filter supernatant through 0.45 \u03bcm filter\n5. May require cesium chloride purification\n</code></pre> <p>Challenges: - Humic acids (brown color, PCR inhibition) - Very high bacterial contamination - Low viral recovery efficiency</p>"},{"location":"fundamentals/sample-preparation/#clinical-samples","title":"Clinical Samples","text":"<p>Blood/Serum: - Centrifuge to remove cells - Filter through 0.45 \u03bcm - May require DNase treatment - Low viral biomass often requires enrichment</p> <p>Respiratory samples (swabs, BAL): - Resuspend in viral transport media - Clarify by centrifugation - Filter through 0.45 \u03bcm - Host RNA/DNA is major contaminant</p>"},{"location":"fundamentals/sample-preparation/#viral-enrichment-methods","title":"Viral Enrichment Methods","text":""},{"location":"fundamentals/sample-preparation/#why-enrich","title":"Why Enrich?","text":"<p>Even after filtration, samples may contain: - Residual bacteria (broken cells, small bacteria) - Free DNA/RNA from lysed cells - Host contamination</p> <p>Goals of enrichment: 1. Increase ratio of viral to non-viral nucleic acids 2. Remove free extracellular DNA/RNA 3. Maintain viral genome integrity</p>"},{"location":"fundamentals/sample-preparation/#dnasernase-treatment","title":"DNase/RNase Treatment","text":"<p>Principle: Digest free nucleic acids while leaving encapsidated viral genomes intact.</p> <p>Standard Protocol: <pre><code>1. Add DNase I (10-100 U/mL) to filtered sample\n2. Add RNase A (10-50 \u03bcg/mL) if targeting DNA viruses\n3. Incubate 1-2 hours at 37\u00b0C\n4. Optional: Add MgCl2 (5-10 mM final) to enhance DNase activity\n5. Inactivate enzymes (heat to 65\u00b0C for 10 min + EDTA)\n6. Proceed to nucleic acid extraction\n</code></pre></p> <p>Advantages: - Simple and effective - Removes most free nucleic acids - Compatible with most downstream methods</p> <p>Limitations: - Some enzymes may enter damaged virions - Incomplete digestion of all contaminants - Can't distinguish integrated prophages from bacterial genomes</p> <p>Critical Control</p> <p>Always include a DNase/RNase-free control to assess how much contamination removal occurs!</p>"},{"location":"fundamentals/sample-preparation/#cscl-density-gradient-ultracentrifugation","title":"CsCl Density Gradient Ultracentrifugation","text":"<p>Principle: Viruses have distinct buoyant density (1.3-1.5 g/cm\u00b3) separating from cells and debris.</p> <p>Protocol: <pre><code>1. Layer sample over CsCl gradient (1.2-1.6 g/cm\u00b3)\n2. Ultracentrifuge (100,000-200,000 \u00d7 g, 2-24 hours)\n3. Collect viral band (typically ~1.4 g/cm\u00b3)\n4. Remove CsCl by dialysis or ultrafiltration\n5. Proceed to nucleic acid extraction\n</code></pre></p> <p>Advantages: - High purity viral preparations - Removes most contaminating nucleic acids - Can separate different virus types by density</p> <p>Limitations: - Requires ultracentrifuge (expensive, specialized) - Time-consuming (hours to overnight) - Some viruses may aggregate or not band clearly - Low throughput (typically one sample at a time)</p>"},{"location":"fundamentals/sample-preparation/#iron-chloride-fecl3-flocculation","title":"Iron Chloride (FeCl\u2083) Flocculation","text":"<p>Principle: Viruses bind to iron hydroxide precipitates and can be concentrated.</p> <p>Protocol: <pre><code>1. Add FeCl\u2083 (final concentration 0.005-0.01 g/L)\n2. Adjust pH to 3.5-4.5\n3. Mix gently, incubate 10-30 min\n4. Centrifuge (5,000 \u00d7 g, 10 min) to pellet flocs\n5. Resuspend pellet in neutral buffer\n6. May need DNase treatment before extraction\n</code></pre></p> <p>Advantages: - Simple and inexpensive - Effective for large volumes - High virus recovery</p> <p>Limitations: - Not selective (bacteria also flocculate) - Requires pH optimization - Potential for PCR inhibition from iron</p>"},{"location":"fundamentals/sample-preparation/#polyethylene-glycol-peg-precipitation","title":"Polyethylene Glycol (PEG) Precipitation","text":"<p>Principle: PEG causes viral particles to aggregate and precipitate.</p> <p>Protocol: <pre><code>1. Add PEG-8000 (final 8-10% w/v) and NaCl (0.5-1 M)\n2. Mix thoroughly, incubate 4\u00b0C overnight (or 1-2 hr room temp)\n3. Centrifuge (10,000 \u00d7 g, 30 min)\n4. Discard supernatant, resuspend pellet in small volume buffer\n5. Proceed to nucleic acid extraction\n</code></pre></p> <p>Advantages: - Concentrates viruses effectively - No specialized equipment needed - Can process large volumes</p> <p>Limitations: - Co-precipitates proteins and debris - Requires DNase treatment afterward - PEG can inhibit downstream enzymes</p>"},{"location":"fundamentals/sample-preparation/#tangential-flow-filtration-tff","title":"Tangential Flow Filtration (TFF)","text":"<p>Principle: Concentrate viruses by cross-flow filtration.</p> <p>Protocol: <pre><code>1. Pass sample through TFF system (100 kDa or 300 kDa cutoff)\n2. Concentrate to desired volume (typically 10-100x)\n3. Optional: Diafiltration to exchange buffer\n4. Proceed to DNase treatment or extraction\n</code></pre></p> <p>Advantages: - Scalable (milliliters to liters) - Gentle (minimal viral damage) - Efficient concentration</p> <p>Limitations: - Equipment cost - Membrane fouling - Small viruses may pass through</p>"},{"location":"fundamentals/sample-preparation/#nucleic-acid-extraction","title":"Nucleic Acid Extraction","text":""},{"location":"fundamentals/sample-preparation/#dna-extraction","title":"DNA Extraction","text":""},{"location":"fundamentals/sample-preparation/#standard-methods","title":"Standard Methods","text":"<p>Phenol-Chloroform Extraction: - Pros: High yield, removes proteins effectively - Cons: Toxic chemicals, labor-intensive - Use when: Maximum yield needed, small number of samples</p> <p>Column-Based Kits (e.g., Qiagen DNeasy, Zymo): - Pros: Fast, safe, reproducible - Cons: Can be expensive, lower yields - Use when: Medium sample numbers, safety important</p> <p>Magnetic Bead-Based (e.g., Agencourt, MagAttract): - Pros: Automatable, high throughput - Cons: Equipment required, variable recovery - Use when: Large sample numbers, automation available</p>"},{"location":"fundamentals/sample-preparation/#protocol-considerations","title":"Protocol Considerations","text":"<p>Lysis methods: - SDS + Proteinase K: Standard for most viruses - Freeze-thaw: Gentle, for sensitive viruses - Bead beating: For tough-coated viruses (e.g., noroviruses)</p> <p>Yield optimization: - Longer proteinase K incubation (1-2 hr or overnight) - Carrier RNA to improve recovery of low-biomass samples - Multiple elutions with warm elution buffer</p>"},{"location":"fundamentals/sample-preparation/#rna-extraction","title":"RNA Extraction","text":"<p>Challenges: - RNA is easily degraded by RNases - Many viruses have RNA genomes - RNA and DNA may need separate extractions</p> <p>Key differences from DNA extraction: - RNase-free water and reagents mandatory - TRIzol or equivalent for RNA-specific extraction - Optional: DNase treatment to remove DNA before library prep</p> <p>Combined DNA/RNA extraction: - AllPrep kits (Qiagen) extract both simultaneously - Useful for comprehensive virome analysis - More expensive than single-extraction protocols</p>"},{"location":"fundamentals/sample-preparation/#quality-control-after-extraction","title":"Quality Control After Extraction","text":"<p>Quantification: - Qubit fluorometry: Most accurate for low concentrations - NanoDrop spectrophotometry: Quick but less accurate at low concentrations - qPCR/RT-qPCR: For specific viral targets</p> <p>Quality Assessment: - 260/280 ratio: Should be ~1.8 for DNA, ~2.0 for RNA - 260/230 ratio: Should be 2.0-2.2 (lower indicates contamination) - Fragment size: Bioanalyzer or TapeStation to check integrity</p> <p>Expected yields: - High biomass (gut, seawater): 0.5-5 \u03bcg per sample - Medium biomass (soil, clinical): 0.1-1 \u03bcg per sample - Low biomass (blood, CSF): 10-100 ng per sample</p> <p>Low Yield Solutions</p> <p>If yields are &lt;50 ng: - Check filtration isn't removing too many viruses - Verify DNase treatment isn't too aggressive - Consider amplification (MDA or linker amplification) - Increase starting sample volume</p>"},{"location":"fundamentals/sample-preparation/#genome-amplification-optional","title":"Genome Amplification (Optional)","text":""},{"location":"fundamentals/sample-preparation/#when-to-amplify","title":"When to Amplify?","text":"<p>Consider amplification if: - Extracted DNA/RNA &lt;50 ng - Need to conserve precious samples - Require multiple library preparations from one extraction</p> <p>Avoid amplification if: - Sufficient material available (&gt;100 ng) - Concerned about PCR bias - Performing quantitative analyses (abundance changes)</p>"},{"location":"fundamentals/sample-preparation/#multiple-displacement-amplification-mda","title":"Multiple Displacement Amplification (MDA)","text":"<p>Best for: DNA viruses</p> <p>Principle: Phi29 polymerase with random hexamers provides uniform amplification of circular and linear DNA.</p> <p>Protocol: <pre><code>1. Denature DNA (95\u00b0C, 3 min)\n2. Add Phi29 polymerase + random hexamers\n3. Incubate 30\u00b0C, 4-16 hours\n4. Heat inactivate (65\u00b0C, 10 min)\n5. Purify amplified DNA\n</code></pre></p> <p>Advantages: - High yield (1,000-10,000x amplification) - Long products (&gt;10 kb) - Uniform amplification</p> <p>Limitations: - Amplification bias (especially with multiple templates) - Phi29 prefers circular DNA (good for some viruses) - Can amplify contaminants</p>"},{"location":"fundamentals/sample-preparation/#linker-amplification-sequence-independent","title":"Linker Amplification (Sequence-Independent)","text":"<p>Best for: Both DNA and RNA viruses</p> <p>Principle: Add linkers to fragmented nucleic acids, then PCR amplify.</p> <p>Common methods: - SISPA (Sequence-Independent Single Primer Amplification) - NEBNext SISPA: Commercial kit version</p> <p>Advantages: - Works for RNA and DNA - Less bias than MDA for some samples - Simultaneous fragmentation and amplification</p> <p>Limitations: - Shorter fragments than MDA - Requires more input DNA/RNA initially - Multiple enzymatic steps</p>"},{"location":"fundamentals/sample-preparation/#rolling-circle-amplification-rca","title":"Rolling Circle Amplification (RCA)","text":"<p>Best for: Circular ssDNA viruses</p> <p>Principle: Amplifies circular DNA templates using random primers and Phi29 polymerase.</p> <p>Applications: - CRESS viruses (Circular Rep-encoding ssDNA viruses) - Some bacteriophages with circular genomes</p> <p>Limitations: - Only works for circular templates - Linear genomes won't amplify</p>"},{"location":"fundamentals/sample-preparation/#special-considerations","title":"Special Considerations","text":""},{"location":"fundamentals/sample-preparation/#dsrna-extraction","title":"dsRNA Extraction","text":"<p>Why: Many RNA viruses have dsRNA replication intermediates or genomes.</p> <p>Method: 1. Extract total RNA 2. Digest ssRNA with RNase A (leaves dsRNA intact) 3. Denature dsRNA before library prep</p> <p>Applications: - Plant virus discovery - Fungal virus detection - Eukaryotic RNA virus enrichment</p>"},{"location":"fundamentals/sample-preparation/#prophage-handling","title":"Prophage Handling","text":"<p>Challenge: Prophages are integrated in host genomes.</p> <p>Options:</p> <p>Include prophages (metagenome approach): - Extract total DNA without filtration - Identify prophages computationally - Maintains host-virus linkage</p> <p>Exclude prophages (VLP approach): - Filter to remove bacteria - Only captures free virions - Misses temperate phages unless induced</p> <p>Induced prophages: - Treat sample with Mitomycin C or UV - Induces prophage excision and lytic cycle - Captures previously hidden temperate phages</p>"},{"location":"fundamentals/sample-preparation/#quality-control-and-negative-controls","title":"Quality Control and Negative Controls","text":""},{"location":"fundamentals/sample-preparation/#essential-controls","title":"Essential Controls","text":"<p>Negative extraction control: - Process with no sample input - Identifies reagent contamination - Especially important for low-biomass samples</p> <p>Mock community control: - Defined mixture of known viruses - Assesses recovery efficiency - Calibrates quantification</p> <p>DNase/RNase efficiency control: - Sample without enzyme treatment - Quantifies contamination removal - Validates enrichment</p>"},{"location":"fundamentals/sample-preparation/#contamination-assessment","title":"Contamination Assessment","text":"<p>Common contaminants: - Bacterial genomes (16S rRNA gene amplification) - Host DNA (species-specific qPCR) - Reagent contamination (kit DNA) - Environmental contamination (lab viruses)</p> <p>Detection: - Sequence negative controls - Check for unexpected taxa - Compare to known contaminant databases</p>"},{"location":"fundamentals/sample-preparation/#recommended-protocols-by-sample-type","title":"Recommended Protocols by Sample Type","text":""},{"location":"fundamentals/sample-preparation/#standard-gut-virome-protocol","title":"Standard Gut Virome Protocol","text":"<pre><code>1. Resuspend 200 mg feces in 5 mL SM buffer\n2. Vortex, incubate 20 min at 4\u00b0C with rotation\n3. Centrifuge 10,000 \u00d7 g, 10 min\n4. Filter supernatant (0.45 \u03bcm)\n5. DNase/RNase treatment (1-2 hr, 37\u00b0C)\n6. DNA extraction (phenol-chloroform or kit)\n7. Library prep and sequencing\n</code></pre>"},{"location":"fundamentals/sample-preparation/#standard-seawater-virome-protocol","title":"Standard Seawater Virome Protocol","text":"<pre><code>1. Collect 1-4 L seawater\n2. Pre-filter (10 \u03bcm)\n3. Filter (0.22 \u03bcm) to collect viral fraction\n4. Concentrate by TFF (100 kDa, 10-50x)\n5. DNase treatment (overnight, 37\u00b0C)\n6. DNA extraction\n7. Optional: MDA if &lt;100 ng yield\n8. Library prep and sequencing\n</code></pre>"},{"location":"fundamentals/sample-preparation/#low-biomass-clinical-protocol","title":"Low-Biomass Clinical Protocol","text":"<pre><code>1. Clarify sample (centrifugation)\n2. Filter (0.45 \u03bcm)\n3. DNase/RNase treatment\n4. Nucleic acid extraction (with carrier RNA)\n5. Amplification (MDA or linker amplification)\n6. Library prep and sequencing\n</code></pre>"},{"location":"fundamentals/sample-preparation/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":"Problem Possible Causes Solutions Low DNA yield Over-filtration, excessive DNase Use 0.45 \u03bcm filter, optimize DNase time, increase sample volume Brown color (humic acids) Soil/sediment samples CsCl purification, commercial cleanup kits, increase wash steps PCR inhibition Contaminants (humic acids, salts, PEG) Additional wash steps, dilute samples, use inhibitor-resistant polymerases High bacterial contamination Inadequate enrichment Longer DNase treatment, CsCl purification, increase filtration stringency No viral sequences Sample contains no viruses, over-processing Verify with qPCR, reduce processing steps, check sample viability"},{"location":"fundamentals/sample-preparation/#next-steps","title":"Next Steps","text":"<ul> <li>Sequencing Strategies - Choose the right sequencing approach</li> <li>Complete Tutorials - Follow step-by-step protocols</li> <li>Best Practices: Quality Control - Ensure data quality</li> </ul>"},{"location":"fundamentals/sample-preparation/#further-reading","title":"Further Reading","text":"<ul> <li>Thurber, R. V., et al. (2009). \"Laboratory procedures to generate viral metagenomes.\" Nature Protocols, 4(4), 470-483.</li> <li>Roux, S., et al. (2016). \"Towards quantitative viromics for both double-stranded and single-stranded DNA viruses.\" PeerJ, 4, e2777.</li> <li>Lim, E. S., et al. (2015). \"Early life dynamics of the human gut virome and bacterial microbiome in infants.\" Nature Medicine, 21(10), 1228-1234.</li> </ul>"},{"location":"fundamentals/sequencing-strategies/","title":"Sequencing Strategies for Virome Analysis","text":"<p>Last Updated: November 29, 2025</p> <p>Choosing the right sequencing strategy is crucial for successful virome analysis. This guide covers sequencing platforms, library preparation methods, coverage requirements, and how to match your strategy to your research question.</p>"},{"location":"fundamentals/sequencing-strategies/#sequencing-platform-overview","title":"Sequencing Platform Overview","text":""},{"location":"fundamentals/sequencing-strategies/#platform-comparison","title":"Platform Comparison","text":"Platform Read Length Accuracy Throughput Cost/Gb Best For Illumina 150-300 bp &gt;99.9% Very High $ Diversity studies, quantification PacBio HiFi 10-25 kb &gt;99.9% High $$$ Complete genomes, structural variation Oxford Nanopore 1-100+ kb ~95-99% Medium-High $$ Long-range assembly, real-time analysis MGI/BGI 150-300 bp &gt;99% Very High $ Similar to Illumina, lower cost"},{"location":"fundamentals/sequencing-strategies/#illumina-sequencing","title":"Illumina Sequencing","text":"<p>Platforms: NovaSeq, NextSeq, MiSeq, HiSeq</p> <p>Advantages: - Highest accuracy (&gt;Q30) - Well-established protocols - Extensive computational tools - Cost-effective for high throughput - Excellent for paired-end reads</p> <p>Limitations: - Short read length challenges assembly - Can miss structural variants - Repetitive regions difficult to resolve - GC bias in some library prep methods</p> <p>When to use: - Viral diversity and abundance studies - Comparative viromics (multiple samples) - Targeted amplicon sequencing - When high accuracy is paramount - Budget-constrained projects</p> <p>Recommended configurations: - Diversity studies: 2\u00d7150 bp, 10-20M reads per sample - Deep virome: 2\u00d7250 bp, 50-100M reads per sample - Metagenome with virome: 2\u00d7150 bp, 100-300M reads per sample</p>"},{"location":"fundamentals/sequencing-strategies/#pacbio-hifi-sequencing","title":"PacBio HiFi Sequencing","text":"<p>Platform: Sequel II/IIe, Revio</p> <p>Advantages: - Long, accurate reads (HiFi) - Complete viral genomes in single reads - Resolves repeat regions - No GC bias - Detects structural variants</p> <p>Limitations: - More expensive per gigabase - Lower throughput than Illumina - Requires more input DNA (typically) - Computational intensity for assembly</p> <p>When to use: - Isolate sequencing (complete genomes) - Characterizing structural variation - Resolving complex repeats - Host-integrated prophages with flanking regions - Novel virus discovery requiring complete genomes</p> <p>Recommended configurations: - Single viral isolate: 1-5 SMRT cells (Gb scale) - Complex virome: 5-10 SMRT cells for deep coverage - Hybrid approach: Combine with Illumina for accuracy + completeness</p>"},{"location":"fundamentals/sequencing-strategies/#oxford-nanopore-sequencing","title":"Oxford Nanopore Sequencing","text":"<p>Platforms: MinION, GridION, PromethION</p> <p>Advantages: - Very long reads (10-100+ kb) - Real-time sequencing and analysis - Portable (MinION) - Direct RNA sequencing possible - Rapid turnaround - Lower capital cost</p> <p>Limitations: - Lower accuracy than Illumina/HiFi (~95-99%) - Homopolymer errors - Requires more input DNA - Computational tools still maturing</p> <p>When to use: - Rapid outbreak investigation - Field deployment - Long-range structural analysis - Direct RNA virus sequencing - When real-time results needed</p> <p>Recommended configurations: - MinION: Quick virome screen, 1-2 flow cells - PromethION: Deep virome, production-scale - Adaptive sampling: Target specific viral sequences in real-time</p>"},{"location":"fundamentals/sequencing-strategies/#library-preparation-strategies","title":"Library Preparation Strategies","text":""},{"location":"fundamentals/sequencing-strategies/#standard-shotgun-metagenomics","title":"Standard Shotgun Metagenomics","text":"<p>Principle: Fragment all DNA, add adapters, sequence everything.</p> <p>Protocol: <pre><code>1. Fragment DNA (enzymatic or mechanical)\n2. End-repair and A-tailing\n3. Adapter ligation\n4. Size selection (optional)\n5. PCR amplification (minimal cycles)\n6. Quantification and QC\n7. Sequencing\n</code></pre></p> <p>Advantages: - Unbiased representation of viral genomes - Quantitative (read abundance reflects genome abundance) - Works for diverse viral types - Standard, well-supported protocols</p> <p>Limitations: - Requires sufficient input DNA (typically 1-100 ng) - Host contamination in unenriched samples - Rare viruses may need high sequencing depth</p> <p>When to use: - Standard virome analysis - Diversity and abundance studies - Sufficient input material available</p>"},{"location":"fundamentals/sequencing-strategies/#amplicon-sequencing","title":"Amplicon Sequencing","text":"<p>Principle: PCR amplify specific viral genes, then sequence amplicons.</p> <p>Common targets: - DNA viruses: DNA polymerase genes, capsid genes - RNA viruses: RdRp (RNA-dependent RNA polymerase) - Specific groups: Papillomavirus L1, adenovirus hexon, etc.</p> <p>Advantages: - Extremely sensitive (can detect rare viruses) - Lower sequencing cost per sample - Works with low-input samples - Targeted for specific viral groups</p> <p>Limitations: - PCR bias - Only detects amplified regions - Primer design challenges (viral diversity) - Not quantitative (PCR amplification bias) - Misses unamplified viruses</p> <p>When to use: - Surveillance for specific viral families - Low-biomass samples - Cost-effective screening of many samples - Phylogenetic studies of specific genes</p>"},{"location":"fundamentals/sequencing-strategies/#rna-sequencing","title":"RNA Sequencing","text":"<p>Specific considerations for RNA viruses:</p> <p>Library prep options: 1. Random priming: Captures all RNA sequences 2. rRNA depletion: Remove ribosomal contamination 3. PolyA selection: Only for polyA+ viral RNAs (rare in viruses) 4. dsRNA enrichment: Targets viral replication intermediates</p> <p>Challenges: - RNA degradation (use RNase-free everything) - rRNA contamination (often &gt;90% of reads) - Variable strand specificity needs</p> <p>Stranded vs. Non-stranded: - Non-stranded: Cheaper, more standard - Stranded: Preserves orientation, critical for some RNA viruses</p> <p>Recommended approach for RNA viromes: <pre><code>1. Extract RNA (DNase-treated to remove DNA)\n2. Optional: dsRNA enrichment\n3. rRNA depletion (CRITICAL for host-associated samples)\n4. Stranded library prep\n5. Sequencing (2\u00d7150 bp typical)\n</code></pre></p>"},{"location":"fundamentals/sequencing-strategies/#low-input-library-preparation","title":"Low-Input Library Preparation","text":"<p>For samples &lt;1 ng DNA:</p> <p>Options: 1. Nextera XT: Tagmentation-based, works with 1 ng 2. SMARTer: Template switching, works with &lt;1 ng 3. TruSeq Nano: Standard Illumina, requires 25-200 ng (not low-input) 4. MDA then standard library: Amplify first, then make library</p> <p>Considerations: - More PCR cycles = more bias - Adapter dimers more problematic - Size selection often critical - Negative controls absolutely essential</p>"},{"location":"fundamentals/sequencing-strategies/#coverage-and-sequencing-depth","title":"Coverage and Sequencing Depth","text":""},{"location":"fundamentals/sequencing-strategies/#how-much-sequencing","title":"How Much Sequencing?","text":"<p>Factors affecting depth requirements: - Research question (diversity vs. complete genomes) - Sample complexity (simple vs. highly diverse) - Viral abundance (high vs. low biomass) - Assembly strategy (reference vs. de novo)</p>"},{"location":"fundamentals/sequencing-strategies/#recommended-depths","title":"Recommended Depths","text":""},{"location":"fundamentals/sequencing-strategies/#diversitycommunity-analysis","title":"Diversity/Community Analysis","text":"<p>Goal: Detect most abundant viruses, characterize community structure</p> <p>Illumina: - Simple communities (isolates, monocultures): 5-10M reads - Moderate complexity (gut, marine): 20-50M reads - High complexity (soil, sediment): 50-200M reads</p> <p>Expected: - Capture dominant viruses (&gt;0.1% abundance) - Miss rare viruses (&lt;0.01%) - Sufficient for diversity metrics - Good for comparative studies</p>"},{"location":"fundamentals/sequencing-strategies/#deep-characterization","title":"Deep Characterization","text":"<p>Goal: Complete/near-complete genomes of abundant viruses</p> <p>Illumina: - 50-100M reads for gut viromes - 100-300M reads for environmental viromes - More for highly diverse samples</p> <p>Expected: - Near-complete genomes for viruses &gt;0.01% abundance - Better assembly contiguity - Detect rarer viruses - Identify strain variation</p>"},{"location":"fundamentals/sequencing-strategies/#complete-genome-recovery","title":"Complete Genome Recovery","text":"<p>Goal: Closed, circularized viral genomes</p> <p>Long-read (PacBio/Nanopore): - 5-20 Gb for isolates - 20-100 Gb for complex communities - Depends on target genome sizes and abundance</p> <p>Expected: - Complete genomes for abundant viruses - Resolve repeats and structural variations - Phage-host linkages (if integrated)</p>"},{"location":"fundamentals/sequencing-strategies/#rarefaction-and-coverage","title":"Rarefaction and Coverage","text":"<p>Rarefaction curves show whether you've sequenced deeply enough:</p> <pre><code># Conceptual rarefaction curve\nfrom matplotlib import pyplot as plt\n\nreads = [1M, 5M, 10M, 20M, 50M, 100M]\nnew_viruses = [100, 250, 350, 425, 475, 490]\n\nplt.plot(reads, new_viruses)\nplt.xlabel(\"Sequencing Depth (reads)\")\nplt.ylabel(\"Unique Viruses Detected\")\n</code></pre> <p>Interpretation: - Steep curve: Not saturated, more sequencing will find more viruses - Plateau: Saturated, additional sequencing has diminishing returns - No plateau: Extremely diverse, may never saturate (e.g., ocean viromes)</p>"},{"location":"fundamentals/sequencing-strategies/#paired-end-vs-single-end","title":"Paired-End vs. Single-End","text":""},{"location":"fundamentals/sequencing-strategies/#paired-end-sequencing","title":"Paired-End Sequencing","text":"<p>Configuration: 2\u00d7150 bp, 2\u00d7250 bp (read pairs from both ends of DNA fragment)</p> <p>Advantages: - Improved assembly (scaffolding information) - Better repeat resolution - Detects structural variants - Higher confidence alignments - Useful for strain differentiation</p> <p>Limitations: - More expensive than single-end - Slightly lower total bases per run - Requires paired-end aware tools</p> <p>When to use: - De novo assembly - Comprehensive virome studies - When budget allows - Recommended for most virome projects</p>"},{"location":"fundamentals/sequencing-strategies/#single-end-sequencing","title":"Single-End Sequencing","text":"<p>Configuration: 1\u00d7150 bp, 1\u00d775 bp</p> <p>Advantages: - Lower cost per sample - More total bases per run - Sufficient for some applications - Faster library prep</p> <p>When to use: - Reference-based mapping only - Simple viral communities - Budget-constrained projects - Amplicon sequencing</p>"},{"location":"fundamentals/sequencing-strategies/#read-length-considerations","title":"Read Length Considerations","text":""},{"location":"fundamentals/sequencing-strategies/#short-reads-50-150-bp","title":"Short Reads (50-150 bp)","text":"<p>Pros: - Lower cost - Higher throughput - Established tools</p> <p>Cons: - Assembly challenges - Poor repeat resolution - Limited for complex genomes</p> <p>Use for: - Reference mapping - Read-based classification (Kraken, Kaiju) - Cost-effective screening</p>"},{"location":"fundamentals/sequencing-strategies/#medium-reads-150-300-bp","title":"Medium Reads (150-300 bp)","text":"<p>Pros: - Balance of cost and assembly quality - Good for most viruses - Paired-end overlap possible</p> <p>Cons: - Still challenging for repeats - Assembly not as contiguous as long reads</p> <p>Use for: - Standard virome analysis (most common) - Good assembly with paired-end - Versatile for many applications</p>"},{"location":"fundamentals/sequencing-strategies/#long-reads-10-kb","title":"Long Reads (&gt;10 kb)","text":"<p>Pros: - Complete viral genomes - Resolve structural complexity - Less assembly ambiguity</p> <p>Cons: - Higher cost - Lower throughput - More input DNA needed</p> <p>Use for: - Novel virus characterization - Structural variation studies - Prophage architecture - Host-phage linkages</p>"},{"location":"fundamentals/sequencing-strategies/#hybrid-sequencing-approaches","title":"Hybrid Sequencing Approaches","text":""},{"location":"fundamentals/sequencing-strategies/#illumina-pacbionanopore","title":"Illumina + PacBio/Nanopore","text":"<p>Strategy: Use long reads for assembly scaffolding, short reads for error correction.</p> <p>Workflow: <pre><code>1. Sequence with long reads (PacBio/Nanopore)\n2. Assemble long reads into contigs\n3. Sequence same sample with Illumina (high coverage)\n4. Polish long-read assembly with Illumina reads\n5. Result: Long contigs with high accuracy\n</code></pre></p> <p>Advantages: - Best of both worlds: length + accuracy - Cost-effective compromise - Resolves complex structures accurately</p> <p>Limitations: - Two library preps required - More computational analysis - Higher overall cost</p> <p>When to use: - Important novel viruses needing complete genomes - Prophage characterization - Research projects with sufficient budget - Structural variation studies</p>"},{"location":"fundamentals/sequencing-strategies/#adaptivetargeted-sequencing","title":"Adaptive/Targeted Sequencing","text":"<p>Nanopore-specific feature: Real-time sequence analysis and selective sequencing.</p> <p>Applications: - Enrich for specific viral sequences during run - Deplete abundant contaminants (host, bacteria) - Focus sequencing on target viruses</p> <p>Example workflow: <pre><code>1. Start sequencing run\n2. Real-time basecalling identifies sequences\n3. Reject reads matching host/bacterial references\n4. Continue sequencing viral reads only\n5. Result: Enriched viral dataset\n</code></pre></p>"},{"location":"fundamentals/sequencing-strategies/#sample-multiplexing-and-barcoding","title":"Sample Multiplexing and Barcoding","text":""},{"location":"fundamentals/sequencing-strategies/#when-to-multiplex","title":"When to Multiplex?","text":"<p>Advantages: - Reduce cost per sample - Increase throughput - Efficient use of sequencing capacity</p> <p>Considerations: - Need enough reads per sample after demultiplexing - Barcode loss can occur (typically 1-5%) - Multiplexing level depends on viral complexity</p>"},{"location":"fundamentals/sequencing-strategies/#multiplexing-guidelines","title":"Multiplexing Guidelines","text":"Sample Complexity Platform Reads Needed/Sample Max Multiplexing Low (isolates) Illumina MiSeq 5-10M 10-20 samples Medium (gut) Illumina NextSeq 20-50M 8-16 samples High (soil, ocean) Illumina NovaSeq 50-200M 20-40 samples <p>Example: - NovaSeq S4 flow cell: ~3-4 billion reads - Target 50M reads per sample - Can multiplex 60-80 samples - Account for 10-20% loss to QC and host filtering</p>"},{"location":"fundamentals/sequencing-strategies/#barcoding-strategies","title":"Barcoding Strategies","text":"<p>Dual indexing (recommended): - Reduces barcode hopping/cross-contamination - Two barcodes per sample (i5 and i7 adapters) - Critical for high-plex runs</p> <p>Unique molecular identifiers (UMIs): - Tag individual molecules before amplification - Remove PCR duplicates computationally - Important for low-input samples with many PCR cycles - Enables accurate quantification</p>"},{"location":"fundamentals/sequencing-strategies/#cost-considerations","title":"Cost Considerations","text":""},{"location":"fundamentals/sequencing-strategies/#per-sample-cost-estimates-2025","title":"Per-Sample Cost Estimates (2025)","text":"Strategy Platform Cost/Sample Notes Basic virome Illumina (10M reads) $50-150 Multiplexed, 2\u00d7150 bp Standard virome Illumina (50M reads) $150-300 Good for most studies Deep virome Illumina (200M reads) $300-600 High diversity samples Complete genomes PacBio HiFi $500-2000 Isolates or low complexity Rapid outbreak Nanopore MinION $100-500 Lower depth, fast results <p>Cost-saving strategies: - Multiplex aggressively for simple samples - Use amplicon sequencing for screening - Reserve deep sequencing for high-priority samples - Pilot with small-scale sequencing first - Use appropriate depth (don't over-sequence)</p>"},{"location":"fundamentals/sequencing-strategies/#special-considerations","title":"Special Considerations","text":""},{"location":"fundamentals/sequencing-strategies/#metagenome-vs-virome-sequencing","title":"Metagenome vs. Virome Sequencing","text":"<p>Metagenome (total community DNA): - Pros: Captures prophages, maintains host context - Cons: Mostly non-viral reads (&gt;90% bacteria/eukarya in unenriched) - When: Studying prophages, have high sequencing budget</p> <p>Enriched virome (VLP-prepared): - Pros: Enriched viral signal, more cost-effective - Cons: Misses prophages, sample prep complexity - When: Standard virome studies, focus on free viruses</p>"},{"location":"fundamentals/sequencing-strategies/#quantitative-vs-qualitative","title":"Quantitative vs. Qualitative","text":"<p>For quantitative analysis (accurate viral abundances): - Avoid or minimize amplification (MDA/PCR biases) - Use spike-ins for normalization - Deep, even coverage - Careful library prep (minimal PCR cycles)</p> <p>For qualitative analysis (presence/absence, diversity): - Amplification acceptable - Lower depth may suffice - Focus on maximizing virus recovery</p>"},{"location":"fundamentals/sequencing-strategies/#time-series-and-longitudinal-studies","title":"Time-Series and Longitudinal Studies","text":"<p>Considerations: - Consistent sample prep across timepoints - Batch effects (sequence all together if possible) - Sufficient depth to detect changes (50M+ reads) - Technical replicates for key timepoints - Spike-in controls for cross-timepoint comparison</p>"},{"location":"fundamentals/sequencing-strategies/#decision-tree-choosing-your-strategy","title":"Decision Tree: Choosing Your Strategy","text":"graph TD     A[Research Question] --&gt; B{Complete genomes needed?}     B --&gt;|Yes| C{Budget allows?}     C --&gt;|Yes| D[PacBio HiFi or Hybrid]     C --&gt;|No| E[Illumina deep sequencing]     B --&gt;|No| F{Diversity study?}     F --&gt;|Yes| G[Illumina 2x150, 20-50M reads]     F --&gt;|No| H{Targeted group?}     H --&gt;|Yes| I[Amplicon sequencing]     H --&gt;|No| J[Standard Illumina virome]"},{"location":"fundamentals/sequencing-strategies/#recommended-strategies-by-study-type","title":"Recommended Strategies by Study Type","text":""},{"location":"fundamentals/sequencing-strategies/#study-type-1-exploratory-virome-diversity","title":"Study Type 1: Exploratory Virome Diversity","text":"<p>Goal: Characterize viral community, compare between samples</p> <p>Recommended: - Platform: Illumina - Configuration: 2\u00d7150 bp paired-end - Depth: 20-50M reads per sample - Multiplexing: 10-20 samples per run (NextSeq) - Library: Standard shotgun metagenomics - Sample prep: VLP enrichment + DNase</p>"},{"location":"fundamentals/sequencing-strategies/#study-type-2-novel-virus-discovery","title":"Study Type 2: Novel Virus Discovery","text":"<p>Goal: Complete genomes of unknown viruses</p> <p>Recommended: - Platform: PacBio HiFi or Hybrid (PacBio + Illumina) - Configuration: PacBio 15-20kb HiFi, Illumina 2\u00d7250bp - Depth: 20-50 Gb PacBio, 100M reads Illumina - Library: Shotgun for both platforms - Sample prep: Enriched virome or isolate culture</p>"},{"location":"fundamentals/sequencing-strategies/#study-type-3-outbreak-investigation","title":"Study Type 3: Outbreak Investigation","text":"<p>Goal: Rapid identification of pathogenic viruses</p> <p>Recommended: - Platform: Nanopore MinION or Illumina MiSeq - Configuration: Nanopore long reads or 2\u00d7150 bp - Depth: 5-20M reads - Turnaround: &lt;24 hours possible with Nanopore - Library: Rapid library prep kits - Analysis: Real-time for Nanopore</p>"},{"location":"fundamentals/sequencing-strategies/#study-type-4-large-scale-epidemiology","title":"Study Type 4: Large-Scale Epidemiology","text":"<p>Goal: Screen hundreds of samples for specific viruses</p> <p>Recommended: - Platform: Illumina NovaSeq - Configuration: 2\u00d7150 bp or amplicon approach - Depth: 5-10M reads per sample (or less for amplicons) - Multiplexing: 100+ samples per run - Library: Amplicon (if targeting specific viruses) or shotgun - Sample prep: Minimal processing for cost efficiency</p>"},{"location":"fundamentals/sequencing-strategies/#next-steps","title":"Next Steps","text":"<ul> <li>Complete Tutorials - Follow step-by-step sequencing workflows</li> <li>Tool Selection Guide - Choose analysis tools</li> <li>Best Practices - Ensure high-quality results</li> </ul>"},{"location":"fundamentals/sequencing-strategies/#further-reading","title":"Further Reading","text":"<ul> <li>Warwick-Dugdale, J., et al. (2019). \"Long-read viral metagenomics captures abundant and microdiverse viral populations.\" PeerJ, 7, e6800.</li> <li>Roux, S., et al. (2016). \"Towards quantitative viromics for both double-stranded and single-stranded DNA viruses.\" PeerJ, 4, e2777.</li> <li>Garalde, D. R., et al. (2018). \"Highly parallel direct RNA sequencing on an array of nanopores.\" Nature Methods, 15(3), 201-206.</li> </ul>"},{"location":"intro/","title":"Introduction to Awesome-Virome","text":"<p>Last Updated: November 29, 2025</p> <p>Welcome to the official documentation for Awesome-Virome, a curated list of software, tools, and databases useful for virome analysis, including phages, viruses, and their interactions with hosts.</p>"},{"location":"intro/#what-is-virome-analysis","title":"What is Virome Analysis?","text":"<p>Virome analysis involves studying the collection of viruses (including bacteriophages) in a specific environment such as the human gut, soil, or oceans. These analyses typically include:</p> <ol> <li>Identifying viral sequences in metagenomic data</li> <li>Classifying viruses and predicting their hosts</li> <li>Assembling and annotating viral genomes</li> <li>Analyzing viral diversity and evolution</li> <li>Studying virus-host interactions and functional potential</li> </ol>"},{"location":"intro/#how-to-use-this-documentation","title":"How to Use This Documentation","text":"<p>This documentation is organized into several sections:</p> <ul> <li>Getting Started: Basic information about virome analysis and how to use this repository</li> <li>Tools: Detailed information about the tools included in Awesome-Virome</li> <li>API Reference: Documentation for the programmatic API</li> <li>Contributing: Guidelines for contributing to Awesome-Virome</li> </ul> <p>You can navigate through the documentation using the navigation bar. If you're looking for a specific tool or topic, you can use the search function at the top of the page.</p>"},{"location":"intro/#key-features","title":"Key Features","text":"<p>Awesome-Virome offers several unique features that enhance its value as a resource for the viral bioinformatics community:</p>"},{"location":"intro/#interactive-visualizations","title":"Interactive Visualizations","text":"<ul> <li>Dynamic network graph showing tool relationships and connections</li> <li>Interactive dashboard with filterable tool comparisons</li> <li>Tool categorization treemap for understanding the ecosystem</li> <li>Timeline visualization showing field development over time</li> </ul>"},{"location":"intro/#enhanced-metadata-collection","title":"Enhanced Metadata Collection","text":"<ul> <li>Automated metadata enrichment from GitHub, GitLab and Bitbucket</li> <li>Detailed repository statistics including stars, forks, and languages</li> <li>License information and release history tracking</li> <li>Programming language distribution analysis</li> </ul>"},{"location":"intro/#community-contributions","title":"Community Contributions","text":"<ul> <li>Standardized issue templates for tool additions and updates</li> <li>Automated workflows for data validation and site health checks</li> <li>Detailed contribution guidelines for consistent data entry</li> <li>Regular updates to ensure tool information remains current</li> </ul>"},{"location":"intro/#data-access-options","title":"Data Access Options","text":"<ul> <li>Web interface for browsing and searching tools</li> <li>Interactive dashboard for visual exploration</li> <li>RESTful API for programmatic access</li> <li>Markdown files for simple text-based access</li> </ul>"},{"location":"intro/#popular-virome-analysis-tools","title":"Popular Virome Analysis Tools","text":"<p>Top tools ranked by GitHub stars and community adoption:</p> <ol> <li>metaviralSPAdes - \u2b50 803 stars - Viral genome assembler for metagenomic data</li> <li>DRAMv - \u2b50 270 stars - Distilled and Refined Annotation of Metabolism for viruses</li> <li>geNomad - \u2b50 226 stars - Identify viruses and plasmids in sequencing data</li> <li>Viral-NGS - \u2b50 192 stars - Viral genomics analysis pipelines</li> <li>VIBRANT - \u2b50 160 stars - Virus Identification By iteRative ANnoTation</li> <li>Pharokka - \u2b50 160 stars - Fast phage annotation tool</li> </ol>"},{"location":"intro/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Typical Workflows page to learn how to use the tools in Awesome-Virome</li> <li>Explore the Interactive Dashboard to visualize the tool ecosystem</li> <li>Browse the Tools section to find tools for your specific needs</li> </ul>"},{"location":"intro/versioning/","title":"Documentation Versioning","text":"<p>Awesome-Virome documentation uses versioning to maintain documentation for different versions of the project. This page explains how versioning works and how to navigate between different versions.</p>"},{"location":"intro/versioning/#why-version-documentation","title":"Why Version Documentation?","text":"<p>Documentation versioning provides several benefits:</p> <ol> <li>Historical accuracy: Users can access documentation that corresponds to the specific version of the project they're using</li> <li>Backward compatibility: Changes or new features don't break documentation for users on older versions</li> <li>Upgrade planning: Users can see what's changed between versions before upgrading</li> <li>Feature exploration: Users can preview upcoming features in the latest version</li> </ol>"},{"location":"intro/versioning/#how-versioning-works","title":"How Versioning Works","text":"<p>The Awesome-Virome documentation is organized into versioned snapshots:</p> <ul> <li>Latest (Unreleased): Contains the most up-to-date documentation, including features not yet released</li> <li>Versioned Releases: Snapshots of documentation corresponding to specific project releases (e.g., 1.0.0)</li> </ul>"},{"location":"intro/versioning/#navigating-between-versions","title":"Navigating Between Versions","text":"<p>You can easily switch between documentation versions using the version selector in the header. The version selector shows all available versions of the documentation.</p>"},{"location":"intro/versioning/#current-versions","title":"Current Versions","text":"Version Release Date Description Latest Unreleased Most up-to-date documentation, including unreleased features 1.0.0 May 3, 2025 Initial version of the comprehensive documentation"},{"location":"intro/versioning/#version-specific-features","title":"Version-Specific Features","text":"<p>Each version may have different documentation features:</p>"},{"location":"intro/versioning/#latest-unreleased","title":"Latest (Unreleased)","text":"<ul> <li>Complete Tool Selection Guide</li> <li>Updated API endpoints</li> <li>Additional workflow examples</li> </ul>"},{"location":"intro/versioning/#100","title":"1.0.0","text":"<ul> <li>Initial comprehensive documentation</li> <li>Core tool references</li> <li>Basic API documentation</li> <li>Contribution guidelines</li> </ul>"},{"location":"intro/versioning/#contributing-to-documentation","title":"Contributing to Documentation","text":"<p>When contributing to the documentation, your changes will be applied to the latest (unreleased) version. When a new version is released, a snapshot of the current state will be created as a new versioned documentation set.</p> <p>See the contribution guidelines for more information on how to contribute to the documentation.</p>"},{"location":"intro/workflows/","title":"Typical Virome Analysis Workflows","text":"<p>Last Updated: November 29, 2025</p> <p>This page outlines common workflows for virome analysis, showcasing how different tools from the Awesome-Virome collection can be combined to achieve specific research goals.</p> <p>Important Note on Workflows</p> <p>These workflows represent common approaches but should be adapted to your specific research questions and sample types. Always validate results and consider running multiple tools for critical analyses.</p>"},{"location":"intro/workflows/#basic-virome-analysis-workflow","title":"Basic Virome Analysis Workflow","text":"<p>For general metagenomic virome analysis, this basic workflow provides a solid foundation:</p> Raw Sequencing Data \u2192 Quality Control \u2192 Assembly \u2192 Viral Contig Identification Functional Annotation \u2190 Host Prediction \u2190 Taxonomic Classification \u2190 Quality Assessment"},{"location":"intro/workflows/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li>Quality Control of Metagenomic Reads <ul> <li>Tools: Standard bioinformatics QC tools (Trimmomatic, FastQC, etc.)</li> <li>Purpose: Remove low-quality reads, adapters, and contaminants</li> </ul> </li> <li>Assembly of Contigs <ul> <li>Tools: SPAdes, MEGAHIT</li> <li>Purpose: Assemble short reads into longer contiguous sequences (contigs)</li> </ul> </li> <li>Identification of Viral Contigs <ul> <li>Tools: VirSorter2, VIBRANT, geNomad</li> <li>Purpose: Identify which contigs are of viral origin</li> </ul> </li> <li>Quality Assessment <ul> <li>Tools: CheckV</li> <li>Purpose: Assess the completeness and quality of viral genomes</li> </ul> </li> <li>Taxonomic Classification <ul> <li>Tools: vConTACT2, PhaGCN</li> <li>Purpose: Assign taxonomy to viral sequences</li> </ul> </li> <li>Host Prediction <ul> <li>Tools: iPHoP, CHERRY</li> <li>Purpose: Predict the bacterial hosts of phages</li> </ul> </li> <li>Functional Annotation <ul> <li>Tools: Pharokka, DRAMv</li> <li>Purpose: Annotate genes and predict functions</li> </ul> </li> </ol>"},{"location":"intro/workflows/#rna-virus-discovery-workflow","title":"RNA Virus Discovery Workflow","text":"<p>For specifically focusing on RNA viruses in your samples:</p> Raw RNA-Seq Data \u2192 Quality Control \u2192 Assembly \u2192 RdRp Search Phylogenetic Analysis \u2190 Genome Annotation \u2190 RNA Virus Verification"},{"location":"intro/workflows/#key-tools-for-rna-virus-analysis","title":"Key Tools for RNA Virus Analysis","text":"<ol> <li>RNA Virus Detection <ul> <li>Tools: palmID, RdRp-scan, metaviralSPAdes-RNA</li> <li>Purpose: Identify RNA virus sequences by detecting conserved RdRp domains</li> </ul> </li> <li>RNA Virus Annotation <ul> <li>Tools: VirMine-RNA</li> <li>Purpose: Functional annotation specific to RNA viral genomes</li> </ul> </li> </ol>"},{"location":"intro/workflows/#prophage-identification-workflow","title":"Prophage Identification Workflow","text":"<p>For identifying integrated prophages in bacterial genomes:</p> Bacterial Genome \u2192 Prophage Detection \u2192 Prophage Excision Host-Prophage Interaction Analysis \u2190 Prophage Annotation \u2190 Prophage Verification"},{"location":"intro/workflows/#key-tools-for-prophage-analysis","title":"Key Tools for Prophage Analysis","text":"<ol> <li>Prophage Detection <ul> <li>Tools: PhiSpy, Phigaro, PHASTER</li> <li>Purpose: Identify integrated viral sequences within bacterial genomes</li> </ul> </li> <li>Prophage Analysis <ul> <li>Tools: viralintegration, hafeZ</li> <li>Purpose: Analyze integration sites and characterize prophage regions</li> </ul> </li> </ol>"},{"location":"intro/workflows/#advanced-workflows","title":"Advanced Workflows","text":"<p>These more specialized workflows address specific research questions:</p>"},{"location":"intro/workflows/#viral-quasispecies-analysis","title":"Viral Quasispecies Analysis","text":"<p>For analyzing viral population diversity within a sample:</p> <ol> <li>Strain Reconstruction <ul> <li>Tools: VStrains, COBRA</li> <li>Purpose: Reconstruct individual viral strains from complex metagenomic samples</li> </ul> </li> <li>Quasispecies Analysis <ul> <li>Tools: ShoRAH, CliqueSNV</li> <li>Purpose: Analyze genetic variation and population dynamics within viral communities</li> </ul> </li> </ol>"},{"location":"intro/workflows/#virome-host-interaction-analysis","title":"Virome-Host Interaction Analysis","text":"<p>For studying how viruses interact with their hosts:</p> <ol> <li>CRISPR Analysis <ul> <li>Tools: SpacePHARER, CrisprOpenDB</li> <li>Purpose: Identify CRISPR spacers and predict virus-host relationships</li> </ul> </li> <li>Protein-Protein Interactions <ul> <li>Tools: DeepVHPPI</li> <li>Purpose: Predict interactions between viral and host proteins</li> </ul> </li> </ol>"},{"location":"intro/workflows/#recommended-tools-by-category","title":"Recommended Tools by Category","text":"<p>For newcomers to virome analysis, here are some recommended starting points:</p> <ol> <li>Viral identification <ul> <li>Tools: VirSorter2, VIBRANT, geNomad</li> <li>Difficulty: Beginner to Intermediate</li> <li>Computational requirements: Moderate</li> </ul> </li> <li>Host prediction <ul> <li>Tools: iPHoP, CHERRY</li> <li>Difficulty: Intermediate</li> <li>Computational requirements: Moderate to High</li> </ul> </li> <li>Genome annotation <ul> <li>Tools: Pharokka, DRAMv</li> <li>Difficulty: Beginner</li> <li>Computational requirements: Low to Moderate</li> </ul> </li> <li>Taxonomy assignment <ul> <li>Tools: vConTACT2, PhaGCN</li> <li>Difficulty: Intermediate</li> <li>Computational requirements: Moderate</li> </ul> </li> <li>Quality control <ul> <li>Tools: CheckV</li> <li>Difficulty: Beginner</li> <li>Computational requirements: Low</li> </ul> </li> </ol>"},{"location":"intro/workflows/#next-steps","title":"Next Steps","text":"<ol> <li>Explore Tools <ul> <li>Visit the Tools Overview section for detailed information about each tool</li> <li>Check the Selection Guide to find the best tools for your specific needs</li> </ul> </li> <li>Learn About Data Access <ul> <li>Review the API Reference to learn how to access the Awesome-Virome database programmatically</li> <li>See API Examples for code snippets in Python, R, and JavaScript</li> </ul> </li> <li>Join the Community <ul> <li>Contribute to the project by following our Contribution Guidelines</li> <li>Explore the GitHub repository for the latest updates</li> </ul> </li> </ol>"},{"location":"tools/host-prediction/","title":"Host Prediction Tools","text":"<p>Last Updated: November 29, 2025</p> <p>Host prediction tools help determine the bacterial hosts of viral sequences, particularly phages. This is crucial for understanding phage-host interactions, designing phage therapy, and interpreting the role of phages in microbial communities.</p> <p>Reality Check: Host Prediction Accuracy</p> <p>Host prediction is one of the most challenging problems in virome analysis. Current computational tools have significant limitations:</p> <ul> <li>Real-world accuracy: Typically 30-60% at genus level for novel viruses (not the 75-80% often cited from benchmarks on known viruses)</li> <li>Many predictions fail: 20-40% of viral sequences may get no confident prediction</li> <li>Predictions are hypotheses: Always treat them as computational predictions requiring validation, not ground truth</li> <li>Method-dependent: Different tools can give conflicting predictions for the same sequence</li> </ul> <p>Best practices: - Use multiple prediction methods and look for consensus - Higher confidence when multiple lines of evidence agree (sequence homology + CRISPR spacers + co-occurrence data) - CRISPR spacer matches are the \"gold standard\" but only available for ~1-5% of viruses - Consider biological context (sample environment, known host distributions) - Validate computationally important predictions experimentally when possible</p>"},{"location":"tools/host-prediction/#key-host-prediction-tools","title":"Key Host Prediction Tools","text":""},{"location":"tools/host-prediction/#iphop","title":"iPHoP","text":"<p>iPHoP (Integrated Prediction of Host and Phage) is a state-of-the-art tool for predicting phage-host interactions at various taxonomic levels.</p> <ul> <li>Version: v1.3.3, 2023</li> <li>Installation: <code>conda install -c bioconda iphop</code></li> <li>GitHub Stars: Hosted on Bitbucket</li> <li>Key Features:</li> <li>Integrates multiple prediction methods</li> <li>Assigns confidence scores to predictions</li> <li>Works at multiple taxonomic levels</li> <li>Pre-trained with a comprehensive database</li> <li>Optimized for metagenomic data</li> </ul> <p>Usage Example: <pre><code>iphop predict --fa_file input_phages.fasta --out_dir iphop_results\n</code></pre></p>"},{"location":"tools/host-prediction/#cherry","title":"CHERRY","text":"<p>CHERRY (v1.0, 2022) uses deep learning for phage host prediction.</p> <ul> <li>GitHub Stars: \u2b50 24</li> <li>Installation: <code>git clone https://github.com/KennthShang/CHERRY.git</code></li> <li>Key Features:</li> <li>Uses deep learning (CNN and LSTM)</li> <li>Pre-trained with thousands of phage-host pairs</li> <li>Works well with novel phages</li> <li>Can make predictions at different taxonomic levels</li> </ul> <p>How It Works: CHERRY uses a combination of convolutional neural networks and LSTM to learn sequence patterns indicative of phage-host interactions.</p>"},{"location":"tools/host-prediction/#virhostmatcher-net","title":"VirHostMatcher-Net","text":"<p>VirHostMatcher-Net is a network-based virus-host prediction tool.</p> <ul> <li>GitHub Stars: \u2b50 21</li> <li>Key Features:</li> <li>Uses both oligonucleotide frequencies and protein alignment</li> <li>Incorporates network-based information</li> <li>Achieves high accuracy at genus level</li> <li>Works well with novel viruses</li> </ul>"},{"location":"tools/host-prediction/#wish","title":"WIsH","text":"<p>WIsH (Who Is the Host) predicts phage-host interactions using genome homology.</p> <ul> <li>Key Features:</li> <li>Uses Markov models of genomic composition</li> <li>Fast and lightweight</li> <li>Good performance on well-characterized host taxa</li> <li>Works well with complete genomes</li> </ul>"},{"location":"tools/host-prediction/#additional-host-prediction-tools","title":"Additional Host Prediction Tools","text":""},{"location":"tools/host-prediction/#host-prediction-based-on-sequence-similarity","title":"Host Prediction Based on Sequence Similarity","text":"<ul> <li>HostPhinder: K-mer based phage host prediction</li> <li>PHP: Phage host prediction tool</li> <li>PHPGCA: Similarity graphs for phage-host prediction</li> </ul>"},{"location":"tools/host-prediction/#host-prediction-based-on-crispr-spacers","title":"Host Prediction Based on CRISPR Spacers","text":"<ul> <li>CrisprOpenDB: CRISPR spacer database for phage-host prediction</li> <li>SpacePHARER: CRISPR spacer phage-host pair finder</li> </ul>"},{"location":"tools/host-prediction/#host-prediction-based-on-machine-learning","title":"Host Prediction Based on Machine Learning","text":"<ul> <li>DeepHost: CNN for phage host prediction</li> <li>HostG: Graph convolutional network for phage host prediction</li> <li>PhageHostLearn: Machine learning for phage-host prediction</li> </ul>"},{"location":"tools/host-prediction/#comparison-table","title":"Comparison Table","text":"Tool Method Taxonomic Level Strengths Limitations iPHoP Integrated Kingdom to Strain Combines multiple methods, high accuracy Resource intensive CHERRY Deep Learning Genus, Species Works well with novel phages Needs substantial computing power VirHostMatcher-Net Network-based Genus Good accuracy at genus level Limited to specific host taxa WIsH Markov Models Species Fast, lightweight Better with complete genomes HostPhinder K-mer Species Simple, efficient Limited to known hosts CrisprOpenDB CRISPR spacers Strain High specificity Limited coverage"},{"location":"tools/host-prediction/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Understanding Benchmark Numbers</p> <p>The performance metrics below are from controlled benchmark studies on test datasets with known virus-host pairs. Real-world performance on novel environmental viruses is typically 20-40% lower.</p> <p>Benchmark studies often: - Use viruses with known hosts (easier than novel viruses) - Test on sequences similar to training data - Exclude difficult cases - Report best-case accuracy</p> <p>For your research: Expect genus-level accuracy of 30-60% on novel viruses, not 75-80%.</p> <p>Based on published benchmarks (test datasets with known hosts):</p> <ul> <li>Genus level prediction (benchmark datasets):</li> <li>VirHostMatcher-Net: ~75-80% (novel viruses: ~40-50%)</li> <li>iPHoP: ~70-75% (novel viruses: ~45-55%)</li> <li> <p>CHERRY: ~65-70% (novel viruses: ~35-45%)</p> </li> <li> <p>Species level prediction (benchmark datasets):</p> </li> <li>iPHoP: ~60-65% (novel viruses: ~30-40%)</li> <li>CHERRY: ~55-60% (novel viruses: ~25-35%)</li> <li>WIsH: ~50-55% (novel viruses: ~25-30%)</li> </ul> <p>Performance depends on: viral genome completeness, taxonomic coverage of reference databases, host diversity in training data, and sequence similarity to known virus-host pairs.</p>"},{"location":"tools/host-prediction/#recommended-workflow","title":"Recommended Workflow","text":"<p>For optimal host prediction results, we recommend a multi-tool approach:</p> <ol> <li>Start with iPHoP:</li> <li>Comprehensive predictions with confidence scores</li> <li> <p>Good starting point for most analyses</p> </li> <li> <p>Complement with specialized tools:</p> </li> <li>For well-studied hosts: WIsH and HostPhinder</li> <li>For novel phages: CHERRY and VirHostMatcher-Net</li> <li> <p>If CRISPR data is available: CrisprOpenDB and SpacePHARER</p> </li> <li> <p>Consensus approach:</p> </li> <li>Take predictions agreed upon by multiple methods</li> <li>Weight predictions by confidence scores when available</li> <li>Consider biological context (e.g., environment of isolation)</li> </ol>"},{"location":"tools/host-prediction/#future-directions","title":"Future Directions","text":"<p>The field of phage host prediction is rapidly evolving:</p> <ul> <li>Integration of metagenomic co-occurrence data</li> <li>Improved deep learning models</li> <li>Single-cell and spatial information integration</li> <li>Expanded reference databases</li> </ul>"},{"location":"tools/host-prediction/#further-reading","title":"Further Reading","text":"<ul> <li>Benchmarking phage-host prediction tools</li> <li>Computational approaches for phage host prediction</li> <li>Challenges in phage-host prediction</li> </ul>"},{"location":"tools/overview/","title":"Virome Analysis Tools","text":"<p>Last Updated: November 29, 2025</p> <p>Awesome-Virome contains a comprehensive collection of tools for various aspects of virome analysis. This page provides an overview of the tool categories and helps you navigate to the specific tools you need.</p>"},{"location":"tools/overview/#tool-categories","title":"Tool Categories","text":"<p>The tools are organized into the following main categories:</p> Category Description Key Tools Virus and Phage Identification Tools for identifying viral sequences in metagenomic data VirSorter2, VIBRANT, geNomad Host Prediction Tools for predicting the bacterial hosts of phages iPHoP, CHERRY, WIsH Genome Analysis Tools for assembling, annotating, and analyzing viral genomes Pharokka, DRAMv, MetaProdigal Taxonomy Tools for taxonomic classification of viral sequences vConTACT2, PhaGCN, VIPtree Databases Reference databases for viral sequences NCBI RefSeq, ICTV VMR, pVOGs Functional Analysis Tools for functional annotation and analysis BACPHLIP, PHACTS, PHROGs Sequence Analysis Tools for sequence alignment and translation ViralMSA, pygenetic_code Specialized Analysis Tools for specific types of analysis DeepVHPPI, vAMPirus, SpacePHARER"},{"location":"tools/overview/#virus-and-phage-identification","title":"Virus and Phage Identification","text":"<p>Tools for identifying viral sequences in metagenomic data:</p>"},{"location":"tools/overview/#metagenome-analysis","title":"Metagenome Analysis","text":"<ul> <li>VirSorter2 - Random forest classifier for virus detection</li> <li>VIBRANT - Virus identification by combining boundary detection with annotation</li> <li>geNomad - Tool for identifying viral sequences, including proviruses</li> <li>DeepVirFinder - Neural network approach for viral contig identification</li> </ul>"},{"location":"tools/overview/#integrated-viruses","title":"Integrated Viruses","text":"<ul> <li>PhiSpy - Prophage identification combining similarity and composition-based approaches</li> <li>Phigaro - Prophage prediction tool</li> <li>viralintegration - Nextflow pipeline for detecting viral integration sites</li> </ul>"},{"location":"tools/overview/#rna-virus-identification","title":"RNA Virus Identification","text":"<ul> <li>palmID - RNA virus RdRp search tool with R interface</li> <li>RdRp-scan - Search against the RdRp database</li> <li>metaviralSPAdes-RNA - RNA virus detection module</li> </ul>"},{"location":"tools/overview/#host-prediction","title":"Host Prediction","text":"<p>Tools for predicting the bacterial hosts of phages:</p> <ul> <li>iPHoP - Integrated approach for phage host prediction</li> <li>CHERRY - Deep learning for phage host prediction</li> <li>VirHostMatcher-Net - Network-based virus-host prediction</li> <li>WIsH - Phage-host prediction using genome homology</li> </ul>"},{"location":"tools/overview/#genome-analysis","title":"Genome Analysis","text":"<p>Tools for assembling, annotating, and analyzing viral genomes:</p>"},{"location":"tools/overview/#genome-annotation","title":"Genome Annotation","text":"<ul> <li>Pharokka - Rapid phage annotation tool</li> <li>DRAMv - Distilling and refining annotation of metabolism for phages</li> </ul>"},{"location":"tools/overview/#genome-assembly","title":"Genome Assembly","text":"<ul> <li>metaviralSPAdes - Assembler for viruses from metagenomic data</li> <li>coronaSPAdes - HMM-synteny guided assembly for all viruses</li> </ul>"},{"location":"tools/overview/#genome-completeness","title":"Genome Completeness","text":"<ul> <li>CheckV - Quality assessment for viral genomes</li> <li>viralComplete - Tool for checking viral genome completeness</li> </ul>"},{"location":"tools/overview/#taxonomy","title":"Taxonomy","text":"<p>Tools for taxonomic classification of viral sequences:</p> <ul> <li>vConTACT2 - Viral taxonomy based on protein clusters</li> <li>PhaGCN - Graph convolutional network for phage taxonomy</li> <li>VIPtree - Viral proteomic tree-based classification</li> <li>ViPTree - Viral genome-based phylogenetic tree construction</li> </ul>"},{"location":"tools/overview/#databases","title":"Databases","text":"<p>Reference databases for viral sequences:</p> <ul> <li>NCBI Viral RefSeq - Reference viral genomes</li> <li>ICTV VMR - ICTV Virus Metadata Resource</li> <li>pVOGs - Prokaryotic Virus Orthologous Groups</li> <li>IMG/VR - Integrated database of viral sequences from metagenomes</li> <li>PhagesDB - Database of mycobacteriophage genomics</li> </ul>"},{"location":"tools/overview/#functional-analysis","title":"Functional Analysis","text":"<p>Tools for functional annotation and analysis:</p> <ul> <li>BACPHLIP - Bacteriophage lifestyle prediction</li> <li>PHACTS - Phage Classification Tool Set</li> <li>PHROGs - Phage Orthologous Groups annotation</li> <li>pVOGS - Database for virus orthologous groups</li> <li>PhageTerm - Phage termini and packaging identification</li> </ul>"},{"location":"tools/overview/#sequence-analysis","title":"Sequence Analysis","text":"<p>Tools for sequence alignment and translation:</p> <ul> <li>ViralMSA - Reference-guided multiple sequence alignment for viral genomes</li> <li>pygenetic_code - Python package for genetic code manipulation</li> <li>VIGOR - Viral genome annotation</li> <li>VGAS - Viral genome annotation system</li> <li>VADR - Viral Annotation DefineR for sequence annotation</li> </ul>"},{"location":"tools/overview/#specialized-analysis","title":"Specialized Analysis","text":"<p>Tools for specific types of analysis:</p> <ul> <li>DeepVHPPI - Prediction of virus-host protein-protein interactions</li> <li>vAMPirus - Processing viral amplicon data</li> <li>SpacePHARER - CRISPR-Cas target prediction</li> <li>HoloVir - Viral diversity in metagenomic datasets</li> <li>VirSorter - Mining viral signals from microbial genomes</li> </ul>"},{"location":"tools/overview/#top-packages-by-category","title":"Top Packages by Category","text":"<p>Here are the most starred packages in key categories:</p>"},{"location":"tools/overview/#virus-and-phage-identification_1","title":"Virus and Phage Identification","text":"<ol> <li>BLAST+DIAMOND - \u2b50 1114 stars</li> <li>geNomad - \u2b50 219 stars</li> <li>VIBRANT - \u2b50 159 stars</li> </ol>"},{"location":"tools/overview/#host-prediction_1","title":"Host Prediction","text":"<ol> <li>CHERRY - \u2b50 24 stars</li> <li>VirHostMatcher-Net - \u2b50 21 stars</li> <li>DeepHost - \u2b50 17 stars</li> </ol>"},{"location":"tools/overview/#genome-analysis_1","title":"Genome Analysis","text":"<ol> <li>metaviralSPAdes - \u2b50 797 stars</li> <li>Prodigal/MetaProdigal - \u2b50 471 stars</li> <li>Pharokka - \u2b50 158 stars</li> </ol>"},{"location":"tools/overview/#tool-selection-guide","title":"Tool Selection Guide","text":"<p>Not sure which tool to use? Check out our Selection Guide to find the right tools for your specific research needs.</p>"},{"location":"tools/selection-guide/","title":"Tool Selection Guide","text":"<p>Last Updated: November 29, 2025</p> <p>This guide helps you choose the right tools for your virome analysis workflow based on your specific research questions and sample types.</p>"},{"location":"tools/selection-guide/#key-decision-factors","title":"Key Decision Factors","text":"<p>When selecting tools for virome analysis, consider these key factors:</p> <ol> <li>Research Objective - What is your primary research question?</li> <li>Sample Type - What environment does your sample come from?</li> <li>Computational Resources - What computing resources do you have available?</li> <li>Specific Requirements - Do you have special needs like sensitivity, runtime, or database dependencies?</li> </ol>"},{"location":"tools/selection-guide/#decision-flowchart","title":"Decision Flowchart","text":"Tool Selection Start \u2193 What is your primary objective? Virus Detection Identification Tools \u2193 Sample type? Metagenome: VirSorter2 VIBRANT geNomad Transcriptome: RNA-Virus-Flow RdRp-scan Single cell: scVIRseq scViroCap Host Prediction Host Prediction Tools \u2193 Host domain? Bacteria: WIsH iPHoP PHIST Eukaryotes: DeepHost VirHostMatcher-Net Genome Analysis Assembly: metaviralSPAdes metaPhage Annotation: Pharokka DRAMv Quality Check: CheckV viralComplete Classification Taxonomy: vConTACT2 PhaGCN VIPtree Function: BACPHLIP PHROGs"},{"location":"tools/selection-guide/#tool-selection-by-category","title":"Tool Selection by Category","text":""},{"location":"tools/selection-guide/#virus-identification","title":"Virus Identification","text":"Tool Strengths Limitations Best For VirSorter2 Sensitive, handles diverse viral sequences Computationally intensive Metagenomes with unknown viruses VIBRANT Integrated annotation, good visualization Limited to specific viral groups Phage-focused studies DeepVirFinder Works well on short contigs Requires GPU for best performance Fragmented assemblies Seeker Ultra-fast, works on reads Lower accuracy than contig-based tools Quick screening"},{"location":"tools/selection-guide/#host-prediction","title":"Host Prediction","text":"Tool Strengths Limitations Best For WIsH Fast, accurate for bacteria Requires reference genomes Phage-host studies iPHoP Multi-method approach Computationally intensive When accuracy is critical PHIST Simple k-mer based May miss distant relationships Quick screening VirHostMatcher-Net Works across domains Requires training Cross-domain studies"},{"location":"tools/selection-guide/#genome-assembly","title":"Genome Assembly","text":"Tool Strengths Limitations Best For metaviralSPAdes Specifically for viral metagenomes Memory intensive Complex viral communities metaPhage Optimized for phages Limited to phages Bacteriophage studies PHAMB Good for retrieving viral contigs Requires good depth Well-sequenced samples"},{"location":"tools/selection-guide/#computational-requirements","title":"Computational Requirements","text":"Resource Level Recommended Tools Low (Laptop) Seeker, PHIST, VirHostMatcher Medium (Workstation) VirSorter2, VIBRANT, WIsH High (Server/Cluster) metaviralSPAdes, iPHoP, PHAMB Cloud-optimized IDseq, CZ ID, Jovian"},{"location":"tools/selection-guide/#recent-additions-2024-2025","title":"Recent Additions (2024-2025)","text":"<p>These tools have been added recently and show promising results:</p> <ul> <li>DePhT - Novel approach to detect prophages with high accuracy</li> <li>GraViTy - Graph-based virus taxonomy assignment tool</li> <li>ViroProfiler - Integrated workflow for comprehensive virome profiling</li> <li>ViralWasm - Web Assembly tools for client-side viral analysis</li> <li>CHERRY - AI-based identification and classification of animal viruses</li> </ul>"},{"location":"tools/selection-guide/#version-compatibility","title":"Version Compatibility","text":"Tool Python Version Dependencies VirSorter2 3.6+ scikit-learn, Tensorflow VIBRANT 3.5+ scikit-learn, prodigal iPHoP 3.7+ mash, pytorch, diamond MetaviralSPAdes Any C++17 compiler Pharokka 3.8+ BLAST+, mash, prodigal"},{"location":"tools/selection-guide/#further-resources","title":"Further Resources","text":"<ul> <li>Check the GitHub repository for the most up-to-date tools and resources</li> <li>Explore our Tools Overview for a complete listing of all available tools</li> <li>Visit the Virus Identification and Host Prediction pages for more detailed information</li> </ul>"},{"location":"tools/virus-identification/","title":"Virus and Phage Identification Tools","text":"<p>Last Updated: November 29, 2025</p> <p>This section details tools for identifying viral sequences in metagenomic data, including tools for general metagenome analysis, integrated viruses (prophages), and RNA virus identification.</p> <p>Important: False Positives and Best Practices</p> <p>Viral identification tools can produce false positives! Cellular genes, mobile genetic elements, and other sequences may be incorrectly classified as viral. To minimize false positives:</p> <ul> <li>Use multiple tools: Run at least 2-3 different tools (e.g., VirSorter2 + VIBRANT + geNomad) and take consensus predictions</li> <li>Check confidence scores: Use appropriate score thresholds (see tool-specific guidance below)</li> <li>Validate with CheckV: Always run CheckV to assess genome quality and remove contamination</li> <li>Set minimum contig length: For metagenomes, use \u22655kb; for isolates, \u22651kb minimum</li> <li>Review results critically: Unexpected taxonomic assignments or unusual gene content may indicate false positives</li> </ul> <p>Remember: High sensitivity often comes with lower specificity. Adjust thresholds based on your research goals.</p>"},{"location":"tools/virus-identification/#metagenome-analysis","title":"Metagenome Analysis","text":"<p>Tools for identifying viral sequences in mixed metagenomic data:</p>"},{"location":"tools/virus-identification/#virsorter2","title":"VirSorter2","text":"<p>VirSorter2 is a multi-classifier, scalable pipeline for identifying viral sequences from diverse environments.</p> <ul> <li>Version: v2.2.4, 2023</li> <li>Installation: <code>conda install -c bioconda virsorter=2</code></li> <li>Language: Python</li> <li>Key Features:</li> <li>Random forest classifiers trained on diverse viral genomes</li> <li>Can detect novel viral sequences with limited homology to reference databases</li> <li>Scalable to large metagenomic datasets</li> <li>Improved sensitivity compared to the original VirSorter</li> </ul> <p>Usage Example: <pre><code>virsorter run -w output_dir -i input_contigs.fa --min-length 5000 --min-score 0.5 --include-groups dsDNAphage,ssDNA -j 4 all\n</code></pre></p> <p>Recommended Parameters: - <code>--min-length 5000</code>: Use \u22655kb for metagenomes to reduce false positives - <code>--min-score 0.5</code>: Default threshold (0.5-0.9 for high confidence) - <code>--include-groups</code>: Specify expected viral types to reduce search space - Consider <code>--keep-original-seq</code> to retain boundary information</p> <p>Score Interpretation: - \u22650.9: High confidence viral sequences - 0.5-0.9: Medium confidence (validate with other tools) - &lt;0.5: Low confidence (likely false positives)</p>"},{"location":"tools/virus-identification/#vibrant","title":"VIBRANT","text":"<p>VIBRANT (Virus Identification By iteRative ANnoTation) identifies viral contigs from metagenomic data.</p> <ul> <li>GitHub Stars: \u2b50 159</li> <li>Key Features:</li> <li>Combines boundary detection with annotation</li> <li>Identifies viruses without reliance on sequence similarity</li> <li>Includes metabolic and auxiliary gene annotation</li> <li>Can extract sequences directly from metagenomic assemblies</li> </ul> <p>How It Works: VIBRANT uses multiple neural networks to scan for viral signatures, identifies viral protein boundaries, and performs annotation for identified viral sequences.</p>"},{"location":"tools/virus-identification/#genomad","title":"geNomad","text":"<p>geNomad (v1.6.0, 2023) is a tool for identifying viral sequences, including integrated proviruses.</p> <ul> <li>GitHub Stars: \u2b50 219</li> <li>Key Features:</li> <li>Joint classification of viral and plasmid sequences</li> <li>Annotation of viral genes with protein families</li> <li>Extraction of genomic features</li> <li>Integrates both marker and gene content-based approaches</li> </ul>"},{"location":"tools/virus-identification/#deepvirfinder","title":"DeepVirFinder","text":"<p>DeepVirFinder uses deep learning to identify viral sequences in metagenomic data.</p> <ul> <li>Key Features:</li> <li>Neural network approach</li> <li>Trained on both prokaryotic and viral genomes</li> <li>Performs well on short contigs</li> <li>Works on novel viruses with limited similarity to references</li> </ul>"},{"location":"tools/virus-identification/#integrated-viruses","title":"Integrated Viruses","text":"<p>Tools specifically designed to identify prophages (viruses integrated into bacterial genomes):</p>"},{"location":"tools/virus-identification/#phispy","title":"PhiSpy","text":"<p>PhiSpy (v4.2.23, 2023) identifies prophages in bacterial genomes using a combination of similarity and composition-based approaches.</p> <ul> <li>Installation: <code>pip install phispy</code> or <code>conda install -c bioconda phispy</code></li> <li>Key Features:</li> <li>Identifies prophages in both complete and draft genomes</li> <li>Uses multiple measurements: GC skew, coding density, strand switching</li> <li>Combines similarity and composition-based features</li> <li>Outputs prophage coordinates and sequences</li> </ul> <p>Usage Example: <pre><code>PhiSpy.py -o output_dir -t data/trainers/Generic_taxonomy.pt input_genome.fasta\n</code></pre></p>"},{"location":"tools/virus-identification/#phigaro","title":"Phigaro","text":"<p>Phigaro is a tool for prophage prediction that performs well on both complete and draft genomes.</p> <ul> <li>Key Features:</li> <li>High-throughput prophage prediction</li> <li>Works with both complete genomes and metagenomic contigs</li> <li>Identifies partial prophages</li> <li>Outputs prophage coordinates and gene annotations</li> </ul>"},{"location":"tools/virus-identification/#viralintegration","title":"viralintegration","text":"<p>viralintegration is a Nextflow pipeline for detecting viral integration sites in host genomes.</p> <ul> <li>Key Features:</li> <li>Identifies viral integration in both germline and somatic contexts</li> <li>Works with both DNA and RNA sequencing data</li> <li>Supports multiple alignment strategies</li> <li>Part of the nf-core collection of pipelines</li> </ul>"},{"location":"tools/virus-identification/#rna-virus-identification","title":"RNA Virus Identification","text":"<p>Tools specifically for identifying RNA viruses:</p>"},{"location":"tools/virus-identification/#palmid","title":"palmID","text":"<p>palmID is an RNA virus RdRp (RNA-dependent RNA polymerase) search tool with an R interface.</p> <ul> <li>Key Features:</li> <li>Identifies RNA viruses through their RdRp sequences</li> <li>Interactive visualization of phylogenetic placement</li> <li>Integrates with Serratus for large-scale analysis</li> <li>Web interface for easy use</li> </ul>"},{"location":"tools/virus-identification/#rdrp-scan","title":"RdRp-scan","text":"<p>RdRp-scan is a tool for searching sequences against the RdRp database to identify RNA viruses.</p> <ul> <li>Key Features:</li> <li>Sensitive detection of viral RdRp sequences</li> <li>Works with divergent viral sequences</li> <li>Can be integrated into RNA virus discovery pipelines</li> <li>Command-line tool for high-throughput analysis</li> </ul>"},{"location":"tools/virus-identification/#metaviralspades-rna","title":"metaviralSPAdes-RNA","text":"<p>metaviralSPAdes-RNA is a module of the SPAdes assembler specifically designed for RNA virus detection and assembly.</p> <ul> <li>Key Features:</li> <li>Specialized assembly of RNA virus genomes</li> <li>Works with both short and long reads</li> <li>Optimized for metagenomic RNA sequencing data</li> <li>Part of the widely-used SPAdes assembler</li> </ul>"},{"location":"tools/virus-identification/#comparison-table","title":"Comparison Table","text":"Tool Type Method Best For Installation VirSorter2 Metagenome Random Forest Large metagenomic datasets <code>conda install -c bioconda virsorter=2</code> VIBRANT Metagenome Neural Networks Detailed annotation <code>conda install -c bioconda vibrant</code> geNomad Metagenome Hybrid Both viruses and plasmids <code>conda install -c bioconda genomad</code> DeepVirFinder Metagenome Deep Learning Short contigs <code>pip install deepvirfinder</code> PhiSpy Integrated Hybrid Complete bacterial genomes <code>pip install phispy</code> Phigaro Integrated HMM Draft genomes Custom installation viralintegration Integrated Alignment Integration sites Nextflow pipeline palmID RNA RdRp Search RNA virus discovery Web interface RdRp-scan RNA HMM Divergent RNA viruses <code>git clone</code> metaviralSPAdes-RNA RNA Assembly RNA virus assembly Part of SPAdes"},{"location":"tools/virus-identification/#recommended-workflows","title":"Recommended Workflows","text":"<p>For comprehensive viral discovery in metagenomic samples, consider using multiple tools with different approaches:</p> <ol> <li>Basic Workflow:</li> <li>Run VirSorter2 for general viral detection</li> <li>Check for prophages with PhiSpy</li> <li> <p>If working with RNA, add RdRp-scan</p> </li> <li> <p>Advanced Workflow:</p> </li> <li>Run multiple tools: VirSorter2, VIBRANT, geNomad</li> <li>Compare results and take consensus predictions</li> <li>Perform quality assessment with CheckV</li> <li> <p>Annotate with specialized tools like Pharokka</p> </li> <li> <p>RNA Virus Workflow:</p> </li> <li>Assemble with metaviralSPAdes-RNA</li> <li>Screen for RdRp with palmID or RdRp-scan</li> <li>Validate with sequence-based methods</li> </ol>"},{"location":"tools/virus-identification/#further-reading","title":"Further Reading","text":"<ul> <li>Benchmarking of viral prediction tools</li> <li>Challenges in viral metagenomics</li> <li>Best practices for virus identification</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>Last Updated: November 29, 2025</p> <p>This guide helps you diagnose and fix common problems in virome analysis. Issues are organized by workflow stage.</p>"},{"location":"troubleshooting/#quick-problem-finder","title":"Quick Problem Finder","text":"<p>Jump to your issue:</p> <ul> <li>Installation Problems</li> <li>Quality Control Issues</li> <li>Assembly Problems</li> <li>Viral Identification Issues</li> <li>CheckV Errors</li> <li>Performance Issues</li> </ul>"},{"location":"troubleshooting/#installation-problems","title":"Installation Problems","text":""},{"location":"troubleshooting/#tool-wont-install-via-conda","title":"Tool Won't Install via Conda","text":"<pre><code># Update conda\nconda update -n base conda\n\n# Try mamba (faster)\nconda install mamba\nmamba install -c bioconda tool_name\n\n# Create fresh environment\nconda create -n fresh_env python=3.9\nconda install -c bioconda tool_name\n</code></pre>"},{"location":"troubleshooting/#database-download-fails","title":"Database Download Fails","text":"<pre><code># Check disk space\ndf -h\n\n# Resume download\nwget -c URL\n\n# Use different download location\nexport TMPDIR=/scratch/tmp\n</code></pre>"},{"location":"troubleshooting/#quality-control-issues","title":"Quality Control Issues","text":""},{"location":"troubleshooting/#low-qc-pass-rate-70","title":"Low QC Pass Rate (&lt;70%)","text":"<p>Solutions: <pre><code># Relax quality threshold\nfastp ... --qualified_quality_phred 15\n\n# Lower length requirement\nfastp ... --length_required 30\n</code></pre></p>"},{"location":"troubleshooting/#high-duplication-60","title":"High Duplication (&gt;60%)","text":"<p>Normal for viromes (20-70% expected)</p> <p>If problematic: <pre><code>clumpify.sh in=reads.fq out=dedup.fq dedupe\n</code></pre></p>"},{"location":"troubleshooting/#assembly-problems","title":"Assembly Problems","text":""},{"location":"troubleshooting/#out-of-memory","title":"Out of Memory","text":"<p>Solutions: <pre><code># Increase memory\nspades.py -m 250\n\n# Subsample reads\nseqtk sample reads.fq 5000000 &gt; subset.fq\n\n# Fewer k-mer sizes\nspades.py -k 21,33,55\n</code></pre></p>"},{"location":"troubleshooting/#low-n50-3-kb","title":"Low N50 (&lt;3 kb)","text":"<p>Causes: Low coverage, high diversity, poor quality</p> <p>Solutions: - Sequence deeper - Try different k-mer sizes - Improve QC</p>"},{"location":"troubleshooting/#viral-identification-issues","title":"Viral Identification Issues","text":""},{"location":"troubleshooting/#very-few-viruses","title":"Very Few Viruses","text":"<p>If &lt;1%: <pre><code># Lower threshold\nvirsorter run --min-score 0.3 ...\n\n# Use multiple tools\n# VirSorter2 + VIBRANT + geNomad\n\n# Check if viral reads present\nblastn -query contigs.fa -db viral_refseq\n</code></pre></p>"},{"location":"troubleshooting/#too-many-viruses-50","title":"Too Many Viruses (&gt;50%)","text":"<p>Validate with CheckV: <pre><code>checkv end_to_end predicted.fa checkv_out/\n\n# Check contamination\nawk -F'\\t' '$10 &gt; 10' quality_summary.tsv | wc -l\n</code></pre></p>"},{"location":"troubleshooting/#checkv-errors","title":"CheckV Errors","text":""},{"location":"troubleshooting/#high-contamination","title":"High Contamination","text":"<p>Solutions: <pre><code># Use cleaned sequences\ncp checkv_out/viruses.fna cleaned.fa\n\n# Or filter\nawk -F'\\t' '$10 &lt; 10 {print $1}' quality_summary.tsv &gt; clean_ids.txt\nseqkit grep -f clean_ids.txt contigs.fa &gt; filtered.fa\n</code></pre></p>"},{"location":"troubleshooting/#host-prediction-issues","title":"Host Prediction Issues","text":""},{"location":"troubleshooting/#no-predictions","title":"No Predictions","text":"<p>Expected: Only 30-60% get predictions</p> <p>Improve: <pre><code># Lower threshold\niphop predict --min_score 70 ...\n\n# Add more MAGs from environment\n# Use multiple methods (CRISPR + WIsH + ML)\n</code></pre></p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#job-killed","title":"Job Killed","text":"<p>Solutions: <pre><code># Request more resources\n#SBATCH --mem=250G\n#SBATCH --time=48:00:00\n\n# Parallelize\nfor sample in S*; do\n    process.sh $sample &amp;\ndone\nwait\n</code></pre></p>"},{"location":"troubleshooting/#analysis-too-slow","title":"Analysis Too Slow","text":"<p>Optimize: <pre><code># More threads\ntool -t 32\n\n# Use faster tools\ndiamond  # instead of blastp\nbowtie2  # instead of bwa\n\n# Subsample for pilot\nseqtk sample reads.fq 1000000 &gt; pilot.fq\n</code></pre></p>"},{"location":"troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Cause Solution <code>std::bad_alloc</code> Out of memory Increase RAM <code>Killed</code> Out of memory Request more in job <code>Permission denied</code> File permissions Check with <code>ls -la</code> <code>No such file</code> Wrong path Verify path exists <code>Command not found</code> Not installed Install tool, activate env"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If problems persist:</p> <ol> <li>Check tool GitHub issues</li> <li>Search error message on Google/Biostars</li> <li>Awesome-Virome Discussions</li> <li>Ask on Biostars</li> </ol> <p>When asking for help, include: - Complete error message - Tool version - Input file characteristics - Steps to reproduce</p>"},{"location":"troubleshooting/#prevention-checklist","title":"Prevention Checklist","text":"<ul> <li>[ ] Test on small dataset first</li> <li>[ ] Record all commands</li> <li>[ ] Check input formats</li> <li>[ ] Monitor resources (RAM, disk)</li> <li>[ ] Use version control</li> <li>[ ] Include controls</li> <li>[ ] Validate each step</li> </ul>"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Tutorial Troubleshooting Sections</li> <li>Best Practices: Quality Control</li> <li>Tool Selection Guide</li> </ul>"},{"location":"tutorials/","title":"Virome Analysis Tutorials","text":"<p>Last Updated: November 29, 2025</p> <p>Welcome to the Awesome-Virome tutorial collection. These hands-on tutorials guide you through complete virome analysis workflows, from raw sequencing data to publication-ready results.</p>"},{"location":"tutorials/#tutorial-overview","title":"Tutorial Overview","text":"<p>Each tutorial includes: - Complete workflows with all commands and parameters - Test datasets that you can download and analyze - Expected outputs at each step for validation - Troubleshooting for common issues - Interpretation guides to understand your results</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#1-basic-metagenome-virome-analysis","title":"1. Basic Metagenome Virome Analysis","text":"<p>Level: Beginner | Time: 4-6 hours | Data: 50MB test dataset</p> <p>Learn the fundamental workflow for discovering viruses in metagenomic data.</p> <ul> <li>Quality control of raw sequencing reads</li> <li>Assembly strategies for viral metagenomes</li> <li>Viral sequence identification with multiple tools</li> <li>Quality assessment and validation</li> <li>Taxonomic classification</li> <li>Abundance estimation</li> </ul> <p>Start Tutorial</p>"},{"location":"tutorials/#2-rna-virus-discovery","title":"2. RNA Virus Discovery","text":"<p>Level: Intermediate | Time: 6-8 hours | Data: 100MB test dataset</p> <p>Discover RNA viruses in transcriptomic or metagenomic data.</p> <ul> <li>RNA extraction and library preparation considerations</li> <li>Quality control for RNA-seq data</li> <li>Assembly of RNA viral genomes</li> <li>RdRp-based virus identification</li> <li>RNA virus annotation</li> <li>Phylogenetic placement</li> </ul> <p>Start Tutorial</p>"},{"location":"tutorials/#3-prophage-identification-in-bacterial-genomes","title":"3. Prophage Identification in Bacterial Genomes","text":"<p>Level: Intermediate | Time: 3-4 hours | Data: 20MB test dataset</p> <p>Identify and characterize prophages integrated in bacterial genomes.</p> <ul> <li>Working with bacterial isolate genomes</li> <li>Multiple prophage prediction tools</li> <li>Validation and quality assessment</li> <li>Distinguishing active vs. cryptic prophages</li> <li>Prophage excision and induction analysis</li> <li>Comparative prophage genomics</li> </ul> <p>Start Tutorial</p>"},{"location":"tutorials/#4-comparative-virome-analysis","title":"4. Comparative Virome Analysis","text":"<p>Level: Advanced | Time: 8-12 hours | Data: 500MB test dataset</p> <p>Compare viral communities across multiple samples and conditions.</p> <ul> <li>Experimental design for comparative studies</li> <li>Batch processing multiple samples</li> <li>Viral contig clustering and dereplication</li> <li>Abundance normalization strategies</li> <li>Statistical analysis of viral communities</li> <li>Visualization and interpretation</li> </ul> <p>Start Tutorial</p>"},{"location":"tutorials/#5-host-prediction-workflows","title":"5. Host Prediction Workflows","text":"<p>Level: Advanced | Time: 6-10 hours | Data: 200MB test dataset</p> <p>Predict bacterial hosts for newly discovered phages.</p> <ul> <li>Multiple host prediction approaches</li> <li>CRISPR spacer-based host assignment</li> <li>Sequence homology methods</li> <li>Machine learning-based predictions</li> <li>Consensus approaches and validation</li> <li>Integrating host prediction with microbiome data</li> </ul> <p>Start Tutorial</p>"},{"location":"tutorials/#before-you-begin","title":"Before You Begin","text":""},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>All tutorials assume you have:</p> <ol> <li>Basic command line skills - Familiarity with navigating directories, running commands</li> <li>Bioinformatics fundamentals - Understanding of FASTA/FASTQ formats, sequencing basics</li> <li>Computational resources - At minimum: 16GB RAM, 50GB disk space, 4 CPU cores</li> </ol>"},{"location":"tutorials/#software-installation","title":"Software Installation","text":"<p>Most tutorials use tools available through Conda/Bioconda:</p> <pre><code># Create a conda environment for virome analysis\nconda create -n virome python=3.9\nconda activate virome\n\n# Install common tools (specific tools listed in each tutorial)\nconda install -c bioconda -c conda-forge \\\n    fastp \\\n    spades \\\n    checkv \\\n    prodigal \\\n    blast \\\n    hmmer\n</code></pre>"},{"location":"tutorials/#test-datasets","title":"Test Datasets","text":"<p>All tutorial datasets are hosted on Zenodo with DOIs for reproducibility:</p> <ul> <li>Tutorial 1: 10.5281/zenodo.example1 (simulated gut virome)</li> <li>Tutorial 2: 10.5281/zenodo.example2 (plant RNA virome)</li> <li>Tutorial 3: 10.5281/zenodo.example3 (bacterial isolates)</li> <li>Tutorial 4: 10.5281/zenodo.example4 (time-series marine virome)</li> <li>Tutorial 5: 10.5281/zenodo.example5 (environmental phages)</li> </ul> <p>Simulated Datasets</p> <p>These tutorials use simulated/controlled datasets to ensure reproducible results and reasonable runtimes. Real-world data will have additional complexities, but the analytical approaches remain the same.</p>"},{"location":"tutorials/#learning-paths","title":"Learning Paths","text":""},{"location":"tutorials/#path-1-complete-beginner","title":"Path 1: Complete Beginner","text":"<ol> <li>Start with Tutorial 1 (Basic Metagenome Virome Analysis)</li> <li>Review Fundamentals for background concepts</li> <li>Move to Tutorial 3 (Prophage Identification) - simpler than Tutorial 2</li> <li>Tackle Tutorial 2 (RNA Virus Discovery)</li> <li>Advance to Tutorials 4 &amp; 5 when confident</li> </ol>"},{"location":"tutorials/#path-2-experience-with-metagenomics","title":"Path 2: Experience with Metagenomics","text":"<ol> <li>Skim Tutorial 1 to understand virome-specific differences</li> <li>Jump to Tutorial 4 (Comparative Virome) for real-world scenarios</li> <li>Add Tutorial 5 (Host Prediction) for ecological insights</li> <li>Explore Tutorial 2 if working with RNA viruses</li> </ol>"},{"location":"tutorials/#path-3-specific-research-focus","title":"Path 3: Specific Research Focus","text":"<p>Gut microbiome researchers: - Tutorial 1 \u2192 Tutorial 3 \u2192 Tutorial 4 \u2192 Tutorial 5</p> <p>Marine/environmental virologists: - Tutorial 1 \u2192 Tutorial 4 \u2192 Tutorial 5</p> <p>Plant/RNA virologists: - Tutorial 2 \u2192 Tutorial 1 (for metagenomics background)</p> <p>Bacterial genomics + phages: - Tutorial 3 \u2192 Tutorial 5 \u2192 Tutorial 1</p>"},{"location":"tutorials/#getting-help","title":"Getting Help","text":""},{"location":"tutorials/#tutorial-specific-issues","title":"Tutorial-Specific Issues","text":"<p>Each tutorial includes a troubleshooting section for common problems. Check there first.</p>"},{"location":"tutorials/#general-questions","title":"General Questions","text":"<ul> <li>Review Best Practices</li> <li>Check Tool Documentation</li> <li>Visit Troubleshooting Guide</li> </ul>"},{"location":"tutorials/#community-support","title":"Community Support","text":"<ul> <li>GitHub Discussions</li> <li>GitHub Issues (for bugs/errors)</li> </ul>"},{"location":"tutorials/#contributing-tutorials","title":"Contributing Tutorials","text":"<p>Have a tutorial idea or improvement? We welcome contributions:</p> <ol> <li>Open a GitHub Issue describing your tutorial</li> <li>Follow our Contributing Guidelines</li> <li>Submit a pull request with your tutorial</li> </ol> <p>Tutorial requirements: - Complete, tested workflow with all commands - Publicly available test dataset (&lt;500MB) - Expected outputs and validation steps - Troubleshooting section - Estimated completion time</p>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>Ready to start? Choose your first tutorial from the list above, or review the Fundamentals section if you need more background.</p>"},{"location":"tutorials/#further-reading","title":"Further Reading","text":""},{"location":"tutorials/#books","title":"Books","text":"<ul> <li>\"Viral Ecology\" by Christon J. Hurst (comprehensive virology background)</li> <li>\"Metagenomics: Methods and Protocols\" (Methods in Molecular Biology series)</li> </ul>"},{"location":"tutorials/#review-papers","title":"Review Papers","text":"<ul> <li>Roux, S., et al. (2019). \"Minimum Information about an Uncultivated Virus Genome (MIUViG).\" Nature Biotechnology, 37(1), 29-37.</li> <li>Gregory, A. C., et al. (2019). \"Marine DNA viral macro- and microdiversity from pole to pole.\" Cell, 177(5), 1109-1123.</li> <li>Shkoporov, A. N., &amp; Hill, C. (2019). \"Bacteriophages of the human gut: the 'known unknown' of the microbiome.\" Cell Host &amp; Microbe, 25(2), 195-209.</li> </ul>"},{"location":"tutorials/#online-courses","title":"Online Courses","text":"<ul> <li>Viral Bioinformatics Course - Free GitHub-based course</li> <li>Introduction to Metagenomics - Coursera course</li> </ul>"},{"location":"tutorials/basic-metagenome-virome/","title":"Tutorial 1: Basic Metagenome Virome Analysis","text":"<p>Last Updated: November 29, 2025 Level: Beginner | Time: 4-6 hours | Data Size: 50MB</p>"},{"location":"tutorials/basic-metagenome-virome/#overview","title":"Overview","text":"<p>This tutorial teaches the fundamental workflow for discovering and characterizing viruses in metagenomic sequencing data. You'll learn how to go from raw FASTQ files to a characterized set of viral contigs with taxonomic assignments and abundance estimates.</p> <p>What you'll learn: - Quality control and preprocessing of metagenomic reads - Assembly strategies optimized for viral sequences - Identification of viral contigs using multiple tools - Quality assessment and validation with CheckV - Taxonomic classification of viral sequences - Abundance estimation and visualization</p> <p>Sample dataset: Simulated human gut virome dataset (paired-end Illumina, 2\u00d7150bp, ~2M reads)</p>"},{"location":"tutorials/basic-metagenome-virome/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/basic-metagenome-virome/#required-software","title":"Required Software","text":"<p>Install these tools via conda:</p> <pre><code># Create and activate environment\nconda create -n virome_tutorial python=3.9\nconda activate virome_tutorial\n\n# Install required tools\nconda install -c bioconda -c conda-forge \\\n    fastp=0.23.4 \\\n    spades=3.15.5 \\\n    virsorter=2.2.4 \\\n    checkv=1.0.1 \\\n    blast=2.14.0 \\\n    prodigal=2.6.3 \\\n    hmmer=3.3.2 \\\n    seqkit=2.5.1 \\\n    bbmap=39.01 \\\n    coverm=0.6.1\n\n# Install VIBRANT (requires separate installation)\ncd ~/tools  # or your preferred tools directory\ngit clone https://github.com/AnantharamanLab/VIBRANT.git\ncd VIBRANT\npython3 setup.py install\ndownload-db.sh  # Downloads VIBRANT databases (~11GB)\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#system-requirements","title":"System Requirements","text":"<ul> <li>RAM: 16GB minimum (32GB recommended)</li> <li>Disk Space: 50GB free space</li> <li>CPU: 4+ cores recommended</li> <li>OS: Linux or macOS</li> </ul>"},{"location":"tutorials/basic-metagenome-virome/#background-knowledge","title":"Background Knowledge","text":"<p>Familiarity with: - Basic Unix command line (cd, ls, mkdir, etc.) - FASTA/FASTQ file formats - Concepts from Fundamentals</p>"},{"location":"tutorials/basic-metagenome-virome/#step-1-download-and-prepare-data","title":"Step 1: Download and Prepare Data","text":""},{"location":"tutorials/basic-metagenome-virome/#download-test-dataset","title":"Download Test Dataset","text":"<pre><code># Create project directory\nmkdir -p ~/virome_tutorial\ncd ~/virome_tutorial\n\n# Download simulated gut virome dataset (Zenodo)\n# Note: Replace with actual Zenodo DOI when dataset is uploaded\nwget https://zenodo.org/record/EXAMPLE/files/gut_virome_R1.fastq.gz\nwget https://zenodo.org/record/EXAMPLE/files/gut_virome_R2.fastq.gz\n\n# For this tutorial, we'll use a simulated dataset\n# Verify download integrity\nmd5sum gut_virome_R1.fastq.gz gut_virome_R2.fastq.gz\n# Expected:\n# a1b2c3d4... gut_virome_R1.fastq.gz\n# e5f6g7h8... gut_virome_R2.fastq.gz\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#inspect-raw-data","title":"Inspect Raw Data","text":"<pre><code># Check number of reads\necho \"$(zcat gut_virome_R1.fastq.gz | wc -l) / 4\" | bc\n# Expected output: ~2000000 reads\n\n# Look at first few reads\nzcat gut_virome_R1.fastq.gz | head -n 8\n\n# Check read length distribution\nseqkit stats gut_virome_R1.fastq.gz gut_virome_R2.fastq.gz\n</code></pre> <p>Expected output: <pre><code>file                      format  type  num_seqs      sum_len  min_len  avg_len  max_len\ngut_virome_R1.fastq.gz    FASTQ   DNA  2,000,000  300,000,000      150      150      150\ngut_virome_R2.fastq.gz    FASTQ   DNA  2,000,000  300,000,000      150      150      150\n</code></pre></p>"},{"location":"tutorials/basic-metagenome-virome/#step-2-quality-control-and-preprocessing","title":"Step 2: Quality Control and Preprocessing","text":""},{"location":"tutorials/basic-metagenome-virome/#run-fastp-for-qc-and-trimming","title":"Run FastP for QC and Trimming","text":"<pre><code># Create QC output directory\nmkdir -p 01_qc\n\n# Run fastp with virome-optimized parameters\nfastp \\\n    -i gut_virome_R1.fastq.gz \\\n    -I gut_virome_R2.fastq.gz \\\n    -o 01_qc/cleaned_R1.fastq.gz \\\n    -O 01_qc/cleaned_R2.fastq.gz \\\n    -h 01_qc/fastp_report.html \\\n    -j 01_qc/fastp_report.json \\\n    --detect_adapter_for_pe \\\n    --correction \\\n    --cut_front \\\n    --cut_tail \\\n    --cut_window_size 4 \\\n    --cut_mean_quality 20 \\\n    --qualified_quality_phred 20 \\\n    --unqualified_percent_limit 30 \\\n    --n_base_limit 5 \\\n    --length_required 50 \\\n    --thread 4\n</code></pre> <p>Parameter explanation: - <code>--detect_adapter_for_pe</code>: Auto-detect and trim adapters - <code>--correction</code>: Overlap-based error correction - <code>--cut_front/tail</code>: Quality trimming from both ends - <code>--cut_mean_quality 20</code>: Quality threshold for sliding window - <code>--length_required 50</code>: Minimum read length after trimming</p>"},{"location":"tutorials/basic-metagenome-virome/#review-qc-results","title":"Review QC Results","text":"<pre><code># View HTML report\nfirefox 01_qc/fastp_report.html  # or open in browser\n\n# Check filtering statistics from JSON\ncat 01_qc/fastp_report.json | grep -A 5 \"summary\"\n</code></pre> <p>Expected results: - Reads passing filter: ~90-95% (1.8-1.9M reads) - Q30 bases: &gt;90% - Adapter content: &lt;5% - Duplication rate: 10-30% (normal for viral samples)</p> <p>High Duplication is Normal</p> <p>Viral samples often show 20-50% duplication due to high viral abundance and small genome sizes. This is expected and not a quality issue.</p>"},{"location":"tutorials/basic-metagenome-virome/#step-3-assembly","title":"Step 3: Assembly","text":""},{"location":"tutorials/basic-metagenome-virome/#run-metaviralspades","title":"Run metaviralSPAdes","text":"<pre><code># Create assembly directory\nmkdir -p 02_assembly\n\n# Run metaviralSPAdes (virus-optimized metagenomic assembler)\nmetaspades.py \\\n    --meta \\\n    --only-assembler \\\n    -1 01_qc/cleaned_R1.fastq.gz \\\n    -2 01_qc/cleaned_R2.fastq.gz \\\n    -o 02_assembly/metaspades \\\n    -t 8 \\\n    -m 32 \\\n    -k 21,33,55,77\n\n# metaviralSPAdes mode (alternative - more sensitive for diverse viruses)\nspades.py \\\n    --metaviral \\\n    -1 01_qc/cleaned_R1.fastq.gz \\\n    -2 01_qc/cleaned_R2.fastq.gz \\\n    -o 02_assembly/metaviralspades \\\n    -t 8 \\\n    -m 32\n</code></pre> <p>Parameter explanation: - <code>--meta</code> or <code>--metaviral</code>: Metagenome/viral metagenome mode - <code>-k 21,33,55,77</code>: K-mer sizes (multiple k-mers improve assembly) - <code>-t 8</code>: Number of threads - <code>-m 32</code>: Memory limit (GB)</p> <p>Choose Your Assembler</p> <ul> <li>Use <code>--meta</code> for standard metagenomes with viruses</li> <li>Use <code>--metaviral</code> for virus-enriched samples (VLP preparations)</li> <li>This tutorial uses <code>--metaviral</code> for better viral recovery</li> </ul> <p>Assembly runtime: ~1-2 hours on 8 cores</p>"},{"location":"tutorials/basic-metagenome-virome/#filter-and-prepare-contigs","title":"Filter and Prepare Contigs","text":"<pre><code># Filter contigs \u22651kb (minimum recommended length)\nseqkit seq -m 1000 02_assembly/metaviralspades/contigs.fasta \\\n    &gt; 02_assembly/contigs_1kb.fasta\n\n# Get assembly statistics\nseqkit stats 02_assembly/contigs_1kb.fasta\n\n# Count contigs\ngrep -c \"&gt;\" 02_assembly/contigs_1kb.fasta\n</code></pre> <p>Expected results: - Total contigs \u22651kb: 500-1500 contigs - Longest contig: 50-150 kb - N50: 5-15 kb - Total assembly length: 5-15 Mb</p> <pre><code>file                        format  type  num_seqs    sum_len  min_len  avg_len  max_len\ncontigs_1kb.fasta           FASTA   DNA      1,234  8,456,789    1,000    6,851  142,567\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#step-4-viral-sequence-identification","title":"Step 4: Viral Sequence Identification","text":"<p>We'll use three complementary tools for viral identification to maximize accuracy.</p>"},{"location":"tutorials/basic-metagenome-virome/#41-virsorter2","title":"4.1 VirSorter2","text":"<pre><code># Create viral identification directory\nmkdir -p 03_viral_id\n\n# Run VirSorter2\nvirsorter run \\\n    -w 03_viral_id/virsorter2 \\\n    -i 02_assembly/contigs_1kb.fasta \\\n    --min-length 1000 \\\n    --min-score 0.5 \\\n    --include-groups dsDNAphage,ssDNA \\\n    -j 8 \\\n    all\n\n# Extract viral sequences (score \u2265 0.5)\ncat 03_viral_id/virsorter2/final-viral-combined.fa &gt; 03_viral_id/virsorter2_viral.fasta\n</code></pre> <p>Expected output: - Viral contigs identified: 200-400 - Score distribution: Most 0.5-0.9, some &gt;0.9 - Output file: <code>final-viral-combined.fa</code></p>"},{"location":"tutorials/basic-metagenome-virome/#42-vibrant","title":"4.2 VIBRANT","text":"<pre><code># Run VIBRANT\nVIBRANT_run.py \\\n    -i 02_assembly/contigs_1kb.fasta \\\n    -folder 03_viral_id/vibrant \\\n    -t 8 \\\n    -virome\n\n# Extract VIBRANT predictions\ncp 03_viral_id/vibrant/VIBRANT_contigs_1kb/VIBRANT_phages_contigs_1kb/contigs_1kb.phages_combined.fna \\\n    03_viral_id/vibrant_viral.fasta\n</code></pre> <p>Expected output: - Viral contigs identified: 150-350 - Output: Phages and prophages separated - Annotations: Genes, functions, AMGs (auxiliary metabolic genes)</p>"},{"location":"tutorials/basic-metagenome-virome/#43-genomad","title":"4.3 geNomad","text":"<pre><code># Download geNomad database (first time only)\ngenomad download-database genomad_db/\n\n# Run geNomad\ngenomad end-to-end \\\n    02_assembly/contigs_1kb.fasta \\\n    03_viral_id/genomad \\\n    genomad_db/ \\\n    --threads 8 \\\n    --min-score 0.7\n\n# Extract viral sequences\ncp 03_viral_id/genomad/contigs_1kb_summary/contigs_1kb_virus.fna \\\n    03_viral_id/genomad_viral.fasta\n</code></pre> <p>Expected output: - Viral sequences: 180-380 - Plasmids identified: 20-50 (excluded from viral count) - Scores: Most &gt;0.7 (high confidence)</p>"},{"location":"tutorials/basic-metagenome-virome/#44-combine-predictions-consensus-approach","title":"4.4 Combine Predictions (Consensus Approach)","text":"<pre><code># Create list of viral contigs from each tool\ngrep \"&gt;\" 03_viral_id/virsorter2_viral.fasta | sed 's/&gt;//' | cut -f1 -d' ' &gt; 03_viral_id/vs2_ids.txt\ngrep \"&gt;\" 03_viral_id/vibrant_viral.fasta | sed 's/&gt;//' | cut -f1 -d' ' &gt; 03_viral_id/vibrant_ids.txt\ngrep \"&gt;\" 03_viral_id/genomad_viral.fasta | sed 's/&gt;//' | cut -f1 -d' ' &gt; 03_viral_id/genomad_ids.txt\n\n# Find consensus: contigs predicted by \u22652 tools\ncat 03_viral_id/*_ids.txt | sort | uniq -c | awk '$1 &gt;= 2 {print $2}' &gt; 03_viral_id/consensus_viral_ids.txt\n\n# Extract consensus viral contigs\nseqkit grep -f 03_viral_id/consensus_viral_ids.txt \\\n    02_assembly/contigs_1kb.fasta \\\n    &gt; 03_viral_id/consensus_viral_contigs.fasta\n\n# Count consensus predictions\nwc -l 03_viral_id/consensus_viral_ids.txt\n</code></pre> <p>Expected consensus results: - Consensus viral contigs (\u22652 tools): 150-300 - Tool overlap: ~60-70% agreement between any two tools - High-confidence (all 3 tools): ~40-60% of consensus set</p> <p>Why Consensus?</p> <p>Single tool predictions have 10-30% false positive rates. Using consensus (\u22652 tools agreeing) dramatically reduces false positives while maintaining most true viruses.</p>"},{"location":"tutorials/basic-metagenome-virome/#step-5-quality-assessment-with-checkv","title":"Step 5: Quality Assessment with CheckV","text":"<pre><code># Create CheckV directory\nmkdir -p 04_checkv\n\n# Run CheckV on consensus viral contigs\ncheckv end_to_end \\\n    03_viral_id/consensus_viral_contigs.fasta \\\n    04_checkv \\\n    -t 8 \\\n    -d /path/to/checkv-db-v1.5  # Update path to your CheckV database\n\n# Review quality summary\ncat 04_checkv/quality_summary.tsv\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#interpret-checkv-results","title":"Interpret CheckV Results","text":"<p>CheckV assigns quality tiers:</p> <ul> <li>Complete (&gt;90% completeness): High-quality, likely complete genomes</li> <li>High-quality (&gt;50% completeness): Substantial genome fragments</li> <li>Medium-quality (&gt;50% completeness OR specific criteria): Useful for most analyses</li> <li>Low-quality (&lt;50% completeness, no specific markers): Fragmented, use with caution</li> <li>Not-determined: Insufficient information</li> </ul> <p>Filter for high-quality viral sequences:</p> <pre><code># Extract high and complete quality viral genomes\nawk -F'\\t' '$8 == \"Complete\" || $8 == \"High-quality\" {print $1}' \\\n    04_checkv/quality_summary.tsv \\\n    &gt; 04_checkv/hq_viral_ids.txt\n\n# Extract high-quality sequences\nseqkit grep -f 04_checkv/hq_viral_ids.txt \\\n    03_viral_id/consensus_viral_contigs.fasta \\\n    &gt; 04_checkv/hq_viral_contigs.fasta\n\n# Count HQ viral contigs\nwc -l 04_checkv/hq_viral_ids.txt\n</code></pre> <p>Expected HQ results: - High-quality + Complete: 50-150 contigs - Average completeness: 60-85% - Contamination: &lt;5% for most contigs</p> <p>Quality Thresholds</p> <p>For most analyses: - Diversity studies: Medium-quality and above - Taxonomy: High-quality and above - Genome comparison: Complete genomes only - Host prediction: High-quality and above</p>"},{"location":"tutorials/basic-metagenome-virome/#step-6-remove-host-contamination","title":"Step 6: Remove Host Contamination","text":"<p>CheckV identifies host contamination (bacterial/archaeal genes on viral contigs).</p> <pre><code># Extract cleaned viral sequences (provirus coordinates if any)\n# CheckV creates \"viruses.fna\" with contamination removed\ncp 04_checkv/viruses.fna 04_checkv/viral_contigs_clean.fasta\n\n# Compare before/after cleaning\nseqkit stats 04_checkv/hq_viral_contigs.fasta 04_checkv/viral_contigs_clean.fasta\n</code></pre> <p>Expected: Some contigs may be trimmed if they had flanking host regions (prophages).</p>"},{"location":"tutorials/basic-metagenome-virome/#step-7-taxonomic-classification","title":"Step 7: Taxonomic Classification","text":""},{"location":"tutorials/basic-metagenome-virome/#71-blast-based-classification","title":"7.1 BLAST-based Classification","text":"<pre><code># Create taxonomy directory\nmkdir -p 05_taxonomy\n\n# Download NCBI Viral RefSeq database (if not already present)\nmkdir -p db/viral_refseq\ncd db/viral_refseq\nwget ftp://ftp.ncbi.nlm.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz\nwget ftp://ftp.ncbi.nlm.nih.gov/refseq/release/viral/viral.2.1.genomic.fna.gz\ngunzip viral.*.genomic.fna.gz\ncat viral.*.genomic.fna &gt; viral_refseq.fna\n\n# Create BLAST database\nmakeblastdb -in viral_refseq.fna -dbtype nucl -out viral_refseq\n\ncd ~/virome_tutorial\n\n# Run BLASTn\nblastn \\\n    -query 04_checkv/viral_contigs_clean.fasta \\\n    -db db/viral_refseq/viral_refseq \\\n    -out 05_taxonomy/blast_results.txt \\\n    -outfmt '6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore staxids' \\\n    -evalue 1e-5 \\\n    -num_threads 8 \\\n    -max_target_seqs 5\n\n# Extract best hit per query\nsort -k1,1 -k12,12gr 05_taxonomy/blast_results.txt | \\\n    sort -u -k1,1 &gt; 05_taxonomy/blast_best_hits.txt\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#72-analyze-taxonomic-composition","title":"7.2 Analyze Taxonomic Composition","text":"<pre><code># Count contigs with hits at different identity thresholds\necho \"Total viral contigs: $(grep -c \"&gt;\" 04_checkv/viral_contigs_clean.fasta)\"\necho \"Contigs with BLAST hits (any): $(cut -f1 05_taxonomy/blast_best_hits.txt | sort -u | wc -l)\"\necho \"Contigs with high similarity (&gt;90% identity): $(awk '$3 &gt; 90' 05_taxonomy/blast_best_hits.txt | cut -f1 | sort -u | wc -l)\"\necho \"Contigs with medium similarity (70-90% identity): $(awk '$3 &gt; 70 &amp;&amp; $3 &lt;= 90' 05_taxonomy/blast_best_hits.txt | cut -f1 | sort -u | wc -l)\"\necho \"Contigs with low similarity (&lt;70% identity): $(awk '$3 &lt;= 70' 05_taxonomy/blast_best_hits.txt | cut -f1 | sort -u | wc -l)\"\necho \"Novel contigs (no hits): $(($(grep -c \"&gt;\" 04_checkv/viral_contigs_clean.fasta) - $(cut -f1 05_taxonomy/blast_best_hits.txt | sort -u | wc -l)))\"\n</code></pre> <p>Expected distribution (gut virome): - High similarity (&gt;90%): 20-40% (known viruses) - Medium similarity (70-90%): 15-25% (related to known viruses) - Low similarity (&lt;70%): 10-20% (distant relatives) - No hits (novel): 30-50% (novel viruses - \"viral dark matter\")</p> <p>Interpreting Similarity</p> <ul> <li>&gt;95% identity: Same species/strain</li> <li>70-95% identity: Related species in same genus/family</li> <li>&lt;70% identity: Distant relationship, taxonomy uncertain</li> <li>No hit: Novel virus with no close cultivated relatives</li> </ul>"},{"location":"tutorials/basic-metagenome-virome/#step-8-abundance-estimation","title":"Step 8: Abundance Estimation","text":""},{"location":"tutorials/basic-metagenome-virome/#map-reads-to-viral-contigs","title":"Map Reads to Viral Contigs","text":"<pre><code># Create abundance directory\nmkdir -p 06_abundance\n\n# Index viral contigs\nbbmap.sh ref=04_checkv/viral_contigs_clean.fasta\n\n# Map reads to viral contigs\nbbmap.sh \\\n    in1=01_qc/cleaned_R1.fastq.gz \\\n    in2=01_qc/cleaned_R2.fastq.gz \\\n    out=06_abundance/mapped.sam \\\n    covstats=06_abundance/coverage_stats.txt \\\n    rpkm=06_abundance/rpkm.txt \\\n    minid=0.95 \\\n    threads=8\n\n# Convert to sorted BAM\nsamtools view -bS 06_abundance/mapped.sam | \\\n    samtools sort -o 06_abundance/mapped_sorted.bam\nsamtools index 06_abundance/mapped_sorted.bam\n\n# Calculate coverage with CoverM\ncoverm contig \\\n    --bam-files 06_abundance/mapped_sorted.bam \\\n    --methods mean trimmed_mean covered_fraction \\\n    --output-file 06_abundance/coverm_coverage.txt\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#analyze-abundance-results","title":"Analyze Abundance Results","text":"<pre><code># View top 20 most abundant viruses\nsort -t$'\\t' -k2 -rn 06_abundance/coverm_coverage.txt | head -n 20\n\n# Calculate statistics\necho \"Total viral contigs: $(tail -n +2 06_abundance/coverm_coverage.txt | wc -l)\"\necho \"Viral contigs with coverage &gt;10x: $(awk '$2 &gt; 10' 06_abundance/coverm_coverage.txt | wc -l)\"\necho \"Viral contigs with coverage &gt;100x: $(awk '$2 &gt; 100' 06_abundance/coverm_coverage.txt | wc -l)\"\n</code></pre> <p>Expected results: - Coverage range: 0.1x to 10,000x (highly variable) - High-coverage viruses (&gt;100x): 10-30 contigs (dominant viruses) - Medium-coverage (10-100x): 30-80 contigs - Low-coverage (&lt;10x): Majority of contigs (rare viruses)</p>"},{"location":"tutorials/basic-metagenome-virome/#step-9-summary-and-visualization","title":"Step 9: Summary and Visualization","text":""},{"location":"tutorials/basic-metagenome-virome/#create-summary-table","title":"Create Summary Table","text":"<pre><code># Combine all results into summary table\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load CheckV quality\ncheckv = pd.read_csv('04_checkv/quality_summary.tsv', sep='\\t')\ncheckv = checkv[['contig_id', 'contig_length', 'checkv_quality', 'completeness', 'contamination']]\n\n# Load BLAST results\nblast = pd.read_csv('05_taxonomy/blast_best_hits.txt', sep='\\t', header=None,\n                    names=['contig_id', 'subject', 'pident', 'length', 'mismatch',\n                           'gapopen', 'qstart', 'qend', 'sstart', 'send', 'evalue', 'bitscore', 'taxid'])\nblast = blast[['contig_id', 'subject', 'pident', 'evalue']]\n\n# Load abundance\nabundance = pd.read_csv('06_abundance/coverm_coverage.txt', sep='\\t')\nabundance.columns = ['contig_id', 'mean_coverage', 'trimmed_mean', 'covered_fraction']\n\n# Merge all data\nsummary = checkv.merge(blast, on='contig_id', how='left')\nsummary = summary.merge(abundance, on='contig_id', how='left')\n\n# Fill NaN for contigs without BLAST hits\nsummary['pident'] = summary['pident'].fillna(0)\nsummary['subject'] = summary['subject'].fillna('No hit')\n\n# Sort by abundance\nsummary = summary.sort_values('mean_coverage', ascending=False)\n\n# Save\nsummary.to_csv('07_summary/viral_summary_table.tsv', sep='\\t', index=False)\n\nprint(f\"Total viral contigs: {len(summary)}\")\nprint(f\"High-quality contigs: {len(summary[summary['checkv_quality'].isin(['Complete', 'High-quality'])])}\")\nprint(f\"Contigs with taxonomy (&gt;70% identity): {len(summary[summary['pident'] &gt; 70])}\")\nprint(f\"Novel contigs (no BLAST hit): {len(summary[summary['pident'] == 0])}\")\nprint(\"\\nTop 10 most abundant viruses:\")\nprint(summary[['contig_id', 'contig_length', 'checkv_quality', 'pident', 'subject', 'mean_coverage']].head(10))\nEOF\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#visualize-results","title":"Visualize Results","text":"<p>Create a simple visualization script:</p> <pre><code># Create visualization directory\nmkdir -p 07_summary\n\n# Generate plots with R\nRscript - &lt;&lt; 'EOF'\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load summary table\ndata &lt;- read.delim('07_summary/viral_summary_table.tsv')\n\n# Plot 1: Contig length distribution\npdf('07_summary/contig_length_distribution.pdf', width=8, height=6)\nggplot(data, aes(x=contig_length/1000)) +\n  geom_histogram(bins=50, fill='steelblue', color='black') +\n  labs(x='Contig Length (kb)', y='Count',\n       title='Viral Contig Length Distribution') +\n  theme_minimal()\ndev.off()\n\n# Plot 2: Completeness vs Coverage\npdf('07_summary/completeness_vs_coverage.pdf', width=8, height=6)\nggplot(data, aes(x=log10(mean_coverage + 1), y=completeness, color=checkv_quality)) +\n  geom_point(alpha=0.6) +\n  labs(x='Log10(Coverage + 1)', y='Completeness (%)',\n       title='Viral Genome Completeness vs. Coverage',\n       color='CheckV Quality') +\n  theme_minimal()\ndev.off()\n\n# Plot 3: Taxonomic novelty\npdf('07_summary/taxonomic_novelty.pdf', width=8, height=6)\ndata_with_hits &lt;- data %&gt;% filter(pident &gt; 0)\nggplot(data_with_hits, aes(x=pident)) +\n  geom_histogram(bins=50, fill='coral', color='black') +\n  geom_vline(xintercept=c(70, 90, 95), linetype='dashed', color='red') +\n  labs(x='BLAST Identity (%)', y='Count',\n       title='Taxonomic Similarity to Known Viruses') +\n  annotate('text', x=c(60, 80, 92.5, 97.5), y=Inf,\n           label=c('Novel', 'Distant', 'Related', 'Known'),\n           vjust=2) +\n  theme_minimal()\ndev.off()\n\nprint(\"Plots saved to 07_summary/\")\nEOF\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#expected-final-results","title":"Expected Final Results","text":"<p>At the end of this tutorial, you should have:</p>"},{"location":"tutorials/basic-metagenome-virome/#files-generated","title":"Files Generated","text":"<pre><code>~/virome_tutorial/\n\u251c\u2500\u2500 01_qc/\n\u2502   \u251c\u2500\u2500 cleaned_R1.fastq.gz           # QC-filtered reads\n\u2502   \u251c\u2500\u2500 cleaned_R2.fastq.gz\n\u2502   \u2514\u2500\u2500 fastp_report.html\n\u251c\u2500\u2500 02_assembly/\n\u2502   \u2514\u2500\u2500 contigs_1kb.fasta             # Assembled contigs \u22651kb\n\u251c\u2500\u2500 03_viral_id/\n\u2502   \u2514\u2500\u2500 consensus_viral_contigs.fasta # Viral contigs (\u22652 tools)\n\u251c\u2500\u2500 04_checkv/\n\u2502   \u251c\u2500\u2500 viral_contigs_clean.fasta     # High-quality, clean viral genomes\n\u2502   \u2514\u2500\u2500 quality_summary.tsv\n\u251c\u2500\u2500 05_taxonomy/\n\u2502   \u2514\u2500\u2500 blast_best_hits.txt           # Taxonomic assignments\n\u251c\u2500\u2500 06_abundance/\n\u2502   \u2514\u2500\u2500 coverm_coverage.txt           # Viral abundance\n\u2514\u2500\u2500 07_summary/\n    \u251c\u2500\u2500 viral_summary_table.tsv       # Complete summary table\n    \u2514\u2500\u2500 *.pdf                         # Visualization plots\n</code></pre>"},{"location":"tutorials/basic-metagenome-virome/#typical-results-summary","title":"Typical Results Summary","text":"<ul> <li>Input reads: 2,000,000 paired-end reads</li> <li>After QC: ~1,850,000 reads (92.5%)</li> <li>Assembled contigs \u22651kb: 500-1,500</li> <li>Viral contigs (consensus): 150-300</li> <li>High-quality viral genomes: 50-150</li> <li>Complete genomes: 10-30</li> <li>Novel viruses (no BLAST hit): 30-50% of total</li> <li>Known viruses (&gt;95% identity): 20-40% of total</li> </ul>"},{"location":"tutorials/basic-metagenome-virome/#interpreting-your-results","title":"Interpreting Your Results","text":""},{"location":"tutorials/basic-metagenome-virome/#quality-metrics-to-check","title":"Quality Metrics to Check","text":"<p>\u2705 Good run indicators: - QC pass rate &gt;85% - Assembly N50 &gt;5kb - Viral prediction overlap &gt;50% between any two tools - CheckV completeness &gt;50% for majority of HQ contigs - Reasonable abundance distribution (not dominated by 1-2 viruses)</p> <p>\u26a0\ufe0f Warning signs: - QC pass rate &lt;70% \u2192 Check sequencing quality - Very few viral contigs (&lt;50) \u2192 Sample may be low in viruses or highly novel - High contamination (&gt;10%) in CheckV \u2192 Assembly or identification issues - All viruses novel (0% BLAST hits) \u2192 Check database or sample type</p>"},{"location":"tutorials/basic-metagenome-virome/#biological-interpretation","title":"Biological Interpretation","text":"<p>High novelty (&gt;50% no BLAST hits): - Expected for environmental samples (soil, marine) - Common for gut viromes from non-Western populations - Indicates viral \"dark matter\"</p> <p>Low novelty (&lt;20% no BLAST hits): - Expected for clinical samples - Common for well-studied environments - May indicate sample contamination with known viruses</p> <p>Abundance patterns: - Power-law distribution (few dominant, many rare) is typical - Even distribution may indicate biases or artificial sample - Single dominant virus (&gt;50% of reads) may be bloom or contamination</p>"},{"location":"tutorials/basic-metagenome-virome/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/basic-metagenome-virome/#problem-low-assembly-n50-3kb","title":"Problem: Low Assembly N50 (&lt;3kb)","text":"<p>Possible causes: - Low read quality \u2192 Re-check QC metrics - Low viral diversity/abundance \u2192 Increase sequencing depth - Complex sample \u2192 Try different k-mer sizes</p> <p>Solutions: <pre><code># Try more aggressive QC\nfastp -i R1.fastq.gz -I R2.fastq.gz ... --cut_mean_quality 25\n\n# Try different k-mer sizes\nspades.py --metaviral -k 21,33,55,77,99,127 ...\n\n# Use longer k-mers only\nspades.py --metaviral -k 55,77,99 ...\n</code></pre></p>"},{"location":"tutorials/basic-metagenome-virome/#problem-very-few-viral-contigs-identified","title":"Problem: Very Few Viral Contigs Identified","text":"<p>Possible causes: - Sample not enriched for viruses - Highly novel viruses not recognized - Over-filtering</p> <p>Solutions: <pre><code># Lower VirSorter2 threshold\nvirsorter run ... --min-score 0.3\n\n# Include more viral groups\nvirsorter run ... --include-groups dsDNAphage,ssDNA,RNA,NCLDV,lavidaviridae\n\n# Use single-tool predictions (less conservative)\n# But validate carefully!\n</code></pre></p>"},{"location":"tutorials/basic-metagenome-virome/#problem-high-contamination-in-checkv","title":"Problem: High Contamination in CheckV","text":"<p>Possible causes: - Prophages with flanking host genes - False viral predictions (bacterial contigs) - Horizontal gene transfer</p> <p>Solutions: <pre><code># Use CheckV's cleaned sequences (automatically trims)\n# Already done in tutorial: 04_checkv/viruses.fna\n\n# More stringent consensus (require all 3 tools)\ncat 03_viral_id/*_ids.txt | sort | uniq -c | awk '$1 == 3 {print $2}' &gt; strict_consensus.txt\n\n# Remove low-quality prophages\nawk -F'\\t' '$9 != \"Yes\" || $8 == \"Complete\" {print $1}' 04_checkv/quality_summary.tsv\n</code></pre></p>"},{"location":"tutorials/basic-metagenome-virome/#problem-no-blast-hits","title":"Problem: No BLAST Hits","text":"<p>Possible causes: - Database outdated \u2192 Update viral RefSeq - Truly novel viruses \u2192 Expected for environmental samples - Incorrect database \u2192 Verify using known virus</p> <p>Solutions: <pre><code># Update viral RefSeq database\nwget ftp://ftp.ncbi.nlm.nih.gov/refseq/release/viral/viral.*.genomic.fna.gz\n\n# Try IMG/VR database (much larger, includes environmental viruses)\nwget https://img.jgi.doe.gov/vr/downloads/IMGVR_all_nucleotides.fna.gz\n\n# Use protein-based search (more sensitive)\nprodigal -i viral_contigs.fasta -a proteins.faa -p meta\nblastp -query proteins.faa -db nr -evalue 1e-3 -num_threads 8\n</code></pre></p>"},{"location":"tutorials/basic-metagenome-virome/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've completed the basic virome analysis workflow.</p>"},{"location":"tutorials/basic-metagenome-virome/#to-build-on-this-tutorial","title":"To build on this tutorial:","text":"<ol> <li>Tutorial 2: RNA Virus Discovery - Learn RNA-specific methods</li> <li>Tutorial 4: Comparative Virome Analysis - Analyze multiple samples</li> <li>Tutorial 5: Host Prediction - Predict viral hosts</li> </ol>"},{"location":"tutorials/basic-metagenome-virome/#advanced-analyses-you-can-now-try","title":"Advanced analyses you can now try:","text":"<ul> <li>Protein clustering: Group viruses by shared protein content (vConTACT2)</li> <li>AMG analysis: Identify auxiliary metabolic genes (DRAM-v)</li> <li>Lifestyle prediction: Lytic vs. temperate phages (BACPHLIP)</li> <li>Network analysis: Protein-sharing networks (vConTACT2, Cytoscape)</li> </ul>"},{"location":"tutorials/basic-metagenome-virome/#applying-to-your-own-data","title":"Applying to your own data:","text":"<p>When you have your own virome data:</p> <ol> <li>Adjust assembly parameters based on your sequencing depth and read length</li> <li>Choose appropriate filters - environmental samples may need less stringent thresholds</li> <li>Validate key findings - especially for novel viruses, validate with:</li> <li>Gene content (presence of viral hallmark genes)</li> <li>Genome structure (compare to related viruses)</li> <li>Experimental validation (PCR, qPCR, isolation attempts)</li> </ol>"},{"location":"tutorials/basic-metagenome-virome/#further-reading","title":"Further Reading","text":"<ul> <li>Roux, S., et al. (2016). \"Towards quantitative viromics for both double-stranded and single-stranded DNA viruses.\" PeerJ, 4, e2777.</li> <li>Nayfach, S., et al. (2021). \"CheckV assesses the quality and completeness of metagenome-assembled viral genomes.\" Nature Biotechnology, 39(5), 578-585.</li> <li>Guo, J., et al. (2021). \"VirSorter2: a multi-classifier, expert-guided approach to detect diverse DNA and RNA viruses.\" Microbiome, 9(1), 1-13.</li> </ul>"},{"location":"tutorials/basic-metagenome-virome/#feedback","title":"Feedback","text":"<p>Found an issue or have a suggestion? Please open an issue on GitHub.</p>"},{"location":"tutorials/comparative-virome/","title":"Tutorial 4: Comparative Virome Analysis","text":"<p>Last Updated: November 29, 2025 Level: Advanced | Time: 8-12 hours | Data Size: 500MB</p>"},{"location":"tutorials/comparative-virome/#overview","title":"Overview","text":"<p>Comparative virome analysis allows you to understand how viral communities differ across samples, conditions, time points, or environments. This tutorial covers the complete workflow for comparing viromes across multiple samples, including statistical analysis and biological interpretation.</p> <p>What you'll learn: - Design considerations for comparative studies - Batch processing of multiple samples - Viral contig clustering and dereplication - Abundance normalization strategies - Statistical comparison of viral communities - Alpha and beta diversity analysis - Differential abundance testing - Network analysis and visualization</p> <p>Sample dataset: Time-series marine virome (12 samples: 4 time points \u00d7 3 replicates, ~5M reads each)</p>"},{"location":"tutorials/comparative-virome/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/comparative-virome/#required-software","title":"Required Software","text":"<pre><code># Create environment for comparative analysis\nconda create -n comparative_virome python=3.9\nconda activate comparative_virome\n\n# Install analysis tools\nconda install -c bioconda -c conda-forge \\\n    fastp=0.23.4 \\\n    spades=3.15.5 \\\n    virsorter=2.2.4 \\\n    checkv=1.0.1 \\\n    blast=2.14.0 \\\n    prodigal=2.6.3 \\\n    hmmer=3.3.2 \\\n    seqkit=2.5.1 \\\n    bbmap=39.01 \\\n    coverm=0.6.1 \\\n    cd-hit=4.8.1 \\\n    salmon=1.9.0 \\\n    python=3.9 \\\n    r-base=4.2 \\\n    bioconductor-deseq2 \\\n    bioconductor-phyloseq \\\n    r-vegan \\\n    r-ggplot2 \\\n    r-tidyverse \\\n    r-pheatmap\n\n# Install vConTACT2 (for viral clustering)\npip install vcontact2\n\n# Install InStrain (for strain-level analysis)\npip install instrain\n</code></pre>"},{"location":"tutorials/comparative-virome/#system-requirements","title":"System Requirements","text":"<ul> <li>RAM: 64GB minimum (128GB recommended for large datasets)</li> <li>Disk Space: 200GB free</li> <li>CPU: 16+ cores recommended</li> <li>OS: Linux or macOS</li> </ul>"},{"location":"tutorials/comparative-virome/#background-knowledge","title":"Background Knowledge","text":"<p>Complete Tutorial 1 first. Familiarity with: - Statistical concepts (p-values, multiple testing correction) - Community ecology (alpha/beta diversity) - R programming basics</p>"},{"location":"tutorials/comparative-virome/#step-1-experimental-design-and-data-organization","title":"Step 1: Experimental Design and Data Organization","text":""},{"location":"tutorials/comparative-virome/#download-dataset","title":"Download Dataset","text":"<pre><code># Create project directory\nmkdir -p ~/comparative_virome\ncd ~/comparative_virome\n\n# Download time-series marine virome dataset\n# 12 samples: T1, T2, T3, T4 (4 time points) \u00d7 R1, R2, R3 (3 replicates)\nmkdir -p 00_raw_data\n\n# Simulated download (replace with actual Zenodo link)\nfor timepoint in T1 T2 T3 T4; do\n    for replicate in R1 R2 R3; do\n        sample=\"${timepoint}_${replicate}\"\n        echo \"Downloading $sample...\"\n        # wget https://zenodo.org/record/EXAMPLE/files/${sample}_R1.fastq.gz\n        # wget https://zenodo.org/record/EXAMPLE/files/${sample}_R2.fastq.gz\n    done\ndone\n</code></pre>"},{"location":"tutorials/comparative-virome/#create-sample-metadata","title":"Create Sample Metadata","text":"<pre><code># Create metadata file\ncat &gt; sample_metadata.tsv &lt;&lt; 'EOF'\nSample  Timepoint   Replicate   Season  Depth_m Temp_C\nT1_R1   T1  R1  Winter  10  8.5\nT1_R2   T1  R2  Winter  10  8.3\nT1_R3   T1  R3  Winter  10  8.7\nT2_R1   T2  R1  Spring  10  12.1\nT2_R2   T2  R2  Spring  10  12.3\nT2_R3   T2  R3  Spring  10  11.9\nT3_R1   T3  R1  Summer  10  18.4\nT3_R2   T3  R2  Summer  10  18.1\nT3_R3   T3  R3  Summer  10  18.6\nT4_R1   T4  R1  Fall    10  14.2\nT4_R2   T4  R2  Fall    10  14.5\nT4_R3   T4  R3  Fall    10  14.1\nEOF\n\ncat sample_metadata.tsv\n</code></pre> <p>Metadata is Critical</p> <p>Proper metadata is essential for comparative analysis. Include all relevant experimental factors (time, treatment, location, etc.) that might explain viral community variation.</p>"},{"location":"tutorials/comparative-virome/#step-2-batch-quality-control","title":"Step 2: Batch Quality Control","text":"<p>Process all samples identically for fair comparison.</p>"},{"location":"tutorials/comparative-virome/#run-qc-on-all-samples","title":"Run QC on All Samples","text":"<pre><code># Create QC directory\nmkdir -p 01_qc\n\n# Create sample list\nls 00_raw_data/*_R1.fastq.gz | sed 's/_R1.fastq.gz//' | xargs -n1 basename &gt; sample_list.txt\n\n# Batch QC with parallel processing\ncat sample_list.txt | while read sample; do\n    echo \"QC for $sample...\"\n\n    fastp \\\n        -i 00_raw_data/${sample}_R1.fastq.gz \\\n        -I 00_raw_data/${sample}_R2.fastq.gz \\\n        -o 01_qc/${sample}_clean_R1.fastq.gz \\\n        -O 01_qc/${sample}_clean_R2.fastq.gz \\\n        -h 01_qc/${sample}_fastp.html \\\n        -j 01_qc/${sample}_fastp.json \\\n        --detect_adapter_for_pe \\\n        --correction \\\n        --cut_front \\\n        --cut_tail \\\n        --cut_window_size 4 \\\n        --cut_mean_quality 20 \\\n        --qualified_quality_phred 20 \\\n        --length_required 50 \\\n        --thread 4\n\ndone\n\n# Summarize QC results\npython3 &lt;&lt; 'EOF'\nimport json\nimport pandas as pd\n\nqc_summary = []\n\nwith open('sample_list.txt') as f:\n    for line in f:\n        sample = line.strip()\n        json_file = f'01_qc/{sample}_fastp.json'\n\n        try:\n            with open(json_file) as jf:\n                data = json.load(jf)\n\n                qc_summary.append({\n                    'Sample': sample,\n                    'Total_Reads': data['summary']['before_filtering']['total_reads'],\n                    'Reads_After_QC': data['summary']['after_filtering']['total_reads'],\n                    'QC_Pass_Rate': data['summary']['after_filtering']['total_reads'] / data['summary']['before_filtering']['total_reads'] * 100,\n                    'Q30_Rate': data['summary']['after_filtering']['q30_rate']\n                })\n        except:\n            print(f\"Warning: Could not parse {json_file}\")\n\ndf = pd.DataFrame(qc_summary)\ndf.to_csv('01_qc/qc_summary.tsv', sep='\\t', index=False)\nprint(df)\nprint(f\"\\nMean QC pass rate: {df['QC_Pass_Rate'].mean():.1f}%\")\nEOF\n</code></pre> <p>Expected QC results: - QC pass rate: 85-95% for all samples - Q30 rate: &gt;90% - Consistent across samples (CV &lt;10%)</p>"},{"location":"tutorials/comparative-virome/#step-3-co-assembly-strategy","title":"Step 3: Co-Assembly Strategy","text":"<p>For comparative analysis, we can either: 1. Co-assemble all samples together (finds shared viruses) 2. Assemble each sample individually (finds sample-specific viruses) 3. Hybrid approach (recommended)</p> <p>We'll use the hybrid approach.</p>"},{"location":"tutorials/comparative-virome/#31-co-assembly","title":"3.1 Co-Assembly","text":"<pre><code># Create assembly directory\nmkdir -p 02_assembly/co_assembly\n\n# Concatenate all cleaned reads for co-assembly\ncat 01_qc/*_clean_R1.fastq.gz &gt; 02_assembly/co_assembly/all_R1.fastq.gz\ncat 01_qc/*_clean_R2.fastq.gz &gt; 02_assembly/co_assembly/all_R2.fastq.gz\n\n# Run metaviralSPAdes on combined dataset\nspades.py \\\n    --metaviral \\\n    -1 02_assembly/co_assembly/all_R1.fastq.gz \\\n    -2 02_assembly/co_assembly/all_R2.fastq.gz \\\n    -o 02_assembly/co_assembly/metaviralspades \\\n    -t 16 \\\n    -m 100\n\n# Filter contigs \u22652kb (slightly higher than single sample)\nseqkit seq -m 2000 02_assembly/co_assembly/metaviralspades/contigs.fasta \\\n    &gt; 02_assembly/co_assembly_contigs_2kb.fasta\n\nseqkit stats 02_assembly/co_assembly_contigs_2kb.fasta\n</code></pre> <p>Expected co-assembly: - Total contigs \u22652kb: 2,000-5,000 - N50: 8-20 kb - Longest contig: 100-300 kb</p>"},{"location":"tutorials/comparative-virome/#32-individual-sample-assemblies-optional","title":"3.2 Individual Sample Assemblies (Optional)","text":"<pre><code># Assemble each sample individually (in parallel)\nmkdir -p 02_assembly/individual\n\ncat sample_list.txt | while read sample; do\n    echo \"Assembling $sample...\"\n\n    spades.py \\\n        --metaviral \\\n        -1 01_qc/${sample}_clean_R1.fastq.gz \\\n        -2 01_qc/${sample}_clean_R2.fastq.gz \\\n        -o 02_assembly/individual/${sample} \\\n        -t 4 \\\n        -m 16 &amp;\n\n    # Control parallel jobs (max 4 assemblies at once)\n    if (( $(jobs -r | wc -l) &gt;= 4 )); then\n        wait -n\n    fi\ndone\n\nwait  # Wait for all assemblies to complete\n\n# Filter and combine individual assemblies\ncat 02_assembly/individual/*/contigs.fasta | \\\n    seqkit seq -m 2000 &gt; 02_assembly/individual_contigs_2kb.fasta\n</code></pre>"},{"location":"tutorials/comparative-virome/#33-dereplicate-combined-contigs","title":"3.3 Dereplicate Combined Contigs","text":"<pre><code># Combine co-assembly and individual assemblies\ncat 02_assembly/co_assembly_contigs_2kb.fasta \\\n    02_assembly/individual_contigs_2kb.fasta \\\n    &gt; 02_assembly/combined_all_contigs.fasta\n\n# Dereplicate with CD-HIT-EST (95% identity, 90% coverage)\ncd-hit-est \\\n    -i 02_assembly/combined_all_contigs.fasta \\\n    -o 02_assembly/dereplicated_contigs.fasta \\\n    -c 0.95 \\\n    -aS 0.90 \\\n    -M 32000 \\\n    -T 16\n\nseqkit stats 02_assembly/dereplicated_contigs.fasta\n</code></pre> <p>Expected after dereplication: - Non-redundant contigs: 3,000-7,000 - Deduplication rate: ~30-50%</p>"},{"location":"tutorials/comparative-virome/#step-4-viral-identification","title":"Step 4: Viral Identification","text":""},{"location":"tutorials/comparative-virome/#run-virsorter2-on-dereplicated-contigs","title":"Run VirSorter2 on Dereplicated Contigs","text":"<pre><code># Create viral ID directory\nmkdir -p 03_viral_id\n\n# Run VirSorter2\nvirsorter run \\\n    -w 03_viral_id/virsorter2 \\\n    -i 02_assembly/dereplicated_contigs.fasta \\\n    --min-length 2000 \\\n    --min-score 0.5 \\\n    --include-groups dsDNAphage,ssDNA \\\n    -j 16 \\\n    all\n\n# Extract viral contigs\ncp 03_viral_id/virsorter2/final-viral-combined.fa 03_viral_id/viral_contigs.fasta\n\n# Count\ngrep -c \"&gt;\" 03_viral_id/viral_contigs.fasta\n</code></pre>"},{"location":"tutorials/comparative-virome/#quality-assessment-with-checkv","title":"Quality Assessment with CheckV","text":"<pre><code># Create CheckV directory\nmkdir -p 04_checkv\n\n# Run CheckV\ncheckv end_to_end \\\n    03_viral_id/viral_contigs.fasta \\\n    04_checkv \\\n    -t 16 \\\n    -d /path/to/checkv-db-v1.5\n\n# Filter for medium-quality and above\nawk -F'\\t' '$8 == \"Complete\" || $8 == \"High-quality\" || $8 == \"Medium-quality\" {print $1}' \\\n    04_checkv/quality_summary.tsv \\\n    &gt; 04_checkv/good_quality_ids.txt\n\nseqkit grep -f 04_checkv/good_quality_ids.txt \\\n    03_viral_id/viral_contigs.fasta \\\n    &gt; 04_checkv/viral_contigs_hq.fasta\n\necho \"High-quality viral contigs: $(grep -c \"&gt;\" 04_checkv/viral_contigs_hq.fasta)\"\n</code></pre> <p>Expected viral identification: - Viral contigs: 800-2,000 - High + Medium quality: 400-1,200</p>"},{"location":"tutorials/comparative-virome/#step-5-viral-contig-clustering-votus","title":"Step 5: Viral Contig Clustering (vOTUs)","text":"<p>Create viral Operational Taxonomic Units (vOTUs) - groups of similar viruses.</p>"},{"location":"tutorials/comparative-virome/#51-cluster-at-95-ani","title":"5.1 Cluster at 95% ANI","text":"<pre><code># Create vOTU directory\nmkdir -p 05_vOTUs\n\n# Cluster with CD-HIT-EST (95% identity = species-level)\ncd-hit-est \\\n    -i 04_checkv/viral_contigs_hq.fasta \\\n    -o 05_vOTUs/vOTUs_95.fasta \\\n    -c 0.95 \\\n    -aS 0.85 \\\n    -M 32000 \\\n    -T 16\n\n# Parse cluster file to create OTU table\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Parse CD-HIT cluster file\nclusters = {}\ncluster_id = 0\n\nwith open('05_vOTUs/vOTUs_95.fasta.clstr') as f:\n    for line in f:\n        if line.startswith('&gt;'):\n            cluster_id = int(line.strip().split()[1])\n        else:\n            # Extract contig name\n            contig = line.split('&gt;')[1].split('...')[0]\n            is_representative = '*' in line\n\n            clusters[contig] = {\n                'vOTU_ID': f'vOTU_{cluster_id}',\n                'is_representative': is_representative\n            }\n\n# Save mapping\ndf = pd.DataFrame.from_dict(clusters, orient='index')\ndf.index.name = 'contig_id'\ndf.to_csv('05_vOTUs/contig_to_vOTU_mapping.tsv', sep='\\t')\n\nprint(f\"Total vOTUs (95% ANI): {len(df['vOTU_ID'].unique())}\")\nprint(f\"Total contigs: {len(df)}\")\nprint(f\"Mean contigs per vOTU: {len(df) / len(df['vOTU_ID'].unique()):.1f}\")\nEOF\n</code></pre> <p>Expected vOTU clustering: - vOTUs (95% ANI): 300-800 - Contigs per vOTU: 1-5 (mean ~1.5)</p>"},{"location":"tutorials/comparative-virome/#step-6-abundance-profiling-across-all-samples","title":"Step 6: Abundance Profiling Across All Samples","text":"<p>Map reads from each sample to the dereplicated viral contigs.</p>"},{"location":"tutorials/comparative-virome/#61-read-mapping-with-coverm","title":"6.1 Read Mapping with CoverM","text":"<pre><code># Create abundance directory\nmkdir -p 06_abundance\n\n# Map all samples to viral contigs using CoverM (batch mode)\ncoverm contig \\\n    --coupled $(ls 01_qc/*_clean_R1.fastq.gz | tr '\\n' ' ') \\\n    --reference 04_checkv/viral_contigs_hq.fasta \\\n    --methods mean trimmed_mean covered_fraction \\\n    --min-covered-fraction 0 \\\n    --min-read-percent-identity 95 \\\n    --threads 16 \\\n    --output-file 06_abundance/viral_coverage_all_samples.tsv\n\n# Convert to vOTU-level abundance table\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load coverage data\ncoverage = pd.read_csv('06_abundance/viral_coverage_all_samples.tsv', sep='\\t')\n\n# Load vOTU mapping\nvotu_map = pd.read_csv('05_vOTUs/contig_to_vOTU_mapping.tsv', sep='\\t')\n\n# Merge coverage with vOTU assignments\nmerged = coverage.merge(votu_map, left_on='Contig', right_on='contig_id', how='left')\n\n# Sum abundance for each vOTU (across member contigs)\n# Group by vOTU and sample, sum coverage\n\n# Reshape to wide format (vOTUs \u00d7 samples)\n# This is simplified - full implementation would aggregate across samples properly\n\n# For tutorial, we'll use the contig-level table\n# In practice, you'd aggregate to vOTU level here\n\nprint(\"Coverage matrix created\")\n# coverage.to_csv('06_abundance/vOTU_abundance_table.tsv', sep='\\t', index=False)\nEOF\n</code></pre>"},{"location":"tutorials/comparative-virome/#62-normalize-abundance","title":"6.2 Normalize Abundance","text":"<pre><code># Create normalized abundance table\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport numpy as np\n\n# Load abundance table\n# Assuming columns: Contig, Sample1_Mean, Sample2_Mean, ...\nabundance = pd.read_csv('06_abundance/viral_coverage_all_samples.tsv', sep='\\t')\n\n# Extract sample columns (those ending with \"Mean\")\nsample_cols = [col for col in abundance.columns if 'Mean' in col]\n\n# Calculate relative abundance (normalize to proportions)\nabundance_rel = abundance.copy()\nfor col in sample_cols:\n    total = abundance[col].sum()\n    if total &gt; 0:\n        abundance_rel[col] = abundance[col] / total * 100  # Convert to percentage\n\nabundance_rel.to_csv('06_abundance/viral_abundance_relative.tsv', sep='\\t', index=False)\n\n# Calculate presence/absence (binary)\nabundance_pa = abundance.copy()\nfor col in sample_cols:\n    abundance_pa[col] = (abundance[col] &gt; 0).astype(int)\n\nabundance_pa.to_csv('06_abundance/viral_presence_absence.tsv', sep='\\t', index=False)\n\nprint(\"Normalized abundance tables created\")\nEOF\n</code></pre>"},{"location":"tutorials/comparative-virome/#step-7-statistical-analysis-in-r","title":"Step 7: Statistical Analysis in R","text":""},{"location":"tutorials/comparative-virome/#71-alpha-diversity","title":"7.1 Alpha Diversity","text":"<pre><code>#!/usr/bin/env Rscript\n\nlibrary(vegan)\nlibrary(ggplot2)\nlibrary(tidyverse)\n\n# Load abundance table\nabundance &lt;- read.delim('06_abundance/viral_coverage_all_samples.tsv', row.names=1)\n\n# Transpose (samples as rows, vOTUs as columns)\nabundance_t &lt;- t(abundance)\n\n# Calculate richness (number of vOTUs per sample)\nrichness &lt;- rowSums(abundance_t &gt; 0)\n\n# Calculate Shannon diversity\nshannon &lt;- diversity(abundance_t, index='shannon')\n\n# Calculate Simpson diversity\nsimpson &lt;- diversity(abundance_t, index='simpson')\n\n# Combine into data frame\nalpha_diversity &lt;- data.frame(\n  Sample = rownames(abundance_t),\n  Richness = richness,\n  Shannon = shannon,\n  Simpson = simpson\n)\n\n# Add metadata\nmetadata &lt;- read.delim('sample_metadata.tsv')\nalpha_diversity &lt;- merge(alpha_diversity, metadata, by='Sample')\n\n# Save\nwrite.table(alpha_diversity, '07_statistics/alpha_diversity.tsv',\n            sep='\\t', row.names=FALSE, quote=FALSE)\n\n# Plot richness by timepoint\npdf('07_statistics/alpha_diversity_richness.pdf', width=8, height=6)\nggplot(alpha_diversity, aes(x=Timepoint, y=Richness, fill=Timepoint)) +\n  geom_boxplot() +\n  geom_jitter(width=0.2) +\n  labs(title='Viral Richness Across Timepoints',\n       x='Timepoint', y='Number of vOTUs') +\n  theme_minimal()\ndev.off()\n\n# Plot Shannon diversity\npdf('07_statistics/alpha_diversity_shannon.pdf', width=8, height=6)\nggplot(alpha_diversity, aes(x=Timepoint, y=Shannon, fill=Timepoint)) +\n  geom_boxplot() +\n  geom_jitter(width=0.2) +\n  labs(title='Viral Shannon Diversity Across Timepoints',\n       x='Timepoint', y='Shannon Index') +\n  theme_minimal()\ndev.off()\n\n# Statistical test (ANOVA)\nanova_result &lt;- aov(Richness ~ Timepoint, data=alpha_diversity)\nsummary(anova_result)\n\n# Post-hoc test (Tukey HSD)\ntukey_result &lt;- TukeyHSD(anova_result)\nprint(tukey_result)\n</code></pre>"},{"location":"tutorials/comparative-virome/#72-beta-diversity","title":"7.2 Beta Diversity","text":"<pre><code># Calculate beta diversity (Bray-Curtis dissimilarity)\nlibrary(vegan)\nlibrary(ggplot2)\n\n# Load abundance table\nabundance &lt;- read.delim('06_abundance/viral_coverage_all_samples.tsv', row.names=1)\nabundance_t &lt;- t(abundance)\n\n# Calculate Bray-Curtis dissimilarity\nbray_dist &lt;- vegdist(abundance_t, method='bray')\n\n# Perform NMDS ordination\nset.seed(123)\nnmds &lt;- metaMDS(abundance_t, distance='bray', k=2, trymax=100)\n\n# Extract NMDS scores\nnmds_scores &lt;- as.data.frame(scores(nmds))\nnmds_scores$Sample &lt;- rownames(nmds_scores)\n\n# Merge with metadata\nmetadata &lt;- read.delim('sample_metadata.tsv')\nnmds_scores &lt;- merge(nmds_scores, metadata, by='Sample')\n\n# Plot NMDS\npdf('07_statistics/beta_diversity_nmds.pdf', width=10, height=8)\nggplot(nmds_scores, aes(x=NMDS1, y=NMDS2, color=Timepoint, shape=Replicate)) +\n  geom_point(size=4) +\n  stat_ellipse(aes(group=Timepoint), linetype=2) +\n  labs(title=paste0('NMDS of Viral Communities (Stress=', round(nmds$stress, 3), ')'),\n       x='NMDS1', y='NMDS2') +\n  theme_minimal()\ndev.off()\n\n# PERMANOVA (test for significant differences between groups)\nmetadata_for_test &lt;- metadata[match(rownames(abundance_t), metadata$Sample), ]\npermanova &lt;- adonis2(abundance_t ~ Timepoint, data=metadata_for_test, method='bray')\nprint(permanova)\n\n# Save results\nwrite.table(nmds_scores, '07_statistics/nmds_scores.tsv',\n            sep='\\t', row.names=FALSE, quote=FALSE)\n</code></pre>"},{"location":"tutorials/comparative-virome/#73-differential-abundance-with-deseq2","title":"7.3 Differential Abundance with DESeq2","text":"<pre><code># Identify vOTUs that change significantly across timepoints\nlibrary(DESeq2)\nlibrary(ggplot2)\n\n# Load abundance table (raw counts)\ncounts &lt;- read.delim('06_abundance/viral_coverage_all_samples.tsv', row.names=1)\n\n# Round to integers (DESeq2 requires count data)\ncounts_int &lt;- round(counts)\n\n# Load metadata\nmetadata &lt;- read.delim('sample_metadata.tsv', row.names=1)\n\n# Ensure sample order matches\nmetadata &lt;- metadata[colnames(counts_int), ]\n\n# Create DESeq2 object\ndds &lt;- DESeqDataSetFromMatrix(\n  countData = counts_int,\n  colData = metadata,\n  design = ~ Timepoint\n)\n\n# Run DESeq2\ndds &lt;- DESeq(dds)\n\n# Extract results (T1 vs T3, for example)\nres &lt;- results(dds, contrast=c('Timepoint', 'T3', 'T1'))\n\n# Filter significant vOTUs (padj &lt; 0.05, |log2FC| &gt; 1)\nsig_votus &lt;- subset(res, padj &lt; 0.05 &amp; abs(log2FoldChange) &gt; 1)\n\n# Save\nwrite.csv(as.data.frame(sig_votus), '07_statistics/differential_abundance_T3_vs_T1.csv')\n\nprint(paste('Significantly different vOTUs:', nrow(sig_votus)))\n\n# MA plot\npdf('07_statistics/deseq2_MA_plot.pdf', width=8, height=6)\nplotMA(res, ylim=c(-5,5), main='Differential Abundance (T3 vs T1)')\ndev.off()\n\n# Volcano plot\npdf('07_statistics/deseq2_volcano_plot.pdf', width=8, height=6)\nres_df &lt;- as.data.frame(res)\nres_df$significant &lt;- res_df$padj &lt; 0.05 &amp; abs(res_df$log2FoldChange) &gt; 1\n\nggplot(res_df, aes(x=log2FoldChange, y=-log10(padj), color=significant)) +\n  geom_point(alpha=0.6) +\n  scale_color_manual(values=c('grey', 'red')) +\n  geom_hline(yintercept=-log10(0.05), linetype='dashed') +\n  geom_vline(xintercept=c(-1, 1), linetype='dashed') +\n  labs(title='Volcano Plot: Differential Abundance (T3 vs T1)',\n       x='Log2 Fold Change', y='-Log10(Adjusted P-value)') +\n  theme_minimal()\ndev.off()\n</code></pre>"},{"location":"tutorials/comparative-virome/#step-8-visualization-and-heatmaps","title":"Step 8: Visualization and Heatmaps","text":""},{"location":"tutorials/comparative-virome/#create-heatmap-of-top-votus","title":"Create Heatmap of Top vOTUs","text":"<pre><code>library(pheatmap)\n\n# Load abundance data\nabundance &lt;- read.delim('06_abundance/viral_abundance_relative.tsv', row.names=1)\n\n# Select top 50 most abundant vOTUs (by mean abundance)\nmean_abundance &lt;- rowMeans(abundance)\ntop50_votus &lt;- names(sort(mean_abundance, decreasing=TRUE)[1:50])\n\nabundance_top50 &lt;- abundance[top50_votus, ]\n\n# Load metadata\nmetadata &lt;- read.delim('sample_metadata.tsv', row.names=1)\n\n# Create annotation for heatmap\nannotation_col &lt;- data.frame(\n  Timepoint = metadata$Timepoint,\n  Season = metadata$Season\n)\nrownames(annotation_col) &lt;- rownames(metadata)\n\n# Create heatmap\npdf('08_visualization/heatmap_top50_vOTUs.pdf', width=12, height=14)\npheatmap(\n  log10(abundance_top50 + 1),  # Log transform\n  annotation_col = annotation_col,\n  cluster_rows = TRUE,\n  cluster_cols = TRUE,\n  show_rownames = FALSE,\n  main = 'Top 50 vOTUs Across Samples (log10 relative abundance)',\n  color = colorRampPalette(c('white', 'yellow', 'orange', 'red'))(50)\n)\ndev.off()\n</code></pre>"},{"location":"tutorials/comparative-virome/#step-9-summary-and-interpretation","title":"Step 9: Summary and Interpretation","text":""},{"location":"tutorials/comparative-virome/#generate-comprehensive-report","title":"Generate Comprehensive Report","text":"<pre><code># Create final summary directory\nmkdir -p 09_summary\n\n# Summary statistics\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport numpy as np\n\n# Load all results\nalpha_div = pd.read_csv('07_statistics/alpha_diversity.tsv', sep='\\t')\ndeseq_res = pd.read_csv('07_statistics/differential_abundance_T3_vs_T1.csv', index_col=0)\n\nprint(\"=== Comparative Virome Analysis Summary ===\\n\")\n\nprint(f\"Samples analyzed: {len(alpha_div)}\")\nprint(f\"Timepoints: {alpha_div['Timepoint'].nunique()}\")\nprint(f\"Replicates per timepoint: {alpha_div.groupby('Timepoint').size()[0]}\")\n\nprint(\"\\nAlpha diversity summary:\")\nprint(f\"  Mean richness: {alpha_div['Richness'].mean():.1f} \u00b1 {alpha_div['Richness'].std():.1f} vOTUs\")\nprint(f\"  Range: {alpha_div['Richness'].min()} - {alpha_div['Richness'].max()} vOTUs\")\n\nprint(\"\\nDifferential abundance (T3 vs T1):\")\nprint(f\"  Significantly different vOTUs: {len(deseq_res[deseq_res['padj'] &lt; 0.05])}\")\nprint(f\"  Enriched in T3: {len(deseq_res[(deseq_res['padj'] &lt; 0.05) &amp; (deseq_res['log2FoldChange'] &gt; 1)])}\")\nprint(f\"  Enriched in T1: {len(deseq_res[(deseq_res['padj'] &lt; 0.05) &amp; (deseq_res['log2FoldChange'] &lt; -1)])}\")\nEOF\n</code></pre>"},{"location":"tutorials/comparative-virome/#expected-final-results","title":"Expected Final Results","text":""},{"location":"tutorials/comparative-virome/#typical-findings","title":"Typical Findings","text":"<ul> <li>Total viral contigs: 800-2,000</li> <li>vOTUs (95% ANI): 300-800</li> <li>Mean richness per sample: 100-300 vOTUs</li> <li>Shannon diversity: 3.5-4.5</li> <li>Significant temporal changes: 20-40% of vOTUs</li> <li>Beta diversity: Clear separation by time (stress &lt;0.15)</li> </ul>"},{"location":"tutorials/comparative-virome/#biological-interpretation","title":"Biological Interpretation","text":"<p>Temporal patterns: - Viral diversity may peak in spring/summer - Community composition shifts with temperature - Some vOTUs are persistent, others are transient</p> <p>Statistical significance: - PERMANOVA p &lt; 0.05 indicates communities differ by time - DESeq2 identifies specific vOTUs driving differences - Replicate consistency validates findings</p>"},{"location":"tutorials/comparative-virome/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/comparative-virome/#problem-high-stress-in-nmds","title":"Problem: High Stress in NMDS","text":"<p>Solutions: <pre><code># Increase dimensions\nnmds &lt;- metaMDS(abundance_t, k=3, trymax=200)\n\n# Try different distance metric\njaccard_dist &lt;- vegdist(abundance_t, method='jaccard')\n</code></pre></p>"},{"location":"tutorials/comparative-virome/#problem-no-significant-differences","title":"Problem: No Significant Differences","text":"<p>Possible causes: - True biological similarity - Insufficient replication - High variability</p> <p>Solutions: - Increase sample size - Use non-parametric tests (Kruskal-Wallis) - Focus on effect sizes, not just p-values</p>"},{"location":"tutorials/comparative-virome/#further-reading","title":"Further Reading","text":"<ul> <li>Gregory, A. C., et al. (2019). \"Marine DNA viral macro- and microdiversity from pole to pole.\" Cell, 177(5), 1109-1123.</li> <li>Roux, S., et al. (2019). \"Minimum information about an uncultivated virus genome (MIUViG).\" Nature Biotechnology, 37(1), 29-37.</li> </ul>"},{"location":"tutorials/host-prediction-workflows/","title":"Tutorial 5: Host Prediction Workflows","text":"<p>Last Updated: November 29, 2025 Level: Advanced | Time: 6-10 hours | Data Size: 200MB</p>"},{"location":"tutorials/host-prediction-workflows/#overview","title":"Overview","text":"<p>Predicting the bacterial hosts of newly discovered phages is one of the most challenging problems in virome analysis. This tutorial covers multiple complementary approaches for host prediction, from high-confidence CRISPR spacer matching to machine learning-based predictions.</p> <p>What you'll learn: - CRISPR spacer-based host assignment (gold standard) - Sequence homology approaches (BLAST, protein clustering) - Machine learning predictions (iPHoP, CHERRY, WIsH) - Co-occurrence and correlation analysis - Consensus prediction strategies - Validation and confidence assessment</p> <p>Sample dataset: Environmental phage contigs (500 contigs) + matching bacterial metagenome (100 MAGs)</p> <p>Realistic Expectations</p> <p>Host prediction is difficult! Even with multiple methods, expect: - 30-60% prediction rate (many phages will have no confident prediction) - 30-50% accuracy at genus level for novel phages - High confidence only for ~10-20% of predictions (CRISPR spacer matches)</p>"},{"location":"tutorials/host-prediction-workflows/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/host-prediction-workflows/#required-software","title":"Required Software","text":"<pre><code># Create environment for host prediction\nconda create -n host_prediction python=3.9\nconda activate host_prediction\n\n# Install host prediction tools\nconda install -c bioconda -c conda-forge \\\n    blast=2.14.0 \\\n    hmmer=3.3.2 \\\n    prodigal=2.6.3 \\\n    minced=0.4.2 \\\n    pilercr=1.06 \\\n    bedtools=2.30.0 \\\n    seqkit=2.5.1 \\\n    mash=2.3 \\\n    diamond=2.1.0 \\\n    mmseqs2=14.7e284\n\n# Install iPHoP (comprehensive host prediction)\nconda install -c conda-forge -c bioconda iphop=1.3.0\n\n# Download iPHoP database (large, ~120GB)\niphop download --db_path iphop_db/\n\n# Install CHERRY (deep learning)\npip install cherry-phage\n\n# Install WIsH (homology-based)\ngit clone https://github.com/soedinglab/WIsH.git ~/tools/WIsH\ncd ~/tools/WIsH\ncmake .\nmake\nexport PATH=$PATH:$(pwd)/bin\n\ncd ~/host_prediction\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#system-requirements","title":"System Requirements","text":"<ul> <li>RAM: 64GB minimum (iPHoP database is large)</li> <li>Disk Space: 150GB (databases)</li> <li>CPU: 16+ cores recommended</li> <li>OS: Linux (some tools are Linux-only)</li> </ul>"},{"location":"tutorials/host-prediction-workflows/#background-knowledge","title":"Background Knowledge","text":"<p>Complete Tutorial 1 and review: - CRISPR-Cas systems and spacer acquisition - Phage-host interactions - Metagenome-assembled genomes (MAGs)</p>"},{"location":"tutorials/host-prediction-workflows/#step-1-prepare-data","title":"Step 1: Prepare Data","text":""},{"location":"tutorials/host-prediction-workflows/#download-dataset","title":"Download Dataset","text":"<pre><code># Create project directory\nmkdir -p ~/host_prediction\ncd ~/host_prediction\n\n# Download phage contigs (from virome analysis)\nmkdir -p 00_data\n\n# Simulated dataset (replace with actual Zenodo)\n# wget https://zenodo.org/record/EXAMPLE/files/environmental_phages.fasta\n# wget https://zenodo.org/record/EXAMPLE/files/bacterial_MAGs.tar.gz\n\n# For tutorial: 500 phage contigs, 100 bacterial MAGs\n# tar -xzf bacterial_MAGs.tar.gz -C 00_data/MAGs/\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#inspect-data","title":"Inspect Data","text":"<pre><code># Check phage contigs\nseqkit stats 00_data/environmental_phages.fasta\n\n# Check bacterial MAGs\nfor mag in 00_data/MAGs/*.fa; do\n    seqkit stats $mag\ndone | head\n\n# Expected:\n# 500 phage contigs, 5-150 kb each\n# 100 bacterial MAGs, 1-6 Mb each, 50-100% complete\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#step-2-crispr-spacer-based-host-prediction","title":"Step 2: CRISPR Spacer-Based Host Prediction","text":"<p>CRISPR spacer matches are the \"gold standard\" for host prediction (highest confidence).</p>"},{"location":"tutorials/host-prediction-workflows/#21-extract-crispr-spacers-from-bacterial-mags","title":"2.1 Extract CRISPR Spacers from Bacterial MAGs","text":"<pre><code># Create CRISPR directory\nmkdir -p 01_crispr\n\n# Extract CRISPR arrays using PILER-CR\nmkdir -p 01_crispr/pilercr\n\nfor mag in 00_data/MAGs/*.fa; do\n    basename=$(basename $mag .fa)\n    echo \"Extracting CRISPRs from $basename...\"\n\n    pilercr \\\n        -in $mag \\\n        -out 01_crispr/pilercr/${basename}_pilercr.txt \\\n        -noinfo\n\ndone\n\n# Also use minced (alternative CRISPR finder)\nmkdir -p 01_crispr/minced\n\nfor mag in 00_data/MAGs/*.fa; do\n    basename=$(basename $mag .fa)\n\n    minced \\\n        -gff 01_crispr/minced/${basename}_minced.gff \\\n        -spacers 01_crispr/minced/${basename}_spacers.fa \\\n        $mag \\\n        01_crispr/minced/${basename}_minced.txt\n\ndone\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#22-combine-all-crispr-spacers","title":"2.2 Combine All CRISPR Spacers","text":"<pre><code># Combine all spacers into single file\ncat 01_crispr/minced/*_spacers.fa &gt; 01_crispr/all_crispr_spacers.fasta\n\n# Add MAG name to spacer headers\npython3 &lt;&lt; 'EOF'\nfrom Bio import SeqIO\n\nspacers_with_source = []\n\nfor record in SeqIO.parse('01_crispr/all_crispr_spacers.fasta', 'fasta'):\n    # Extract MAG name from spacer ID\n    # Assuming format: MAG_001 CRISPR1 Spacer1\n    parts = record.description.split()\n    mag_id = parts[0]\n\n    # Modify header to include MAG source\n    record.id = f\"{mag_id}_{record.id}\"\n    record.description = f\"MAG={mag_id} {record.description}\"\n\n    spacers_with_source.append(record)\n\nSeqIO.write(spacers_with_source, '01_crispr/spacers_with_source.fasta', 'fasta')\nprint(f\"Total CRISPR spacers: {len(spacers_with_source)}\")\nEOF\n\n# Count spacers per MAG\necho \"Spacers per MAG:\"\ngrep \"&gt;\" 01_crispr/spacers_with_source.fasta | cut -d'_' -f1-2 | sort | uniq -c | head -20\n</code></pre> <p>Expected CRISPR results: - MAGs with CRISPRs: 30-60% (not all bacteria have CRISPR systems) - Spacers per MAG: 0-200 (highly variable) - Total spacers: 1,000-10,000</p>"},{"location":"tutorials/host-prediction-workflows/#23-blast-spacers-against-phage-contigs","title":"2.3 BLAST Spacers Against Phage Contigs","text":"<pre><code># Create BLAST database from phage contigs\nmakeblastdb \\\n    -in 00_data/environmental_phages.fasta \\\n    -dbtype nucl \\\n    -out 01_crispr/phage_db\n\n# BLAST spacers against phages (very stringent parameters)\nblastn \\\n    -query 01_crispr/spacers_with_source.fasta \\\n    -db 01_crispr/phage_db \\\n    -out 01_crispr/spacer_phage_matches.txt \\\n    -outfmt '6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore qlen slen' \\\n    -evalue 1 \\\n    -word_size 7 \\\n    -reward 1 \\\n    -penalty -1 \\\n    -gapopen 2 \\\n    -gapextend 1 \\\n    -num_threads 16\n\n# Filter for high-confidence matches\n# Criteria: \u226595% identity, \u226590% coverage, \u22641 mismatch\nawk '$3 &gt;= 95 &amp;&amp; $4 &gt;= 0.9*$13 &amp;&amp; $5 &lt;= 1 {print $0}' \\\n    01_crispr/spacer_phage_matches.txt \\\n    &gt; 01_crispr/high_confidence_spacer_matches.txt\n\n# Extract host predictions from CRISPR matches\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load CRISPR matches\nmatches = pd.read_csv('01_crispr/high_confidence_spacer_matches.txt', sep='\\t',\n                      header=None, names=['spacer', 'phage', 'pident', 'length',\n                                          'mismatch', 'gapopen', 'qstart', 'qend',\n                                          'sstart', 'send', 'evalue', 'bitscore',\n                                          'qlen', 'slen'])\n\n# Extract MAG ID from spacer name\nmatches['MAG_ID'] = matches['spacer'].str.split('_').str[0:2].str.join('_')\n\n# Extract phage ID (contig name)\nmatches['Phage_ID'] = matches['phage']\n\n# Create host predictions\nhost_predictions_crispr = matches[['Phage_ID', 'MAG_ID', 'pident', 'mismatch']].copy()\nhost_predictions_crispr['Method'] = 'CRISPR'\nhost_predictions_crispr['Confidence'] = 'High'\n\n# Save\nhost_predictions_crispr.to_csv('01_crispr/crispr_host_predictions.tsv',\n                               sep='\\t', index=False)\n\nprint(f\"CRISPR-based host predictions: {len(host_predictions_crispr)}\")\nprint(f\"Phages with CRISPR match: {host_predictions_crispr['Phage_ID'].nunique()}\")\nprint(f\"Prediction rate: {host_predictions_crispr['Phage_ID'].nunique() / 500 * 100:.1f}%\")\nEOF\n</code></pre> <p>Expected CRISPR predictions: - Phages with CRISPR match: 10-50 (2-10% of phages) - Confidence: Very high (these are the best predictions)</p> <p>CRISPR Spacer Matches</p> <p>CRISPR spacer matches are the highest-confidence host predictions (~90-95% accuracy). However, they're only available for a small fraction of phages.</p>"},{"location":"tutorials/host-prediction-workflows/#step-3-sequence-homology-based-prediction","title":"Step 3: Sequence Homology-Based Prediction","text":""},{"location":"tutorials/host-prediction-workflows/#31-protein-blast-against-bacterial-proteins","title":"3.1 Protein BLAST Against Bacterial Proteins","text":"<pre><code># Create homology directory\nmkdir -p 02_homology\n\n# Predict phage proteins\nprodigal \\\n    -i 00_data/environmental_phages.fasta \\\n    -a 02_homology/phage_proteins.faa \\\n    -p meta \\\n    -q\n\n# Predict MAG proteins\nmkdir -p 02_homology/MAG_proteins\n\nfor mag in 00_data/MAGs/*.fa; do\n    basename=$(basename $mag .fa)\n\n    prodigal \\\n        -i $mag \\\n        -a 02_homology/MAG_proteins/${basename}.faa \\\n        -p single \\\n        -q\ndone\n\n# Combine all MAG proteins\ncat 02_homology/MAG_proteins/*.faa &gt; 02_homology/all_MAG_proteins.faa\n\n# Create DIAMOND database (faster than BLAST)\ndiamond makedb \\\n    --in 02_homology/all_MAG_proteins.faa \\\n    --db 02_homology/MAG_proteins_db\n\n# BLAST phage proteins against MAG proteins\ndiamond blastp \\\n    --query 02_homology/phage_proteins.faa \\\n    --db 02_homology/MAG_proteins_db \\\n    --out 02_homology/phage_MAG_blastp.txt \\\n    --outfmt 6 qseqid sseqid pident length evalue bitscore \\\n    --evalue 1e-5 \\\n    --max-target-seqs 100 \\\n    --threads 16\n\n# Count hits per phage contig\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load BLAST results\nblast = pd.read_csv('02_homology/phage_MAG_blastp.txt', sep='\\t',\n                    header=None, names=['phage_protein', 'mag_protein',\n                                        'pident', 'length', 'evalue', 'bitscore'])\n\n# Extract contig and MAG IDs\nblast['Phage_ID'] = blast['phage_protein'].str.rsplit('_', n=1).str[0]\nblast['MAG_ID'] = blast['mag_protein'].str.rsplit('_', n=1).str[0]\n\n# Count hits per phage-MAG pair\nhit_counts = blast.groupby(['Phage_ID', 'MAG_ID']).size().reset_index(name='Hit_Count')\n\n# For each phage, select MAG with most hits\nbest_matches = hit_counts.loc[hit_counts.groupby('Phage_ID')['Hit_Count'].idxmax()]\n\n# Filter: require \u22653 protein hits\nbest_matches = best_matches[best_matches['Hit_Count'] &gt;= 3]\n\n# Save\nbest_matches['Method'] = 'Protein_Homology'\nbest_matches['Confidence'] = 'Medium'\nbest_matches.to_csv('02_homology/homology_host_predictions.tsv', sep='\\t', index=False)\n\nprint(f\"Homology-based host predictions: {len(best_matches)}\")\nprint(f\"Prediction rate: {len(best_matches) / 500 * 100:.1f}%\")\nEOF\n</code></pre> <p>Expected homology predictions: - Phages with homology match: 100-250 (20-50%) - Confidence: Medium (some may be horizontal gene transfer, not true host)</p>"},{"location":"tutorials/host-prediction-workflows/#step-4-machine-learning-based-prediction","title":"Step 4: Machine Learning-Based Prediction","text":""},{"location":"tutorials/host-prediction-workflows/#41-wish-genome-composition-based","title":"4.1 WIsH (Genome Composition-Based)","text":"<p>WIsH predicts hosts based on k-mer composition similarity.</p> <pre><code># Create WIsH directory\nmkdir -p 03_wish\n\n# Run WIsH\nWIsH \\\n    -c 00_data/environmental_phages.fasta \\\n    -b 00_data/MAGs \\\n    -o 03_wish/wish_predictions.txt \\\n    -n 16\n\n# Parse WIsH results\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load WIsH predictions\n# WIsH output format: phage, host, log-likelihood, p-value\nwish = pd.read_csv('03_wish/wish_predictions.txt', sep='\\t',\n                   header=None, names=['Phage_ID', 'MAG_ID', 'LogLikelihood', 'Pvalue'])\n\n# Filter by p-value (&lt; 0.05)\nwish_filtered = wish[wish['Pvalue'] &lt; 0.05].copy()\n\n# Take best prediction per phage (highest log-likelihood)\nbest_wish = wish_filtered.loc[wish_filtered.groupby('Phage_ID')['LogLikelihood'].idxmax()]\n\nbest_wish['Method'] = 'WIsH'\nbest_wish['Confidence'] = 'Low-Medium'\nbest_wish.to_csv('03_wish/wish_host_predictions.tsv', sep='\\t', index=False)\n\nprint(f\"WIsH-based host predictions: {len(best_wish)}\")\nprint(f\"Prediction rate: {len(best_wish) / 500 * 100:.1f}%\")\nEOF\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#42-iphop-integrated-approach","title":"4.2 iPHoP (Integrated Approach)","text":"<p>iPHoP combines multiple methods including CRISPR, homology, and genomic signatures.</p> <pre><code># Create iPHoP directory\nmkdir -p 04_iphop\n\n# Run iPHoP (all-in-one tool)\niphop predict \\\n    --fa_file 00_data/environmental_phages.fasta \\\n    --db_dir ~/databases/iphop_db/ \\\n    --out_dir 04_iphop \\\n    --num_threads 16\n\n# iPHoP outputs comprehensive results\ncat 04_iphop/Host_prediction_to_genus_m90.csv\n</code></pre> <p>iPHoP output files: - <code>Host_prediction_to_genus_m90.csv</code>: Genus-level predictions (90% confidence) - <code>Host_prediction_to_genome_m90.csv</code>: Genome-level predictions - <code>Detailed_output_by_tool.csv</code>: Breakdown by method</p> <pre><code># Parse iPHoP predictions\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load iPHoP genus-level predictions\niphop = pd.read_csv('04_iphop/Host_prediction_to_genus_m90.csv')\n\n# Filter for confident predictions (confidence score &gt; 90)\niphop_confident = iphop[iphop['Host genus confidence score'] &gt; 90].copy()\n\niphop_confident['Method'] = 'iPHoP'\niphop_confident['Confidence'] = 'Medium-High'\n\n# Save\niphop_confident.to_csv('04_iphop/iphop_host_predictions.tsv', sep='\\t', index=False)\n\nprint(f\"iPHoP host predictions: {len(iphop_confident)}\")\nprint(f\"Prediction rate: {len(iphop_confident) / 500 * 100:.1f}%\")\nEOF\n</code></pre> <p>Expected iPHoP predictions: - Phages with prediction: 150-350 (30-70%) - Confidence: Variable (check confidence scores)</p>"},{"location":"tutorials/host-prediction-workflows/#step-5-co-occurrence-analysis","title":"Step 5: Co-occurrence Analysis","text":"<p>Phages and their hosts may co-occur in metagenomic samples.</p>"},{"location":"tutorials/host-prediction-workflows/#51-calculate-abundance-correlations","title":"5.1 Calculate Abundance Correlations","text":"<pre><code># This requires abundance data from multiple samples\n# Assuming you have abundance tables for phages and MAGs across samples\n\nmkdir -p 05_cooccurrence\n\n# Create mock abundance data for tutorial\n# In practice, you'd use CoverM or similar to get real abundances\n\n# Calculate Spearman correlations\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import spearmanr\n\n# Load abundance data (simulated for tutorial)\n# phage_abundance = pd.read_csv('phage_abundance_matrix.tsv', sep='\\t', index_col=0)\n# mag_abundance = pd.read_csv('mag_abundance_matrix.tsv', sep='\\t', index_col=0)\n\n# For tutorial, create mock data\nnp.random.seed(42)\nn_samples = 20\nn_phages = 500\nn_mags = 100\n\nphage_abundance = pd.DataFrame(\n    np.random.lognormal(0, 2, (n_phages, n_samples)),\n    index=[f\"phage_{i}\" for i in range(n_phages)],\n    columns=[f\"sample_{i}\" for i in range(n_samples)]\n)\n\nmag_abundance = pd.DataFrame(\n    np.random.lognormal(0, 2, (n_mags, n_samples)),\n    index=[f\"MAG_{i:03d}\" for i in range(n_mags)],\n    columns=[f\"sample_{i}\" for i in range(n_samples)]\n)\n\n# Calculate correlations\ncorrelations = []\n\nfor phage_id in phage_abundance.index:\n    phage_abund = phage_abundance.loc[phage_id].values\n\n    for mag_id in mag_abundance.index:\n        mag_abund = mag_abundance.loc[mag_id].values\n\n        # Spearman correlation\n        rho, pval = spearmanr(phage_abund, mag_abund)\n\n        correlations.append({\n            'Phage_ID': phage_id,\n            'MAG_ID': mag_id,\n            'Spearman_Rho': rho,\n            'P_value': pval\n        })\n\n# Convert to DataFrame\ncorr_df = pd.DataFrame(correlations)\n\n# Filter for significant positive correlations\ncorr_sig = corr_df[(corr_df['P_value'] &lt; 0.01) &amp; (corr_df['Spearman_Rho'] &gt; 0.6)].copy()\n\n# Take best match per phage\nbest_corr = corr_sig.loc[corr_sig.groupby('Phage_ID')['Spearman_Rho'].idxmax()]\n\nbest_corr['Method'] = 'Co-occurrence'\nbest_corr['Confidence'] = 'Low'\nbest_corr.to_csv('05_cooccurrence/cooccurrence_host_predictions.tsv', sep='\\t', index=False)\n\nprint(f\"Co-occurrence-based predictions: {len(best_corr)}\")\nprint(f\"Prediction rate: {len(best_corr) / n_phages * 100:.1f}%\")\nEOF\n</code></pre> <p>Expected co-occurrence predictions: - Phages with correlation: 50-150 (10-30%) - Confidence: Low (correlation \u2260 causation, many false positives)</p>"},{"location":"tutorials/host-prediction-workflows/#step-6-consensus-prediction","title":"Step 6: Consensus Prediction","text":"<p>Combine predictions from multiple methods for higher confidence.</p>"},{"location":"tutorials/host-prediction-workflows/#61-merge-all-predictions","title":"6.1 Merge All Predictions","text":"<pre><code># Create consensus directory\nmkdir -p 06_consensus\n\n# Combine all prediction tables\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load all prediction tables\ncrispr = pd.read_csv('01_crispr/crispr_host_predictions.tsv', sep='\\t')\nhomology = pd.read_csv('02_homology/homology_host_predictions.tsv', sep='\\t')\nwish = pd.read_csv('03_wish/wish_host_predictions.tsv', sep='\\t')\niphop = pd.read_csv('04_iphop/iphop_host_predictions.tsv', sep='\\t')\n# cooccur = pd.read_csv('05_cooccurrence/cooccurrence_host_predictions.tsv', sep='\\t')\n\n# Standardize columns\ndef standardize(df, method_name):\n    return df[['Phage_ID', 'MAG_ID', 'Method', 'Confidence']].copy()\n\ncrispr_std = standardize(crispr, 'CRISPR')\nhomology_std = standardize(homology, 'Homology')\nwish_std = standardize(wish, 'WIsH')\n\n# Note: iPHoP output format is different, needs custom parsing\n# For tutorial, we'll just use the first three\n\n# Combine\nall_predictions = pd.concat([crispr_std, homology_std, wish_std], ignore_index=True)\n\n# Save all predictions\nall_predictions.to_csv('06_consensus/all_host_predictions.tsv', sep='\\t', index=False)\n\n# Count predictions per phage\npred_counts = all_predictions.groupby('Phage_ID').size().reset_index(name='Num_Methods')\n\nprint(f\"Total predictions: {len(all_predictions)}\")\nprint(f\"Phages with \u22651 prediction: {all_predictions['Phage_ID'].nunique()}\")\nprint(f\"Phages with \u22652 methods agreeing: {len(pred_counts[pred_counts['Num_Methods'] &gt;= 2])}\")\n\n# Find consensus predictions (\u22652 methods predicting same host)\nconsensus_predictions = []\n\nfor phage in all_predictions['Phage_ID'].unique():\n    phage_preds = all_predictions[all_predictions['Phage_ID'] == phage]\n\n    # Count predictions for each MAG\n    mag_counts = phage_preds['MAG_ID'].value_counts()\n\n    if mag_counts.max() &gt;= 2:  # At least 2 methods agree\n        predicted_mag = mag_counts.idxmax()\n        num_methods = mag_counts.max()\n\n        # Get list of methods\n        methods = phage_preds[phage_preds['MAG_ID'] == predicted_mag]['Method'].tolist()\n\n        consensus_predictions.append({\n            'Phage_ID': phage,\n            'Predicted_Host': predicted_mag,\n            'Num_Methods_Agreeing': num_methods,\n            'Methods': ','.join(methods),\n            'Confidence': 'High' if 'CRISPR' in methods else 'Medium'\n        })\n\nconsensus_df = pd.DataFrame(consensus_predictions)\nconsensus_df.to_csv('06_consensus/consensus_host_predictions.tsv', sep='\\t', index=False)\n\nprint(f\"\\n=== Consensus Predictions ===\")\nprint(f\"Phages with consensus prediction (\u22652 methods): {len(consensus_df)}\")\nprint(f\"Prediction rate: {len(consensus_df) / 500 * 100:.1f}%\")\nprint(f\"High confidence (includes CRISPR): {len(consensus_df[consensus_df['Confidence'] == 'High'])}\")\nEOF\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#step-7-validation-and-confidence-assessment","title":"Step 7: Validation and Confidence Assessment","text":""},{"location":"tutorials/host-prediction-workflows/#71-assess-prediction-quality","title":"7.1 Assess Prediction Quality","text":"<pre><code># Create validation directory\nmkdir -p 07_validation\n\n# Analyze prediction confidence\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load consensus predictions\nconsensus = pd.read_csv('06_consensus/consensus_host_predictions.tsv', sep='\\t')\nall_preds = pd.read_csv('06_consensus/all_host_predictions.tsv', sep='\\t')\n\n# Summary statistics\nprint(\"=== Host Prediction Summary ===\\n\")\n\nprint(f\"Total phages: 500\")\nprint(f\"Phages with any prediction: {all_preds['Phage_ID'].nunique()} ({all_preds['Phage_ID'].nunique()/500*100:.1f}%)\")\nprint(f\"Phages with consensus prediction (\u22652 methods): {len(consensus)} ({len(consensus)/500*100:.1f}%)\")\nprint(f\"Phages with high confidence prediction: {len(consensus[consensus['Confidence']=='High'])} ({len(consensus[consensus['Confidence']=='High'])/500*100:.1f}%)\")\n\nprint(\"\\nPredictions by method:\")\nprint(all_preds['Method'].value_counts())\n\nprint(\"\\nConsensus predictions by number of agreeing methods:\")\nprint(consensus['Num_Methods_Agreeing'].value_counts())\n\n# Plot prediction rates\nmethods = all_preds.groupby('Method')['Phage_ID'].nunique()\n\nplt.figure(figsize=(10, 6))\nmethods.plot(kind='bar', color='steelblue')\nplt.ylabel('Number of Phages with Prediction')\nplt.xlabel('Method')\nplt.title('Host Prediction Rate by Method')\nplt.xticks(rotation=45, ha='right')\nplt.tight_layout()\nplt.savefig('07_validation/prediction_rates_by_method.pdf')\n\n# Confidence distribution\nplt.figure(figsize=(8, 6))\nall_preds['Confidence'].value_counts().plot(kind='bar', color='coral')\nplt.ylabel('Number of Predictions')\nplt.xlabel('Confidence Level')\nplt.title('Prediction Confidence Distribution')\nplt.xticks(rotation=45, ha='right')\nplt.tight_layout()\nplt.savefig('07_validation/confidence_distribution.pdf')\n\nprint(\"\\nPlots saved to 07_validation/\")\nEOF\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#72-create-final-recommendation-table","title":"7.2 Create Final Recommendation Table","text":"<pre><code># Generate final host predictions with recommendations\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load all predictions\nall_preds = pd.read_csv('06_consensus/all_host_predictions.tsv', sep='\\t')\nconsensus = pd.read_csv('06_consensus/consensus_host_predictions.tsv', sep='\\t')\n\n# Create final recommendation table\nrecommendations = []\n\nfor phage in set(all_preds['Phage_ID'].unique()):\n    phage_preds = all_preds[all_preds['Phage_ID'] == phage]\n\n    # Check if in consensus\n    if phage in consensus['Phage_ID'].values:\n        cons_row = consensus[consensus['Phage_ID'] == phage].iloc[0]\n\n        recommendations.append({\n            'Phage_ID': phage,\n            'Recommended_Host': cons_row['Predicted_Host'],\n            'Confidence': cons_row['Confidence'],\n            'Num_Methods': cons_row['Num_Methods_Agreeing'],\n            'Methods': cons_row['Methods'],\n            'Recommendation': 'Use this prediction' if cons_row['Confidence'] == 'High' else 'Validate experimentally'\n        })\n    else:\n        # Single method prediction - lower confidence\n        # Take CRISPR if available, otherwise best available\n        if 'CRISPR' in phage_preds['Method'].values:\n            pred_row = phage_preds[phage_preds['Method'] == 'CRISPR'].iloc[0]\n            conf = 'High'\n            rec = 'Use this prediction (CRISPR match)'\n        else:\n            # Take highest confidence method\n            pred_row = phage_preds.iloc[0]\n            conf = 'Low'\n            rec = 'Low confidence - validate experimentally or use with caution'\n\n        recommendations.append({\n            'Phage_ID': phage,\n            'Recommended_Host': pred_row['MAG_ID'],\n            'Confidence': conf,\n            'Num_Methods': 1,\n            'Methods': pred_row['Method'],\n            'Recommendation': rec\n        })\n\nrec_df = pd.DataFrame(recommendations)\nrec_df.to_csv('07_validation/final_host_recommendations.tsv', sep='\\t', index=False)\n\nprint(f\"Final recommendations created for {len(rec_df)} phages\")\nprint(\"\\nRecommendation breakdown:\")\nprint(rec_df['Recommendation'].value_counts())\nEOF\n</code></pre>"},{"location":"tutorials/host-prediction-workflows/#step-8-summary-and-interpretation","title":"Step 8: Summary and Interpretation","text":""},{"location":"tutorials/host-prediction-workflows/#expected-results","title":"Expected Results","text":"<p>Typical prediction rates: - CRISPR matches: 2-10% of phages (highest confidence) - Homology matches: 20-50% of phages (medium confidence) - Machine learning: 30-70% of phages (variable confidence) - Consensus (\u22652 methods): 10-30% of phages (recommended for use)</p>"},{"location":"tutorials/host-prediction-workflows/#interpreting-confidence-levels","title":"Interpreting Confidence Levels","text":"Confidence Criteria Accuracy (Expected) Recommendation High CRISPR match OR 3+ methods agree ~80-95% Use with confidence Medium-High 2+ methods agree (incl. homology) ~50-70% Reasonable for most analyses, validate key findings Medium iPHoP &gt;90 score OR homology + ML ~30-50% Use with caution, validate if important Low Single method (non-CRISPR) ~20-40% Hypothesis only, requires validation"},{"location":"tutorials/host-prediction-workflows/#validation-strategies","title":"Validation Strategies","text":"<p>Experimental validation: 1. Culture-based: Infect predicted host with phage isolate 2. qPCR: Check phage and host co-occurrence in samples 3. Hi-C: Proximity ligation shows phage-host interactions 4. BONCAT: Label newly synthesized proteins during infection</p> <p>Computational validation: 1. Prophage analysis: Check if phage integrates in predicted host lineage 2. Coverage correlation: Phage and host should co-vary across samples 3. Literature: Known phages from same family infecting predicted host genus</p>"},{"location":"tutorials/host-prediction-workflows/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/host-prediction-workflows/#problem-very-few-crispr-matches","title":"Problem: Very Few CRISPR Matches","text":"<p>Causes: - Few MAGs have CRISPR systems - Phages are novel and not yet encountered by hosts - CRISPR spacers are too old and diverged</p> <p>Solutions: - Include more MAGs from same environment - Use public CRISPR spacer databases (IMG/VR, PADLOC) - Relax CRISPR matching criteria slightly (allow 2 mismatches)</p>"},{"location":"tutorials/host-prediction-workflows/#problem-conflicting-predictions","title":"Problem: Conflicting Predictions","text":"<p>When methods disagree: - Prioritize CRISPR &gt; Homology &gt; Machine Learning - Check taxonomic consistency (predicted hosts should be related) - Look at prediction confidence scores - Use consensus only (\u22652 methods agree)</p>"},{"location":"tutorials/host-prediction-workflows/#problem-no-predictions-for-most-phages","title":"Problem: No Predictions for Most Phages","text":"<p>This is normal! Expected for: - Highly novel phages - Undersampled environments - Limited MAG database</p> <p>Solutions: - Expand MAG collection - Use broader host databases (IMG/VR, GTDB) - Accept that many phages will have unknown hosts</p>"},{"location":"tutorials/host-prediction-workflows/#next-steps","title":"Next Steps","text":"<p>Improve predictions: - Add more MAGs from your environment - Include metatranscriptome data (active infections) - Perform targeted validation experiments</p> <p>Downstream analyses: - Host range analysis (broad vs narrow) - Network analysis (phage-host interaction networks) - Link phage auxiliary metabolic genes to host metabolism</p>"},{"location":"tutorials/host-prediction-workflows/#further-reading","title":"Further Reading","text":"<ul> <li>Galiez, C., et al. (2017). \"WIsH: who is the host?\" Bioinformatics, 33(19), 3113-3114.</li> <li>Roux, S., et al. (2023). \"iPHoP: An integrated machine learning framework to maximize host prediction for metagenome-derived viruses.\" PLoS Biology, 21(4), e3002083.</li> <li>Dion, M. B., et al. (2021). \"Streamlining CRISPR spacer-based bacterial host predictions.\" PeerJ, 9, e11059.</li> </ul>"},{"location":"tutorials/prophage-identification/","title":"Tutorial 3: Prophage Identification in Bacterial Genomes","text":"<p>Last Updated: November 29, 2025 Level: Intermediate | Time: 3-4 hours | Data Size: 20MB</p>"},{"location":"tutorials/prophage-identification/#overview","title":"Overview","text":"<p>Prophages are viral genomes integrated into bacterial chromosomes. They constitute a significant portion of bacterial genetic diversity and play important roles in bacterial evolution, pathogenicity, and horizontal gene transfer. This tutorial covers the complete workflow for identifying and characterizing prophages in bacterial genomes.</p> <p>What you'll learn: - Identify prophages using multiple prediction tools - Validate prophage predictions and assess quality - Distinguish active from cryptic (degraded) prophages - Extract and annotate complete prophage sequences - Compare prophages across multiple bacterial strains - Analyze prophage induction and excision potential</p> <p>Sample dataset: 10 Escherichia coli isolate genomes (complete assemblies, 4.5-5.5 Mb each)</p>"},{"location":"tutorials/prophage-identification/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/prophage-identification/#required-software","title":"Required Software","text":"<pre><code># Create environment for prophage analysis\nconda create -n prophage_tutorial python=3.9\nconda activate prophage_tutorial\n\n# Install prophage prediction tools\nconda install -c bioconda -c conda-forge \\\n    phispy=4.2.21 \\\n    blast=2.14.0 \\\n    prodigal=2.6.3 \\\n    hmmer=3.3.2 \\\n    checkv=1.0.1 \\\n    seqkit=2.5.1 \\\n    bedtools=2.30.0 \\\n    prokka=1.14.6 \\\n    roary=3.13.0\n\n# Install PHASTER (web-based, optional local install)\n# We'll use PhiSpy as primary tool\n\n# Install Phigaro\npip install phigaro\nphigaro-setup --no-updatedb  # Downloads databases\n\n# Install VIBRANT (also detects prophages)\ngit clone https://github.com/AnantharamanLab/VIBRANT.git ~/tools/VIBRANT\ncd ~/tools/VIBRANT\npython3 setup.py install\ndownload-db.sh\n</code></pre>"},{"location":"tutorials/prophage-identification/#system-requirements","title":"System Requirements","text":"<ul> <li>RAM: 16GB minimum</li> <li>Disk Space: 30GB free (for databases)</li> <li>CPU: 4+ cores recommended</li> <li>OS: Linux or macOS</li> </ul>"},{"location":"tutorials/prophage-identification/#background-knowledge","title":"Background Knowledge","text":"<p>Recommended to complete Tutorial 1 first and review: - Lysogenic vs lytic viral lifecycles (Fundamentals) - Bacterial genome structure - Gene prediction and annotation</p>"},{"location":"tutorials/prophage-identification/#step-1-download-and-prepare-data","title":"Step 1: Download and Prepare Data","text":""},{"location":"tutorials/prophage-identification/#download-bacterial-genomes","title":"Download Bacterial Genomes","text":"<pre><code># Create project directory\nmkdir -p ~/prophage_tutorial\ncd ~/prophage_tutorial\n\n# Download E. coli reference genomes from NCBI\n# For tutorial, we'll use 10 complete E. coli genomes\nmkdir -p 00_genomes\n\n# Example genomes (replace with actual NCBI accessions)\n# These would normally be downloaded via NCBI's datasets CLI or FTP\n\n# For this tutorial, simulate with representative genomes:\n# E. coli K-12 MG1655 (NC_000913.3)\n# E. coli O157:H7 (NC_002695.2)\n# ... 8 more strains\n\n# Download using NCBI datasets (if installed)\ndatasets download genome accession NC_000913.3,NC_002695.2 \\\n    --filename 00_genomes/ecoli_genomes.zip\n\nunzip 00_genomes/ecoli_genomes.zip -d 00_genomes/\n\n# Or use direct FTP download\n# wget ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz\n\n# For tutorial purposes, organize genomes\nls 00_genomes/*.fna &gt; 00_genomes/genome_list.txt\n</code></pre>"},{"location":"tutorials/prophage-identification/#inspect-genomes","title":"Inspect Genomes","text":"<pre><code># Get statistics for all genomes\nfor genome in 00_genomes/*.fna; do\n    echo \"=== $(basename $genome) ===\"\n    seqkit stats $genome\ndone\n\n# Expected output for each:\n# ~4.5-5.5 Mb total length\n# 1-2 chromosomes + plasmids (if present)\n# Circular chromosomes\n</code></pre>"},{"location":"tutorials/prophage-identification/#step-2-predict-genes","title":"Step 2: Predict Genes","text":"<p>Prophage prediction tools need gene annotations.</p>"},{"location":"tutorials/prophage-identification/#run-prodigal-for-gene-prediction","title":"Run Prodigal for Gene Prediction","text":"<pre><code># Create gene prediction directory\nmkdir -p 01_genes\n\n# Predict genes for each genome\nfor genome in 00_genomes/*.fna; do\n    basename=$(basename $genome .fna)\n    echo \"Predicting genes for $basename...\"\n\n    prodigal \\\n        -i $genome \\\n        -a 01_genes/${basename}_proteins.faa \\\n        -d 01_genes/${basename}_genes.fna \\\n        -f gff \\\n        -o 01_genes/${basename}.gff \\\n        -p single  # single genome mode (not meta)\n\ndone\n\necho \"Gene prediction complete for all genomes\"\n\n# Check gene counts\nfor faa in 01_genes/*_proteins.faa; do\n    gene_count=$(grep -c \"&gt;\" $faa)\n    echo \"$(basename $faa): $gene_count genes\"\ndone\n</code></pre> <p>Expected results: - Genes per genome: 4,000-5,500 genes - Average gene length: ~900-1,000 bp</p>"},{"location":"tutorials/prophage-identification/#step-3-prophage-prediction-with-multiple-tools","title":"Step 3: Prophage Prediction with Multiple Tools","text":"<p>We'll use three tools to identify prophages: PhiSpy, Phigaro, and VIBRANT.</p>"},{"location":"tutorials/prophage-identification/#31-phispy","title":"3.1 PhiSpy","text":"<p>PhiSpy identifies prophages based on comparison with known phage genes and AT content.</p> <pre><code># Create prophage prediction directory\nmkdir -p 02_prophages/phispy\n\n# Run PhiSpy on each genome\nfor genome in 00_genomes/*.fna; do\n    basename=$(basename $genome .fna)\n    echo \"Running PhiSpy on $basename...\"\n\n    PhiSpy.py \\\n        $genome \\\n        -o 02_prophages/phispy/${basename} \\\n        --output_choice 4 \\\n        --phage_genes 1 \\\n        --threads 4\n\n    # PhiSpy outputs:\n    # prophage_coordinates.tsv - prophage locations\n    # prophage.fasta - prophage sequences\ndone\n\n# Summarize PhiSpy results\necho \"PhiSpy Results Summary:\"\nfor dir in 02_prophages/phispy/*/; do\n    basename=$(basename $dir)\n    if [ -f \"$dir/prophage_coordinates.tsv\" ]; then\n        count=$(tail -n +2 \"$dir/prophage_coordinates.tsv\" | wc -l)\n        echo \"$basename: $count prophages\"\n    else\n        echo \"$basename: 0 prophages\"\n    fi\ndone\n</code></pre> <p>Expected PhiSpy results: - Prophages per genome: 0-8 (typically 2-5) - Prophage sizes: 15-60 kb - Confidence: Varies (check score column)</p>"},{"location":"tutorials/prophage-identification/#32-phigaro","title":"3.2 Phigaro","text":"<p>Phigaro uses profile HMMs to identify prophage regions.</p> <pre><code># Create Phigaro output directory\nmkdir -p 02_prophages/phigaro\n\n# Run Phigaro on each genome\nfor genome in 00_genomes/*.fna; do\n    basename=$(basename $genome .fna)\n    echo \"Running Phigaro on $basename...\"\n\n    phigaro \\\n        -f $genome \\\n        -o 02_prophages/phigaro/${basename}.tsv \\\n        -t 4 \\\n        -e tsv\ndone\n\n# Summarize Phigaro results\necho \"Phigaro Results Summary:\"\nfor tsv in 02_prophages/phigaro/*.tsv; do\n    basename=$(basename $tsv .tsv)\n    count=$(tail -n +2 \"$tsv\" | wc -l)\n    echo \"$basename: $count prophages\"\ndone\n</code></pre> <p>Expected Phigaro results: - Prophages per genome: 1-10 (often finds more than PhiSpy) - Includes: Incomplete prophages and prophage remnants</p>"},{"location":"tutorials/prophage-identification/#33-vibrant-prophage-mode","title":"3.3 VIBRANT (Prophage Mode)","text":"<pre><code># Create VIBRANT output directory\nmkdir -p 02_prophages/vibrant\n\n# Run VIBRANT on each genome\nfor genome in 00_genomes/*.fna; do\n    basename=$(basename $genome .fna)\n    echo \"Running VIBRANT on $basename...\"\n\n    VIBRANT_run.py \\\n        -i $genome \\\n        -folder 02_prophages/vibrant/${basename} \\\n        -t 4\ndone\n\n# VIBRANT separates prophages and lytic phages\n# Prophages are in: VIBRANT_prophages_*/\n\n# Summarize VIBRANT results\necho \"VIBRANT Results Summary:\"\nfor dir in 02_prophages/vibrant/*/VIBRANT_prophages_*/; do\n    if [ -d \"$dir\" ]; then\n        basename=$(basename $(dirname $dir))\n        count=$(ls $dir/*.faa 2&gt;/dev/null | wc -l)\n        echo \"$basename: $count prophages\"\n    fi\ndone\n</code></pre>"},{"location":"tutorials/prophage-identification/#step-4-combine-and-validate-predictions","title":"Step 4: Combine and Validate Predictions","text":"<p>Different tools have different sensitivity and specificity. Let's compare results.</p>"},{"location":"tutorials/prophage-identification/#41-extract-prophage-coordinates","title":"4.1 Extract Prophage Coordinates","text":"<pre><code># Create comparison directory\nmkdir -p 03_comparison\n\n# Convert all predictions to BED format for comparison\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport os\n\nresults = {}\n\n# Parse PhiSpy results\nfor root, dirs, files in os.walk('02_prophages/phispy'):\n    for file in files:\n        if file == 'prophage_coordinates.tsv':\n            genome = os.path.basename(root)\n            filepath = os.path.join(root, file)\n\n            df = pd.read_csv(filepath, sep='\\t')\n            # PhiSpy format: pp, Contig, Start, Stop, ...\n            if len(df) &gt; 0:\n                bed_data = []\n                for idx, row in df.iterrows():\n                    bed_data.append({\n                        'chr': row['Contig'],\n                        'start': row['Start'],\n                        'end': row['Stop'],\n                        'name': f\"phispy_prophage_{idx+1}\",\n                        'score': 0,\n                        'strand': '+'\n                    })\n\n                bed_df = pd.DataFrame(bed_data)\n                bed_df.to_csv(f'03_comparison/{genome}_phispy.bed',\n                              sep='\\t', header=False, index=False)\n\n# Parse Phigaro results\nfor file in os.listdir('02_prophages/phigaro'):\n    if file.endswith('.tsv'):\n        genome = file.replace('.tsv', '')\n        filepath = os.path.join('02_prophages/phigaro', file)\n\n        df = pd.read_csv(filepath, sep='\\t')\n        if len(df) &gt; 0 and 'begin' in df.columns:\n            bed_data = []\n            for idx, row in df.iterrows():\n                bed_data.append({\n                    'chr': row['scaffold'],\n                    'start': row['begin'],\n                    'end': row['end'],\n                    'name': f\"phigaro_prophage_{idx+1}\",\n                    'score': 0,\n                    'strand': '+'\n                })\n\n            bed_df = pd.DataFrame(bed_data)\n            bed_df.to_csv(f'03_comparison/{genome}_phigaro.bed',\n                          sep='\\t', header=False, index=False)\n\nprint(\"Converted all predictions to BED format\")\nEOF\n\n# Find overlapping predictions (consensus)\nls 00_genomes/*.fna | while read genome; do\n    basename=$(basename $genome .fna)\n\n    if [ -f \"03_comparison/${basename}_phispy.bed\" ] &amp;&amp; [ -f \"03_comparison/${basename}_phigaro.bed\" ]; then\n        echo \"Finding consensus prophages for $basename...\"\n\n        # Use bedtools to find overlaps\n        bedtools intersect \\\n            -a 03_comparison/${basename}_phispy.bed \\\n            -b 03_comparison/${basename}_phigaro.bed \\\n            -wa -wb \\\n            &gt; 03_comparison/${basename}_consensus.bed\n    fi\ndone\n</code></pre>"},{"location":"tutorials/prophage-identification/#42-assess-quality-with-checkv","title":"4.2 Assess Quality with CheckV","text":"<p>CheckV can assess prophage completeness and contamination.</p> <pre><code># Create CheckV directory\nmkdir -p 04_checkv\n\n# Extract all predicted prophage sequences\n# Combine from all tools\nmkdir -p 04_checkv/sequences\n\n# Extract PhiSpy prophages\nfor dir in 02_prophages/phispy/*/; do\n    basename=$(basename $dir)\n    if [ -f \"$dir/prophage.fasta\" ]; then\n        # Add genome name to sequence headers\n        sed \"s/&gt;/&gt;$basename\\_/\" \"$dir/prophage.fasta\" \\\n            &gt;&gt; 04_checkv/sequences/all_prophages.fasta\n    fi\ndone\n\n# Run CheckV\ncheckv end_to_end \\\n    04_checkv/sequences/all_prophages.fasta \\\n    04_checkv \\\n    -t 8 \\\n    -d /path/to/checkv-db-v1.5  # Update path\n\n# Analyze CheckV results\ncat 04_checkv/quality_summary.tsv\n</code></pre>"},{"location":"tutorials/prophage-identification/#interpret-checkv-quality","title":"Interpret CheckV Quality","text":"<pre><code># Filter for high-quality prophages\nawk -F'\\t' '($8 == \"Complete\" || $8 == \"High-quality\") &amp;&amp; $10 &lt; 5 {print $1}' \\\n    04_checkv/quality_summary.tsv \\\n    &gt; 04_checkv/hq_prophage_ids.txt\n\necho \"High-quality prophages: $(wc -l &lt; 04_checkv/hq_prophage_ids.txt)\"\n\n# Extract high-quality prophages\nseqkit grep -f 04_checkv/hq_prophage_ids.txt \\\n    04_checkv/sequences/all_prophages.fasta \\\n    &gt; 04_checkv/hq_prophages.fasta\n</code></pre> <p>Expected quality distribution: - Complete: 10-30% of predictions - High-quality: 30-50% - Medium-quality: 20-30% - Low-quality/cryptic: 10-30%</p> <p>Cryptic Prophages</p> <p>Low-quality, short prophages (&lt;20kb, &lt;30% completeness) are often \"cryptic\" or degraded prophages that have lost functionality over evolutionary time.</p>"},{"location":"tutorials/prophage-identification/#step-5-distinguish-active-from-cryptic-prophages","title":"Step 5: Distinguish Active from Cryptic Prophages","text":"<p>Active prophages can excise and produce virions; cryptic prophages cannot.</p>"},{"location":"tutorials/prophage-identification/#criteria-for-active-prophages","title":"Criteria for Active Prophages","text":"<pre><code># Create active vs cryptic analysis directory\nmkdir -p 05_active_cryptic\n\n# Analyze prophage features\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nfrom Bio import SeqIO\n\n# Load CheckV quality\ncheckv = pd.read_csv('04_checkv/quality_summary.tsv', sep='\\t')\n\n# Define criteria for active prophages:\n# 1. Completeness &gt;50%\n# 2. Low contamination (&lt;5%)\n# 3. Contains essential phage genes (checked by CheckV)\n# 4. Not labeled as \"provirus\" in CheckV (which indicates integrated)\n\n# Classify prophages\nactive = []\ncryptic = []\n\nfor idx, row in checkv.iterrows():\n    prophage_id = row['contig_id']\n    completeness = row['completeness']\n    contamination = row['contamination']\n    quality = row['checkv_quality']\n\n    # Active criteria\n    is_active = (\n        completeness &gt; 50 and\n        contamination &lt; 5 and\n        quality in ['Complete', 'High-quality']\n    )\n\n    if is_active:\n        active.append({\n            'prophage_id': prophage_id,\n            'completeness': completeness,\n            'quality': quality,\n            'status': 'Active/Functional'\n        })\n    else:\n        cryptic.append({\n            'prophage_id': prophage_id,\n            'completeness': completeness,\n            'quality': quality,\n            'status': 'Cryptic/Degraded'\n        })\n\n# Save classifications\nactive_df = pd.DataFrame(active)\ncryptic_df = pd.DataFrame(cryptic)\n\nactive_df.to_csv('05_active_cryptic/active_prophages.tsv', sep='\\t', index=False)\ncryptic_df.to_csv('05_active_cryptic/cryptic_prophages.tsv', sep='\\t', index=False)\n\nprint(f\"Active/Functional prophages: {len(active)}\")\nprint(f\"Cryptic/Degraded prophages: {len(cryptic)}\")\n\n# Extract active prophage IDs\nactive_df['prophage_id'].to_csv('05_active_cryptic/active_ids.txt',\n                                 header=False, index=False)\nEOF\n\n# Extract active prophage sequences\nseqkit grep -f 05_active_cryptic/active_ids.txt \\\n    04_checkv/sequences/all_prophages.fasta \\\n    &gt; 05_active_cryptic/active_prophages.fasta\n</code></pre>"},{"location":"tutorials/prophage-identification/#check-for-att-sites-attachment-sites","title":"Check for att Sites (Attachment Sites)","text":"<p>Active prophages typically have att sites flanking the prophage region.</p> <pre><code># Look for direct repeats at prophage boundaries\n# This requires the original genome coordinates\n\n# Simplified approach: Check PhiSpy att site predictions\n# PhiSpy identifies att sites automatically\n\npython3 &lt;&lt; 'EOF'\nimport os\n\natt_sites = {}\n\nfor root, dirs, files in os.walk('02_prophages/phispy'):\n    for file in files:\n        if file == 'prophage_coordinates.tsv':\n            genome = os.path.basename(root)\n            filepath = os.path.join(root, file)\n\n            with open(filepath) as f:\n                header = f.readline()\n                for line in f:\n                    fields = line.strip().split('\\t')\n                    # PhiSpy includes att site information\n                    # Check if att sites were identified\n\nprint(\"att site analysis would go here\")\n# In practice, you'd extract and analyze flanking sequences\nEOF\n</code></pre>"},{"location":"tutorials/prophage-identification/#step-6-annotate-prophages","title":"Step 6: Annotate Prophages","text":"<p>Annotate high-quality active prophages to understand their gene content.</p>"},{"location":"tutorials/prophage-identification/#run-prokka-for-annotation","title":"Run Prokka for Annotation","text":"<pre><code># Create annotation directory\nmkdir -p 06_annotation\n\n# Annotate active prophages\nfor genome in 00_genomes/*.fna; do\n    basename=$(basename $genome .fna)\n\n    # Get prophages for this genome from PhiSpy\n    prophage_file=\"02_prophages/phispy/${basename}/prophage.fasta\"\n\n    if [ -f \"$prophage_file\" ]; then\n        prokka \\\n            --outdir 06_annotation/${basename} \\\n            --prefix ${basename}_prophages \\\n            --kingdom Viruses \\\n            --cpus 4 \\\n            --force \\\n            $prophage_file\n    fi\ndone\n\n# Alternatively, use pharokka (phage-specific annotator)\n# pharokka -i prophage.fasta -o output_dir -t 4\n</code></pre> <p>Prokka outputs: - <code>.gff</code>: Gene annotations - <code>.faa</code>: Protein sequences - <code>.ffn</code>: Gene nucleotide sequences - <code>.gbk</code>: GenBank format - <code>.txt</code>: Annotation statistics</p>"},{"location":"tutorials/prophage-identification/#analyze-gene-content","title":"Analyze Gene Content","text":"<pre><code># Summarize annotations\nfor dir in 06_annotation/*/; do\n    basename=$(basename $dir)\n    echo \"=== $basename ===\"\n\n    if [ -f \"$dir/${basename}_prophages.txt\" ]; then\n        cat \"$dir/${basename}_prophages.txt\"\n    fi\n    echo \"\"\ndone\n\n# Extract specific phage genes\necho \"Prophages with integrase genes:\"\ngrep -r \"integrase\" 06_annotation/*/*.tsv\n\necho \"Prophages with terminase genes:\"\ngrep -r \"terminase\" 06_annotation/*/*.tsv\n</code></pre> <p>Key phage genes to look for: - Integrase: Indicates temperate lifestyle - Terminase: Packaging machinery - Portal protein: Head assembly - Tail proteins: Structural components - Lysis genes: Cell lysis machinery - Repressor: Lysogeny regulation</p>"},{"location":"tutorials/prophage-identification/#step-7-comparative-prophage-analysis","title":"Step 7: Comparative Prophage Analysis","text":"<p>Compare prophages across multiple bacterial strains.</p>"},{"location":"tutorials/prophage-identification/#71-cluster-prophages-by-similarity","title":"7.1 Cluster Prophages by Similarity","text":"<pre><code># Create comparison directory\nmkdir -p 07_comparative\n\n# Combine all prophage proteins\ncat 06_annotation/*/prophages.faa &gt; 07_comparative/all_prophage_proteins.faa\n\n# Cluster proteins with CD-HIT\ncd-hit \\\n    -i 07_comparative/all_prophage_proteins.faa \\\n    -o 07_comparative/protein_clusters.faa \\\n    -c 0.7 \\\n    -n 5 \\\n    -T 8 \\\n    -M 16000\n\n# Analyze clusters\ngrep \"&gt;\" 07_comparative/protein_clusters.faa | wc -l\necho \"protein clusters identified\"\n</code></pre>"},{"location":"tutorials/prophage-identification/#72-build-presenceabsence-matrix","title":"7.2 Build Presence/Absence Matrix","text":"<pre><code># Create prophage presence/absence matrix\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport os\nfrom Bio import SeqIO\n\n# Load all prophage sequences and group by genome\nprophages_by_genome = {}\n\nfor root, dirs, files in os.walk('02_prophages/phispy'):\n    for file in files:\n        if file == 'prophage.fasta':\n            genome = os.path.basename(root)\n            filepath = os.path.join(root, file)\n\n            count = 0\n            for record in SeqIO.parse(filepath, 'fasta'):\n                count += 1\n\n            prophages_by_genome[genome] = count\n\n# Create DataFrame\ngenomes = sorted(prophages_by_genome.keys())\ndf = pd.DataFrame({\n    'Genome': genomes,\n    'Prophage_Count': [prophages_by_genome[g] for g in genomes]\n})\n\ndf.to_csv('07_comparative/prophage_counts.tsv', sep='\\t', index=False)\n\nprint(\"Prophage counts per genome:\")\nprint(df)\n\n# Calculate statistics\nprint(f\"\\nMean prophages per genome: {df['Prophage_Count'].mean():.1f}\")\nprint(f\"Range: {df['Prophage_Count'].min()} - {df['Prophage_Count'].max()}\")\nEOF\n</code></pre>"},{"location":"tutorials/prophage-identification/#73-prophage-sharing-analysis","title":"7.3 Prophage Sharing Analysis","text":"<pre><code># Compare prophages between genomes using BLAST\nmkdir -p 07_comparative/blast\n\n# Create BLAST database from all prophages\ncat 02_prophages/phispy/*/prophage.fasta &gt; 07_comparative/all_prophages_combined.fasta\n\nmakeblastdb \\\n    -in 07_comparative/all_prophages_combined.fasta \\\n    -dbtype nucl \\\n    -out 07_comparative/blast/prophage_db\n\n# All vs all BLAST\nblastn \\\n    -query 07_comparative/all_prophages_combined.fasta \\\n    -db 07_comparative/blast/prophage_db \\\n    -out 07_comparative/blast/prophage_blast.txt \\\n    -outfmt '6 qseqid sseqid pident length qlen slen qcovs' \\\n    -num_threads 8\n\n# Find shared prophages (&gt;95% identity, &gt;90% coverage)\nawk '$3 &gt; 95 &amp;&amp; $7 &gt; 90 &amp;&amp; $1 != $2' 07_comparative/blast/prophage_blast.txt \\\n    &gt; 07_comparative/blast/shared_prophages.txt\n\nwc -l 07_comparative/blast/shared_prophages.txt\n</code></pre>"},{"location":"tutorials/prophage-identification/#step-8-summary-and-visualization","title":"Step 8: Summary and Visualization","text":""},{"location":"tutorials/prophage-identification/#create-summary-table","title":"Create Summary Table","text":"<pre><code># Create summary directory\nmkdir -p 08_summary\n\n# Comprehensive summary\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\nimport os\n\n# Load CheckV results\ncheckv = pd.read_csv('04_checkv/quality_summary.tsv', sep='\\t')\n\n# Load active/cryptic classification\nactive = pd.read_csv('05_active_cryptic/active_prophages.tsv', sep='\\t')\ncryptic = pd.read_csv('05_active_cryptic/cryptic_prophages.tsv', sep='\\t')\n\n# Combine\nactive['classification'] = 'Active'\ncryptic['classification'] = 'Cryptic'\nclassification = pd.concat([active, cryptic])\n\n# Merge with CheckV\nsummary = checkv.merge(\n    classification[['prophage_id', 'classification']],\n    left_on='contig_id',\n    right_on='prophage_id',\n    how='left'\n)\n\nsummary['classification'] = summary['classification'].fillna('Unknown')\n\n# Add genome source\nsummary['genome'] = summary['contig_id'].str.split('_').str[0]\n\n# Save\nsummary.to_csv('08_summary/prophage_summary.tsv', sep='\\t', index=False)\n\n# Print summary stats\nprint(\"=== Prophage Analysis Summary ===\\n\")\nprint(f\"Total prophages identified: {len(summary)}\")\nprint(f\"  Active/Functional: {len(summary[summary['classification'] == 'Active'])}\")\nprint(f\"  Cryptic/Degraded: {len(summary[summary['classification'] == 'Cryptic'])}\")\n\nprint(\"\\nQuality distribution:\")\nprint(summary['checkv_quality'].value_counts())\n\nprint(\"\\nCompleteness summary:\")\nprint(f\"  Mean: {summary['completeness'].mean():.1f}%\")\nprint(f\"  Median: {summary['completeness'].median():.1f}%\")\nprint(f\"  Range: {summary['completeness'].min():.1f}% - {summary['completeness'].max():.1f}%\")\n\nprint(\"\\nProphages per genome:\")\nprint(summary.groupby('genome').size().describe())\nEOF\n</code></pre>"},{"location":"tutorials/prophage-identification/#visualize-results","title":"Visualize Results","text":"<pre><code># In R\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load summary\ndata &lt;- read.delim('08_summary/prophage_summary.tsv')\n\n# Plot 1: Prophage lengths by classification\npdf('08_summary/prophage_length_by_type.pdf', width=10, height=6)\nggplot(data, aes(x=classification, y=contig_length/1000, fill=classification)) +\n  geom_boxplot() +\n  labs(x='Prophage Type', y='Length (kb)',\n       title='Prophage Length Distribution by Classification') +\n  theme_minimal() +\n  theme(legend.position='none')\ndev.off()\n\n# Plot 2: Completeness distribution\npdf('08_summary/completeness_distribution.pdf', width=10, height=6)\nggplot(data, aes(x=completeness, fill=classification)) +\n  geom_histogram(bins=20, position='dodge') +\n  labs(x='Completeness (%)', y='Count',\n       title='Prophage Completeness Distribution',\n       fill='Classification') +\n  theme_minimal()\ndev.off()\n\n# Plot 3: Prophages per genome\npdf('08_summary/prophages_per_genome.pdf', width=10, height=6)\nprophage_counts &lt;- data %&gt;%\n  group_by(genome, classification) %&gt;%\n  summarise(count = n(), .groups='drop')\n\nggplot(prophage_counts, aes(x=genome, y=count, fill=classification)) +\n  geom_bar(stat='identity', position='stack') +\n  labs(x='Genome', y='Number of Prophages',\n       title='Prophage Distribution Across Genomes',\n       fill='Classification') +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle=45, hjust=1))\ndev.off()\n\nprint(\"Plots saved to 08_summary/\")\n</code></pre>"},{"location":"tutorials/prophage-identification/#expected-final-results","title":"Expected Final Results","text":""},{"location":"tutorials/prophage-identification/#directory-structure","title":"Directory Structure","text":"<pre><code>~/prophage_tutorial/\n\u251c\u2500\u2500 00_genomes/           # Input bacterial genomes\n\u251c\u2500\u2500 01_genes/             # Gene predictions\n\u251c\u2500\u2500 02_prophages/         # Tool predictions\n\u2502   \u251c\u2500\u2500 phispy/\n\u2502   \u251c\u2500\u2500 phigaro/\n\u2502   \u2514\u2500\u2500 vibrant/\n\u251c\u2500\u2500 03_comparison/        # Consensus predictions\n\u251c\u2500\u2500 04_checkv/            # Quality assessment\n\u251c\u2500\u2500 05_active_cryptic/    # Classification\n\u251c\u2500\u2500 06_annotation/        # Gene annotations\n\u251c\u2500\u2500 07_comparative/       # Comparative analysis\n\u2514\u2500\u2500 08_summary/           # Final results\n</code></pre>"},{"location":"tutorials/prophage-identification/#typical-results-summary","title":"Typical Results Summary","text":"<ul> <li>Input genomes: 10 E. coli strains</li> <li>Total prophages identified: 30-60</li> <li>Active prophages: 15-30 (50-60%)</li> <li>Cryptic prophages: 15-30 (40-50%)</li> <li>Average per genome: 3-6 prophages</li> <li>Range per genome: 0-8 prophages</li> <li>Mean prophage length: 30-45 kb</li> <li>Shared prophages (&gt;95% identical): 5-15 pairs</li> </ul>"},{"location":"tutorials/prophage-identification/#interpreting-your-results","title":"Interpreting Your Results","text":""},{"location":"tutorials/prophage-identification/#normal-prophage-patterns","title":"Normal Prophage Patterns","text":"<p>\u2705 Expected observations: - Most E. coli genomes contain 2-6 prophages - ~50% are functional (active), ~50% are degraded (cryptic) - Prophage sizes range 15-60 kb (most 30-45 kb) - Some prophages are strain-specific, others are shared - Pathogenic strains often have more prophages</p> <p>\u26a0\ufe0f Unusual patterns: - No prophages detected: May be genuinely prophage-free or sequencing/assembly issues - &gt;10 prophages: Unusual but possible; validate carefully - All cryptic: Suggests old integrations and prophage decay - 100% identical between strains: May indicate recent horizontal transfer</p>"},{"location":"tutorials/prophage-identification/#biological-significance","title":"Biological Significance","text":"<p>Active prophages can: - Excise and produce virions - Spread to other bacteria - Carry virulence genes (Shiga toxin, etc.) - Provide immunity to related phages (superinfection exclusion)</p> <p>Cryptic prophages: - Evolutionary remnants - May still carry functional genes - Can contribute to bacterial fitness - Potential raw material for evolution</p>"},{"location":"tutorials/prophage-identification/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/prophage-identification/#problem-too-many-false-positives","title":"Problem: Too Many False Positives","text":"<p>Solutions: <pre><code># Use consensus of \u22652 tools\nbedtools intersect -a tool1.bed -b tool2.bed -f 0.5 -r\n\n# Filter by CheckV quality\nawk -F'\\t' '$8 == \"Complete\" || $8 == \"High-quality\"' quality_summary.tsv\n\n# Increase PhiSpy stringency\nPhiSpy.py --phage_genes 2 ...  # Default is 1\n</code></pre></p>"},{"location":"tutorials/prophage-identification/#problem-missing-known-prophages","title":"Problem: Missing Known Prophages","text":"<p>Solutions: <pre><code># Lower PhiSpy threshold\nPhiSpy.py --phage_genes 0 ...\n\n# Check if prophage region was assembled correctly\n# Prophages at chromosome ends may be split\n\n# Try PHASTER web service (often more sensitive)\n# https://phaster.ca/\n</code></pre></p>"},{"location":"tutorials/prophage-identification/#problem-cant-distinguish-active-from-cryptic","title":"Problem: Can't Distinguish Active from Cryptic","text":"<p>Solutions: - Experimental validation: Induce with mitomycin C or UV, check for virion production - Comparative genomics: Active prophages often show recent horizontal transfer - Gene content: Check for complete lysis cassette, intact structural genes - Expression data: If available, transcriptome/proteome data shows if genes are expressed</p>"},{"location":"tutorials/prophage-identification/#next-steps","title":"Next Steps","text":"<p>Advanced prophage analyses: - Prophage induction experiments (mitomycin C, UV) - Quantify excision rates (qPCR for circular forms) - Metatranscriptomics to assess prophage activity in situ - Comparative genomics across many strains</p> <p>Related tutorials: - Tutorial 1: Basic Metagenome Virome - Detect prophages in metagenomes - Tutorial 5: Host Prediction - Predict hosts for extracted prophages</p>"},{"location":"tutorials/prophage-identification/#further-reading","title":"Further Reading","text":"<ul> <li>Arndt, D., et al. (2016). \"PHASTER: a better, faster version of the PHAST phage search tool.\" Nucleic Acids Research, 44(W1), W16-W21.</li> <li>Akhter, S., et al. (2012). \"PhiSpy: a novel algorithm for finding prophages in bacterial genomes.\" Nucleic Acids Research, 40(16), e126.</li> <li>Kieft, K., et al. (2022). \"vConTACT 2.0: An updated network-based virus taxonomy tool.\" bioRxiv.</li> </ul>"},{"location":"tutorials/rna-virus-discovery/","title":"Tutorial 2: RNA Virus Discovery","text":"<p>Last Updated: November 29, 2025 Level: Intermediate | Time: 6-8 hours | Data Size: 100MB</p>"},{"location":"tutorials/rna-virus-discovery/#overview","title":"Overview","text":"<p>RNA viruses are abundant and diverse, but present unique challenges compared to DNA viruses. This tutorial covers the complete workflow for discovering RNA viruses in metagenomic or transcriptomic data, including specialized methods for handling RNA sequences.</p> <p>What you'll learn: - RNA extraction and quality assessment - RNA-seq specific quality control - Assembly strategies for RNA viral genomes - RdRp (RNA-dependent RNA polymerase)-based virus identification - RNA virus annotation and classification - Phylogenetic placement of novel RNA viruses</p> <p>Sample dataset: Simulated plant RNA virome (single-end Illumina RNA-seq, 150bp, ~3M reads)</p>"},{"location":"tutorials/rna-virus-discovery/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/rna-virus-discovery/#required-software","title":"Required Software","text":"<pre><code># Create environment for RNA virus analysis\nconda create -n rna_virome python=3.9\nconda activate rna_virome\n\n# Install RNA-specific tools\nconda install -c bioconda -c conda-forge \\\n    fastp=0.23.4 \\\n    sortmerna=4.3.6 \\\n    trinity=2.15.1 \\\n    spades=3.15.5 \\\n    blast=2.14.0 \\\n    hmmer=3.3.2 \\\n    mafft=7.505 \\\n    iqtree=2.2.0 \\\n    seqkit=2.5.1 \\\n    cd-hit=4.8.1\n\n# Install RdRp-scan (RNA virus identification)\npip install rdp-scan\n\n# Install palmID (R-based RdRp search)\n# Requires R - install separately if not available\nR -e \"install.packages('palmid')\"\n\n# Install metaviralSPAdes RNA module\n# Already included in SPAdes installation above\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#system-requirements","title":"System Requirements","text":"<ul> <li>RAM: 32GB minimum (RNA assembly is memory-intensive)</li> <li>Disk Space: 100GB free space</li> <li>CPU: 8+ cores recommended</li> <li>OS: Linux or macOS</li> </ul>"},{"location":"tutorials/rna-virus-discovery/#background-knowledge","title":"Background Knowledge","text":"<p>Complete Tutorial 1 first, and review: - Sample Preparation - RNA extraction section - RNA virus biology (Baltimore Classes III, IV, V, VI) - Reverse transcription concepts</p>"},{"location":"tutorials/rna-virus-discovery/#step-1-download-and-prepare-data","title":"Step 1: Download and Prepare Data","text":""},{"location":"tutorials/rna-virus-discovery/#download-test-dataset","title":"Download Test Dataset","text":"<pre><code># Create project directory\nmkdir -p ~/rna_virome_tutorial\ncd ~/rna_virome_tutorial\n\n# Download simulated plant RNA virome dataset\n# Note: Replace with actual Zenodo DOI when dataset is uploaded\nwget https://zenodo.org/record/EXAMPLE/files/plant_rnaseq.fastq.gz\n\n# Verify download\nmd5sum plant_rnaseq.fastq.gz\n# Expected: x9y8z7w6... plant_rnaseq.fastq.gz\n\n# Inspect data\nseqkit stats plant_rnaseq.fastq.gz\n</code></pre> <p>Expected output: <pre><code>file                    format  type  num_seqs      sum_len  min_len  avg_len  max_len\nplant_rnaseq.fastq.gz   FASTQ   DNA  3,000,000  450,000,000      150      150      150\n</code></pre></p>"},{"location":"tutorials/rna-virus-discovery/#step-2-quality-control-for-rna-seq","title":"Step 2: Quality Control for RNA-seq","text":"<p>RNA-seq has specific QC considerations compared to DNA sequencing.</p>"},{"location":"tutorials/rna-virus-discovery/#run-fastp-with-rna-specific-parameters","title":"Run FastP with RNA-specific Parameters","text":"<pre><code># Create QC directory\nmkdir -p 01_qc\n\n# Run fastp optimized for RNA-seq\nfastp \\\n    -i plant_rnaseq.fastq.gz \\\n    -o 01_qc/cleaned_reads.fastq.gz \\\n    -h 01_qc/fastp_report.html \\\n    -j 01_qc/fastp_report.json \\\n    --detect_adapter_for_pe \\\n    --correction \\\n    --cut_front \\\n    --cut_tail \\\n    --cut_window_size 4 \\\n    --cut_mean_quality 25 \\\n    --qualified_quality_phred 25 \\\n    --unqualified_percent_limit 20 \\\n    --length_required 50 \\\n    --thread 8 \\\n    --poly_x_min_len 10\n</code></pre> <p>RNA-specific parameters: - <code>--poly_x_min_len 10</code>: Remove poly-A/T tails (common in RNA-seq) - Higher quality thresholds (Q25 instead of Q20) - More stringent quality filtering</p> <p>Expected results: - Reads passing filter: ~85-90% - Poly-A trimming: 5-15% of reads trimmed - Q30 bases: &gt;95%</p>"},{"location":"tutorials/rna-virus-discovery/#step-3-remove-ribosomal-rna-contamination","title":"Step 3: Remove Ribosomal RNA Contamination","text":"<p>Plant RNA-seq often contains residual rRNA even after rRNA depletion.</p>"},{"location":"tutorials/rna-virus-discovery/#run-sortmerna","title":"Run SortMeRNA","text":"<pre><code># Download rRNA databases (first time only)\nmkdir -p db/sortmerna\ncd db/sortmerna\n\nwget https://github.com/biocore/sortmerna/releases/download/v4.3.6/database.tar.gz\ntar -xzf database.tar.gz\n\ncd ~/rna_virome_tutorial\n\n# Run SortMeRNA to filter rRNA\nsortmerna \\\n    --ref db/sortmerna/smr_v4.3_default_db.fasta \\\n    --reads 01_qc/cleaned_reads.fastq.gz \\\n    --aligned 01_qc/rRNA_reads \\\n    --other 01_qc/non_rRNA_reads \\\n    --workdir 01_qc/sortmerna_work \\\n    --fastx \\\n    --num_alignments 1 \\\n    --threads 8\n\n# Compress output\ngzip 01_qc/non_rRNA_reads.fq\n\n# Check rRNA removal efficiency\necho \"Total reads after QC: $(zcat 01_qc/cleaned_reads.fastq.gz | wc -l | awk '{print $1/4}')\"\necho \"rRNA reads removed: $(cat 01_qc/rRNA_reads.fq | wc -l | awk '{print $1/4}')\"\necho \"Non-rRNA reads retained: $(zcat 01_qc/non_rRNA_reads.fq.gz | wc -l | awk '{print $1/4}')\"\n</code></pre> <p>Expected results: - rRNA contamination: 5-30% of reads (varies by sample prep) - Non-rRNA reads: 70-95% retained for analysis</p> <p>High rRNA Content</p> <p>If &gt;40% of reads are rRNA, this indicates poor rRNA depletion during library prep. Results will still be valid but sequencing depth is effectively reduced.</p>"},{"location":"tutorials/rna-virus-discovery/#step-4-rna-virus-assembly","title":"Step 4: RNA Virus Assembly","text":"<p>RNA virus genomes are typically smaller and have different assembly characteristics than DNA viruses.</p>"},{"location":"tutorials/rna-virus-discovery/#41-de-novo-assembly-with-trinity","title":"4.1 De Novo Assembly with Trinity","text":"<p>Trinity is optimized for transcriptome assembly and works well for RNA viruses.</p> <pre><code># Create assembly directory\nmkdir -p 02_assembly\n\n# Run Trinity (RNA-seq assembler)\nTrinity \\\n    --seqType fq \\\n    --single 01_qc/non_rRNA_reads.fq.gz \\\n    --max_memory 32G \\\n    --CPU 8 \\\n    --output 02_assembly/trinity \\\n    --full_cleanup\n\n# Trinity outputs to specific filename\nmv 02_assembly/trinity/Trinity.fasta 02_assembly/trinity_contigs.fasta\n</code></pre> <p>Trinity parameters: - <code>--seqType fq</code>: Input format (FASTQ) - <code>--single</code>: Single-end reads (use <code>--left</code> and <code>--right</code> for paired-end) - <code>--max_memory 32G</code>: Maximum memory - <code>--full_cleanup</code>: Remove intermediate files to save space</p> <p>Assembly runtime: 2-4 hours</p>"},{"location":"tutorials/rna-virus-discovery/#42-alternative-metaviralspades-rna-mode","title":"4.2 Alternative: metaviralSPAdes RNA Mode","text":"<pre><code># Run metaviralSPAdes with RNA mode\nspades.py \\\n    --rna \\\n    --s1 01_qc/non_rRNA_reads.fq.gz \\\n    -o 02_assembly/spades_rna \\\n    -t 8 \\\n    -m 32 \\\n    -k 21,33,55\n\n# Copy contigs\ncp 02_assembly/spades_rna/transcripts.fasta 02_assembly/spades_contigs.fasta\n</code></pre> <p>Choosing an Assembler</p> <ul> <li>Trinity: Better for diverse RNA virus communities, more sensitive</li> <li>metaviralSPAdes: Faster, good for high-abundance viruses</li> <li>Best approach: Run both and combine results</li> </ul>"},{"location":"tutorials/rna-virus-discovery/#43-combine-assemblies-optional","title":"4.3 Combine Assemblies (Optional)","text":"<pre><code># Concatenate assemblies\ncat 02_assembly/trinity_contigs.fasta \\\n    02_assembly/spades_contigs.fasta \\\n    &gt; 02_assembly/combined_contigs.fasta\n\n# Remove redundancy with CD-HIT-EST\ncd-hit-est \\\n    -i 02_assembly/combined_contigs.fasta \\\n    -o 02_assembly/combined_nr.fasta \\\n    -c 0.95 \\\n    -n 10 \\\n    -T 8 \\\n    -M 16000\n\n# Use non-redundant set for downstream analysis\ncp 02_assembly/combined_nr.fasta 02_assembly/contigs_final.fasta\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#filter-contigs","title":"Filter Contigs","text":"<pre><code># Filter contigs \u2265500bp (RNA viruses can be small)\nseqkit seq -m 500 02_assembly/contigs_final.fasta \\\n    &gt; 02_assembly/contigs_500bp.fasta\n\n# Get assembly statistics\nseqkit stats 02_assembly/contigs_500bp.fasta\n</code></pre> <p>Expected results: <pre><code>file                     format  type  num_seqs    sum_len  min_len  avg_len  max_len\ncontigs_500bp.fasta      FASTA   DNA      8,456  5,234,567      500      619   25,678\n</code></pre></p> <ul> <li>Total contigs \u2265500bp: 5,000-10,000</li> <li>Longest contig: 15-30 kb</li> <li>N50: 800-1,500 bp</li> </ul>"},{"location":"tutorials/rna-virus-discovery/#step-5-rna-virus-identification","title":"Step 5: RNA Virus Identification","text":"<p>RNA viruses encode characteristic proteins, particularly RNA-dependent RNA polymerase (RdRp).</p>"},{"location":"tutorials/rna-virus-discovery/#51-rdrp-based-identification-with-rdrp-scan","title":"5.1 RdRp-Based Identification with RdRp-scan","text":"<pre><code># Create viral ID directory\nmkdir -p 03_viral_id\n\n# Predict ORFs with Prodigal (metagenomic mode)\nprodigal \\\n    -i 02_assembly/contigs_500bp.fasta \\\n    -a 03_viral_id/proteins.faa \\\n    -p meta \\\n    -q\n\n# Download RdRp database (first time only)\nmkdir -p db/rdrp\ncd db/rdrp\nwget http://s3.climb.ac.uk/ADM_share/profile_db/rdrp_search/rdrp_profile_db.tar.gz\ntar -xzf rdrp_profile_db.tar.gz\ncd ~/rna_virome_tutorial\n\n# Run RdRp-scan\nrdrp_scan \\\n    -i 03_viral_id/proteins.faa \\\n    -o 03_viral_id/rdrp_scan_results \\\n    -d db/rdrp/rdrp_profile_db \\\n    -e 1e-5 \\\n    -t 8\n</code></pre> <p>Expected output: - Contigs with RdRp: 50-200 - E-value range: Most &lt;1e-20 (high confidence) - Output files:   - <code>rdrp_hits.txt</code>: List of contigs with RdRp   - <code>rdrp_alignments.txt</code>: Detailed alignments</p>"},{"location":"tutorials/rna-virus-discovery/#52-extract-rdrp-positive-contigs","title":"5.2 Extract RdRp-Positive Contigs","text":"<pre><code># Extract contig IDs with RdRp hits\ncut -f1 03_viral_id/rdrp_scan_results/rdrp_hits.txt | \\\n    sed 's/_[0-9]*$//' | \\\n    sort -u &gt; 03_viral_id/rdrp_contig_ids.txt\n\n# Extract RdRp-positive contigs\nseqkit grep -f 03_viral_id/rdrp_contig_ids.txt \\\n    02_assembly/contigs_500bp.fasta \\\n    &gt; 03_viral_id/rdrp_positive_contigs.fasta\n\n# Count\nwc -l 03_viral_id/rdrp_contig_ids.txt\n</code></pre> <p>Expected: 50-200 RdRp-positive contigs</p>"},{"location":"tutorials/rna-virus-discovery/#53-blast-based-validation","title":"5.3 BLAST-Based Validation","text":"<pre><code># Download RNA virus database\nmkdir -p db/rna_virus\ncd db/rna_virus\n\n# Download NCBI RefSeq RNA viruses\n# Filtering for Baltimore Classes III, IV, V, VI\nwget ftp://ftp.ncbi.nlm.nih.gov/refseq/release/viral/viral.*.genomic.fna.gz\nzcat viral.*.genomic.fna.gz &gt; all_viral.fna\n\n# Filter for RNA viruses (you may need to do this manually or use taxonomy)\n# For this tutorial, we'll use all viral sequences\nmakeblastdb -in all_viral.fna -dbtype nucl -out rna_virus_db\n\ncd ~/rna_virome_tutorial\n\n# BLAST RdRp-positive contigs\nblastn \\\n    -query 03_viral_id/rdrp_positive_contigs.fasta \\\n    -db db/rna_virus/rna_virus_db \\\n    -out 03_viral_id/blast_results.txt \\\n    -outfmt '6 qseqid sseqid pident length evalue bitscore stitle' \\\n    -evalue 1e-5 \\\n    -num_threads 8 \\\n    -max_target_seqs 3\n\n# Extract best hit per query\nsort -k1,1 -k6,6gr 03_viral_id/blast_results.txt | \\\n    sort -u -k1,1 &gt; 03_viral_id/blast_best_hits.txt\n\n# Analyze hit distribution\necho \"Total RdRp+ contigs: $(wc -l &lt; 03_viral_id/rdrp_contig_ids.txt)\"\necho \"Contigs with BLAST hit: $(cut -f1 03_viral_id/blast_best_hits.txt | wc -l)\"\necho \"High similarity (&gt;80%): $(awk '$3 &gt; 80' 03_viral_id/blast_best_hits.txt | wc -l)\"\necho \"Medium similarity (50-80%): $(awk '$3 &gt; 50 &amp;&amp; $3 &lt;= 80' 03_viral_id/blast_best_hits.txt | wc -l)\"\necho \"Low similarity (&lt;50%): $(awk '$3 &lt;= 50' 03_viral_id/blast_best_hits.txt | wc -l)\"\n</code></pre> <p>Expected distribution: - BLAST hits: 60-80% of RdRp+ contigs - High similarity (&gt;80%): 20-40% (known viruses) - Medium similarity (50-80%): 30-50% (related viruses) - Low similarity (&lt;50%): 10-20% (distant relatives) - No BLAST hit: 20-40% (novel RNA viruses)</p>"},{"location":"tutorials/rna-virus-discovery/#step-6-rna-virus-genome-completeness","title":"Step 6: RNA Virus Genome Completeness","text":"<p>Unlike DNA viruses, we don't have CheckV for RNA viruses. We'll assess completeness manually.</p>"},{"location":"tutorials/rna-virus-discovery/#assess-genome-completeness","title":"Assess Genome Completeness","text":"<pre><code># Create completeness directory\nmkdir -p 04_completeness\n\n# Check for presence of key genes (RdRp, capsid, etc.)\n# Run HMMER against Pfam or custom RNA virus HMMs\n\n# Download Pfam database (if not already present)\nmkdir -p db/pfam\ncd db/pfam\nwget http://ftp.ebi.ac.uk/pub/databases/Pfam/current_release/Pfam-A.hmm.gz\ngunzip Pfam-A.hmm.gz\nhmmpress Pfam-A.hmm\ncd ~/rna_virome_tutorial\n\n# Search for RNA virus protein families\nhmmsearch \\\n    --tblout 04_completeness/pfam_hits.txt \\\n    -E 1e-5 \\\n    --cpu 8 \\\n    db/pfam/Pfam-A.hmm \\\n    03_viral_id/proteins.faa\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#manual-completeness-assessment","title":"Manual Completeness Assessment","text":"<pre><code># Extract contigs with multiple viral genes (more likely complete)\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Define RNA virus marker genes (Pfam IDs)\nrna_virus_markers = {\n    'PF00680': 'RdRp_1',\n    'PF00978': 'RdRp_2',\n    'PF00073': 'RdRp_3',\n    'PF04196': 'RdRp_4',\n    'PF00073': 'RdRp_5',\n    'PF00910': 'RNA_helicase',\n    'PF00073': 'Peptidase',\n    'PF00073': 'Capsid'\n}\n\n# Load HMMER results\nhits = []\nwith open('04_completeness/pfam_hits.txt') as f:\n    for line in f:\n        if line.startswith('#'):\n            continue\n        fields = line.strip().split()\n        protein_id = fields[0]\n        pfam_id = fields[1]\n        evalue = float(fields[4])\n\n        if evalue &lt; 1e-5:\n            hits.append((protein_id, pfam_id, evalue))\n\n# Extract contig IDs and count markers\ncontig_markers = {}\nfor protein_id, pfam_id, evalue in hits:\n    # Extract contig ID (assuming format: contigID_geneNumber)\n    contig_id = '_'.join(protein_id.split('_')[:-1])\n\n    if pfam_id in rna_virus_markers:\n        if contig_id not in contig_markers:\n            contig_markers[contig_id] = set()\n        contig_markers[contig_id].add(rna_virus_markers[pfam_id])\n\n# Assess completeness\ncomplete_contigs = []\npartial_contigs = []\n\nfor contig_id, markers in contig_markers.items():\n    marker_count = len(markers)\n\n    if marker_count &gt;= 3:  # At least 3 RNA virus markers\n        complete_contigs.append((contig_id, marker_count, ','.join(markers)))\n    elif marker_count &gt;= 1:\n        partial_contigs.append((contig_id, marker_count, ','.join(markers)))\n\n# Save results\nwith open('04_completeness/complete_contigs.txt', 'w') as f:\n    for contig_id, count, markers in complete_contigs:\n        f.write(f\"{contig_id}\\t{count}\\t{markers}\\n\")\n\nprint(f\"Contigs with \u22653 markers (likely complete): {len(complete_contigs)}\")\nprint(f\"Contigs with 1-2 markers (partial): {len(partial_contigs)}\")\nEOF\n\n# Extract likely complete genomes\ncut -f1 04_completeness/complete_contigs.txt &gt; 04_completeness/complete_contig_ids.txt\n\nseqkit grep -f 04_completeness/complete_contig_ids.txt \\\n    03_viral_id/rdrp_positive_contigs.fasta \\\n    &gt; 04_completeness/complete_rna_viruses.fasta\n</code></pre> <p>Expected results: - Likely complete genomes (\u22653 markers): 10-50 - Partial genomes (1-2 markers): 40-150</p>"},{"location":"tutorials/rna-virus-discovery/#step-7-rna-virus-classification","title":"Step 7: RNA Virus Classification","text":""},{"location":"tutorials/rna-virus-discovery/#71-taxonomic-assignment-based-on-blast","title":"7.1 Taxonomic Assignment Based on BLAST","text":"<pre><code># Create taxonomy directory\nmkdir -p 05_taxonomy\n\n# Analyze BLAST results for taxonomy\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load BLAST results\nblast = pd.read_csv('03_viral_id/blast_best_hits.txt', sep='\\t', header=None,\n                    names=['qseqid', 'sseqid', 'pident', 'length', 'evalue', 'bitscore', 'stitle'])\n\n# Extract virus family from subject title (manual parsing)\ndef extract_family(title):\n    # Common RNA virus families\n    families = ['Picornaviridae', 'Flaviviridae', 'Coronaviridae', 'Rhabdoviridae',\n                'Paramyxoviridae', 'Orthomyxoviridae', 'Bunyaviridae', 'Reoviridae',\n                'Togaviridae', 'Caliciviridae', 'Astroviridae', 'Hepeviridae']\n\n    for family in families:\n        if family.lower() in title.lower():\n            return family\n    return 'Unknown'\n\nblast['family'] = blast['stitle'].apply(extract_family)\n\n# Summarize taxonomy\nprint(\"\\nTaxonomic distribution (based on best BLAST hits):\")\nprint(blast['family'].value_counts())\n\n# Save taxonomy table\nblast[['qseqid', 'pident', 'family', 'stitle']].to_csv(\n    '05_taxonomy/rna_virus_taxonomy.tsv', sep='\\t', index=False)\nEOF\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#72-phylogenetic-analysis-of-rdrp","title":"7.2 Phylogenetic Analysis of RdRp","text":"<p>For publication-quality classification, place your viruses phylogenetically.</p> <pre><code># Extract RdRp protein sequences\n# Assuming we have RdRp coordinates from RdRp-scan\nseqkit grep -r -p \"RdRp\" 03_viral_id/proteins.faa \\\n    &gt; 05_taxonomy/rdrp_proteins.faa\n\n# Download reference RdRp sequences (curated set)\n# You would normally use a published RdRp reference set\n# For this tutorial, we'll use top BLAST hits as references\n\n# Extract reference RdRps from BLAST results\ncut -f2 03_viral_id/blast_best_hits.txt | head -n 50 &gt; 05_taxonomy/ref_accessions.txt\n\n# Fetch reference sequences (requires internet and NCBI E-utilities)\n# Simplified for tutorial - you'd use efetch in practice\n\n# Combine query and reference RdRps\n# cat 05_taxonomy/rdrp_proteins.faa reference_rdrps.faa &gt; 05_taxonomy/all_rdrps.faa\n\n# Align with MAFFT\nmafft \\\n    --auto \\\n    --thread 8 \\\n    05_taxonomy/rdrp_proteins.faa \\\n    &gt; 05_taxonomy/rdrp_alignment.faa\n\n# Trim alignment (remove poorly aligned regions)\n# trimal -in 05_taxonomy/rdrp_alignment.faa -out 05_taxonomy/rdrp_alignment_trimmed.faa -automated1\n\n# Build phylogenetic tree with IQ-TREE\niqtree \\\n    -s 05_taxonomy/rdrp_alignment.faa \\\n    -m TEST \\\n    -bb 1000 \\\n    -nt 8 \\\n    -pre 05_taxonomy/rdrp_tree\n</code></pre> <p>IQ-TREE parameters: - <code>-m TEST</code>: Automatically select best substitution model - <code>-bb 1000</code>: 1000 ultrafast bootstrap replicates - <code>-nt 8</code>: Number of threads</p> <p>Output files: - <code>rdrp_tree.treefile</code>: Best ML tree (Newick format) - <code>rdrp_tree.iqtree</code>: Detailed analysis log - <code>rdrp_tree.contree</code>: Consensus tree</p> <p>Visualize tree:</p> <pre><code># In R\nlibrary(ape)\nlibrary(ggtree)\n\n# Load tree\ntree &lt;- read.tree('05_taxonomy/rdrp_tree.treefile')\n\n# Plot\npdf('05_taxonomy/rdrp_phylogeny.pdf', width=12, height=16)\nggtree(tree, layout='rectangular') +\n  geom_tiplab(size=2) +\n  geom_treescale() +\n  theme_tree2()\ndev.off()\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#step-8-abundance-estimation","title":"Step 8: Abundance Estimation","text":"<pre><code># Create abundance directory\nmkdir -p 06_abundance\n\n# Map reads to RdRp-positive contigs\n# Index contigs\nbwa index 03_viral_id/rdrp_positive_contigs.fasta\n\n# Map reads\nbwa mem \\\n    -t 8 \\\n    03_viral_id/rdrp_positive_contigs.fasta \\\n    01_qc/non_rRNA_reads.fq.gz \\\n    | samtools view -bS - \\\n    | samtools sort -o 06_abundance/mapped_sorted.bam\n\nsamtools index 06_abundance/mapped_sorted.bam\n\n# Calculate coverage\nsamtools depth 06_abundance/mapped_sorted.bam \\\n    &gt; 06_abundance/coverage_per_base.txt\n\n# Calculate mean coverage per contig\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load coverage data\ncov = pd.read_csv('06_abundance/coverage_per_base.txt', sep='\\t',\n                  header=None, names=['contig', 'pos', 'depth'])\n\n# Calculate mean coverage per contig\nmean_cov = cov.groupby('contig')['depth'].agg(['mean', 'std', 'max']).reset_index()\nmean_cov.columns = ['contig_id', 'mean_coverage', 'std_coverage', 'max_coverage']\n\n# Save\nmean_cov.to_csv('06_abundance/contig_coverage.tsv', sep='\\t', index=False)\n\n# Summary\nprint(f\"Contigs with coverage: {len(mean_cov)}\")\nprint(f\"High coverage (&gt;100x): {len(mean_cov[mean_cov['mean_coverage'] &gt; 100])}\")\nprint(f\"Medium coverage (10-100x): {len(mean_cov[(mean_cov['mean_coverage'] &gt;= 10) &amp; (mean_cov['mean_coverage'] &lt;= 100)])}\")\nprint(f\"Low coverage (&lt;10x): {len(mean_cov[mean_cov['mean_coverage'] &lt; 10])}\")\n\n# Top 10 most abundant\nprint(\"\\nTop 10 most abundant RNA viruses:\")\nprint(mean_cov.nlargest(10, 'mean_coverage')[['contig_id', 'mean_coverage']])\nEOF\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#step-9-summary-and-functional-annotation","title":"Step 9: Summary and Functional Annotation","text":""},{"location":"tutorials/rna-virus-discovery/#create-comprehensive-summary","title":"Create Comprehensive Summary","text":"<pre><code># Create summary directory\nmkdir -p 07_summary\n\n# Combine all results\npython3 &lt;&lt; 'EOF'\nimport pandas as pd\n\n# Load contig info\nfrom Bio import SeqIO\ncontigs_info = {}\nfor record in SeqIO.parse('03_viral_id/rdrp_positive_contigs.fasta', 'fasta'):\n    contigs_info[record.id] = len(record.seq)\n\ncontig_df = pd.DataFrame(list(contigs_info.items()), columns=['contig_id', 'length'])\n\n# Load RdRp scan results\n# Simplified - would parse actual RdRp-scan output\n# For tutorial, we'll use the IDs we extracted\nrdrp_ids = pd.read_csv('03_viral_id/rdrp_contig_ids.txt', header=None, names=['contig_id'])\nrdrp_ids['has_rdrp'] = True\n\n# Load BLAST results\nblast = pd.read_csv('03_viral_id/blast_best_hits.txt', sep='\\t', header=None,\n                    names=['contig_id', 'subject', 'pident', 'length', 'evalue', 'bitscore', 'description'])\n\n# Load completeness\ncomplete = pd.read_csv('04_completeness/complete_contigs.txt', sep='\\t', header=None,\n                       names=['contig_id', 'marker_count', 'markers'])\ncomplete['completeness'] = 'Complete (\u22653 markers)'\n\n# Load taxonomy\ntaxonomy = pd.read_csv('05_taxonomy/rna_virus_taxonomy.tsv', sep='\\t')\n\n# Load abundance\nabundance = pd.read_csv('06_abundance/contig_coverage.tsv', sep='\\t')\n\n# Merge all\nsummary = contig_df.merge(rdrp_ids, on='contig_id', how='left')\nsummary = summary.merge(blast[['contig_id', 'pident', 'description']], on='contig_id', how='left')\nsummary = summary.merge(complete[['contig_id', 'completeness', 'marker_count']], on='contig_id', how='left')\nsummary = summary.merge(taxonomy[['qseqid', 'family']], left_on='contig_id', right_on='qseqid', how='left')\nsummary = summary.merge(abundance[['contig_id', 'mean_coverage']], on='contig_id', how='left')\n\n# Fill NaN\nsummary['completeness'] = summary['completeness'].fillna('Partial')\nsummary['family'] = summary['family'].fillna('Unknown')\nsummary['pident'] = summary['pident'].fillna(0)\n\n# Sort by abundance\nsummary = summary.sort_values('mean_coverage', ascending=False)\n\n# Save\nsummary.to_csv('07_summary/rna_virus_summary.tsv', sep='\\t', index=False)\n\nprint(f\"Total RdRp-positive contigs: {len(summary)}\")\nprint(f\"Likely complete genomes: {len(summary[summary['completeness'].str.contains('Complete')])}\")\nprint(f\"Known viruses (&gt;80% identity): {len(summary[summary['pident'] &gt; 80])}\")\nprint(f\"Novel viruses (no BLAST hit): {len(summary[summary['pident'] == 0])}\")\n\nprint(\"\\nTop 10 RNA viruses by abundance:\")\nprint(summary[['contig_id', 'length', 'family', 'pident', 'mean_coverage', 'completeness']].head(10))\nEOF\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#expected-final-results","title":"Expected Final Results","text":""},{"location":"tutorials/rna-virus-discovery/#directory-structure","title":"Directory Structure","text":"<pre><code>~/rna_virome_tutorial/\n\u251c\u2500\u2500 01_qc/\n\u2502   \u251c\u2500\u2500 cleaned_reads.fastq.gz\n\u2502   \u2514\u2500\u2500 non_rRNA_reads.fq.gz\n\u251c\u2500\u2500 02_assembly/\n\u2502   \u2514\u2500\u2500 contigs_500bp.fasta\n\u251c\u2500\u2500 03_viral_id/\n\u2502   \u251c\u2500\u2500 rdrp_positive_contigs.fasta\n\u2502   \u2514\u2500\u2500 blast_best_hits.txt\n\u251c\u2500\u2500 04_completeness/\n\u2502   \u2514\u2500\u2500 complete_rna_viruses.fasta\n\u251c\u2500\u2500 05_taxonomy/\n\u2502   \u251c\u2500\u2500 rna_virus_taxonomy.tsv\n\u2502   \u2514\u2500\u2500 rdrp_tree.treefile\n\u251c\u2500\u2500 06_abundance/\n\u2502   \u2514\u2500\u2500 contig_coverage.tsv\n\u2514\u2500\u2500 07_summary/\n    \u2514\u2500\u2500 rna_virus_summary.tsv\n</code></pre>"},{"location":"tutorials/rna-virus-discovery/#typical-results","title":"Typical Results","text":"<ul> <li>Input reads: 3,000,000</li> <li>After QC: ~2,550,000 (85%)</li> <li>After rRNA removal: ~2,040,000 (80% of QC reads)</li> <li>Assembled contigs \u2265500bp: 5,000-10,000</li> <li>RdRp-positive contigs: 50-200</li> <li>Likely complete genomes: 10-50</li> <li>Novel RNA viruses: 20-40% with no BLAST hit</li> </ul>"},{"location":"tutorials/rna-virus-discovery/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/rna-virus-discovery/#problem-very-few-rdrp-hits","title":"Problem: Very Few RdRp Hits","text":"<p>Solutions: <pre><code># Lower RdRp-scan e-value threshold\nrdrp_scan ... -e 1e-3  # instead of 1e-5\n\n# Try alternative RdRp databases\n# Use palmID from Serratus project\n</code></pre></p>"},{"location":"tutorials/rna-virus-discovery/#problem-high-rrna-contamination","title":"Problem: High rRNA Contamination","text":"<p>Solutions: <pre><code># More stringent rRNA filtering\nsortmerna --best 1 --num_alignments 1 ...\n\n# Multiple rounds of filtering\nsortmerna ... # Round 1\nsortmerna --reads output_from_round1.fq ... # Round 2\n</code></pre></p>"},{"location":"tutorials/rna-virus-discovery/#problem-fragmented-assembly","title":"Problem: Fragmented Assembly","text":"<p>Solutions: <pre><code># Increase k-mer sizes for SPAdes\nspades.py --rna -k 25,35,45,55,65,75 ...\n\n# Use Trinity (better for complex transcriptomes)\nTrinity --max_memory 64G --CPU 16 ...\n</code></pre></p>"},{"location":"tutorials/rna-virus-discovery/#next-steps","title":"Next Steps","text":"<p>Advanced RNA virus analyses: - Recombination detection (RDP, SimPlot) - Secondary structure prediction (RNAfold) - Viral strain analysis (variant calling)</p> <p>Related tutorials: - Tutorial 4: Comparative Virome - Compare RNA viruses across samples - Tutorial 5: Host Prediction - Predict eukaryotic hosts</p>"},{"location":"tutorials/rna-virus-discovery/#further-reading","title":"Further Reading","text":"<ul> <li>Wolf, Y. I., et al. (2018). \"Origins and evolution of the global RNA virome.\" mBio, 9(6), e02329-18.</li> <li>Mushegian, A., &amp; Elena, S. F. (2015). \"Evolution of plant virus movement proteins from the 30K superfamily and of their homologs integrated in plant genomes.\" Virology, 476, 304-315.</li> <li>Krishnamurthy, S. R., &amp; Wang, D. (2017). \"Origins and challenges of viral dark matter.\" Virus Research, 239, 136-142.</li> </ul>"}]}